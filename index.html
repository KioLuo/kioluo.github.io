<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="gogogo~">
<meta property="og:type" content="website">
<meta property="og:title" content="KioLuo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="KioLuo">
<meta property="og:description" content="gogogo~">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KioLuo">
<meta name="twitter:description" content="gogogo~">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> KioLuo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KioLuo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">hahaha~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/学习笔记-数据库开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KioLuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://b-ssl.duitang.com/uploads/item/201602/18/20160218194039_c2Kmt.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KioLuo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/13/学习笔记-数据库开发/" itemprop="url">
                  学习笔记--数据库开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T19:05:25+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>//JDBC基础</strong></p>
<p>JDBC URL</p>
<p>jdbc:mysql://:/database</p>
<p>jdbc:oracle:thin:@::database</p>
<p>jdbc:microsoft:sqlserver://:; DatabaseName=database</p>
<p>常用方法：</p>
<p>Statement stmt = conn.createStatement();</p>
<p>ResultSet rs = stmt.executeQuery(“select userName from user“);</p>
<p>ResultSet常用方法：</p>
<p>.next();</p>
<p>.previous();</p>
<p>.absolute();</p>
<p>.beforeFirst();</p>
<p>.afterLast();</p>
<p>.getString(ColumnName/Index);</p>
<p>.getInt(ColumnName/Index);</p>
<p>.getObject(ColumnName/Index);</p>
<p>构建步骤：</p>
<p>1. 装载驱动程序</p>
<p>Class.forName(“com.mysql.jdbc.Driver”);</p>
<p>2. 建立数据库连接</p>
<p>Connection conn = DriverManager.getConnection(“jdbc:mysql://localhost:1234/database”, user, password);</p>
<p>3. 执行SQL语句</p>
<p>Statement stmt = conn.createStatement();           //java.sql包</p>
<p>ResultSet rs = stmt.executeQuery(“select userName from user”);</p>
<p>4. 获取执行结果</p>
<p>while (rs.next()) {</p>
<pre><code>System.out.println(&quot;Hello &quot; + rs.getString(&quot;userName&quot;));
</code></pre><p>}</p>
<p>5. 清理环境</p>
<p>conn.close();         //一般需判断不为null，需要放在异常处理的finally中</p>
<p>stmt.close();</p>
<p>rs.close();</p>
<p><strong>//JDBC进阶</strong></p>
<p>游标提供一种客户端读取部分服务器端结果集的机制</p>
<p>DB_URL = jdbc:mysql://:/database?useCursorFetch=true             //开启游标</p>
<p>利用PreparedStatement</p>
<p>.setFetchSize(1);</p>
<p>对于大对象的读取，采用流方式</p>
<p>ResultSet.getBinaryStream(“columnName”)</p>
<p>一次性往数据库中插入大量数据，采用批处理</p>
<p>Statement</p>
<p>.addBatch()</p>
<p>.executeBatch()</p>
<p>.clearBatch()</p>
<p>字符集编码</p>
<p>mysql语句：</p>
<p>show variables like ‘%character%’;        //显示字符集编码信息，优先级别：column&gt;table&gt;database&gt;server</p>
<p>show create table user;</p>
<p>JDBC设置：</p>
<p>DB_URL = DB_URL + characterEncoding=utf8</p>
<p><strong>//数据库连接池</strong></p>
<p>DBCP连接池，Tomcat的连接池组件，由三个jar包组成：</p>
<p>commons-dbcp.jar</p>
<p>commons-pool.jar</p>
<p>commons-logging.jar</p>
<p>创建BasicDataSource对象：</p>
<pre><code>public static BasicDataSource ds = null;

ds = new BasicDataSource();

ds.setUrl(DB_URL);

ds.setDriverClassName(JDBC_DRIVER);

ds.setUsername(USER);

ds.setPassword(PASSWORD);
</code></pre><p>创建连接：</p>
<pre><code>conn = ds.getConnection();

...同JDBC基础
</code></pre><p>DBCP高级配置</p>
<p>BasicDataSource</p>
<p>.setInitialSize()          //设置初始连接数</p>
<p>.setMaxTotal()         //设置最大连接数</p>
<p>.setMaxWaitMillis()        //设置最大等待时间</p>
<p>.setMaxIdle()         //设置最大空闲连接数</p>
<p>.setMinIdle()        //设置最小空闲连接数，一般设置与最大空闲相同</p>
<p>DBCP定期检查</p>
<p>BasicDataSource</p>
<p>.setTestWhiteIdle(true)          //开启检查线程是否为有效的功能</p>
<p>.setMinEvictableIdleTimeMillis()     //设置关闭数据库连接的空闲时间阈值</p>
<p>.setTimeBetweenEvictionRunMillis()      //设置检查运行时间的间隔，一般小于默认最小空闲连接时间8小时</p>
<p><strong>//SQL注入与防范</strong></p>
<p>SQL注入例子：</p>
<p>在SQL语句拼接中，userName = “zhangsan’;#”，欺骗服务器</p>
<p>SQL注入防范：</p>
<p>使用PreparedStatement:</p>
<pre><code>PreparedStatement ptmt = null;

ptmt = conn.prepareStatement(&quot;select * from user where userName = ? and password = ?&quot;);

ptmt.setString(1, userName);

ptmt.setString(2, password);

rs = ptmt.executeQuery();
</code></pre><p><strong>//事务</strong></p>
<p>JDBC事务控制</p>
<p>Connection</p>
<p>.setAutoCommit(false)             //开启事务，默认为true即未开启事务，设置为false为开启事务</p>
<p>.commit()              //提交事务</p>
<p>.rollback()                //回滚事务</p>
<p>检查点</p>
<p>Savepoint sp = conn.setSavepoint();         //设置检查点</p>
<p>conn.rollback(sp);                    //回滚到检查点状态</p>
<p>脏读，不可重复读，幻读</p>
<p>事务并发执行</p>
<p>事务隔离级别：</p>
<p>读未提交（read uncommitted）</p>
<p>读提交 (read committed)</p>
<p>重复读（repeatable read）</p>
<p>串行化（serializable）</p>
<p>默认级别为重复读，级别越高，数据库性能越差</p>
<p>设置隔离级别：</p>
<p>Connection</p>
<p>.getTransactionIsolation()</p>
<p>.setTransactionIsolation()</p>
<p>死锁</p>
<p>死锁的必要条件：</p>
<p>互斥，请求和保持，不剥夺，环路等待</p>
<p>外部加锁：</p>
<p>共享锁（S）：select * from table lock in share mode</p>
<p>排他锁（X）：select * from table for update</p>
<p>内部加锁：</p>
<p>数据库系统为实现ACID特性自动添加</p>
<p>快照读：支持不加锁，select * from table为快照读</p>
<p>当前读：可能加锁</p>
<p>解决死锁方法：强制回滚代价小的事务</p>
<p>分析死锁方法：show engine innodb status</p>
<p><strong>//Mybatis</strong></p>
<p>ORM框架</p>
<p>SqlSessionFactory配置，xml文件内容：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;jdbc&quot; /&gt;
            &lt;!-- 配置数据库连接信息 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;qiyao.luo&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
&lt;/configuration&gt;    
</code></pre><p>创建Java对象与SQL语句映射关系配置文件，xml文件内容：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.micro.profession.mybatis.GetUserInfo&quot;&gt;
    &lt;!-- 在select标签中编写查询的SQL语句，设置select标签的id属性为getUser，
         resultType=&quot;MyBatisTest.User&quot;就表示将查询结果封装成一个User类 --&gt;
    &lt;!-- 根据id查询得到一个user对象 --&gt;
    &lt;select id=&quot;getUser&quot; parameterType=&quot;int&quot; resultType=&quot;com.micro.profession.mybatis.User&quot;&gt;
    select id, userName, corp from user where id =#{id}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>注册配置文件</p>
<p>在SqlSessionFactory的配置文件中加入</p>
<pre><code>&lt;mappers&gt;
    &lt;mapper resource=&quot;com/micro/profession/mybatis/userMapper.xml&quot; /&gt;
&lt;/mappers&gt;
</code></pre><p><strong>Mybatis使用步骤：</strong></p>
<pre><code>//1. 声明配置文件的目录

String resource = &quot;conf.xml&quot;;

//2. 加载应用配置文件

InputStream is = HelloMybatis.class.getClassLoader().getResourceAsStream(resource);

//3. 创建SqlSessionFactory

SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);

//4. 获取session

SqlSession session = sessionFactory.openSession();

//5. 获取操作类

GetUserInfo getUserInfo = session.getMapper(GetUserInfo.class);

User user = getUserInfo.getUser(2);

System.out.println(user.getId() + &quot; &quot; + user.getUserName() + &quot; &quot; + user.getPassword());

session.close();
</code></pre><p><strong>采用注解的方法进行映射：</strong></p>
<pre><code>@Select(&quot;select * from user where user_id = #{id}&quot;)

public User getUser(int id);
</code></pre><p>使用方法：</p>
<p>在原来使用步骤基础上插入：</p>
<pre><code>SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is); 

Configuration conf = sessionFactory.getConfiguration();

conf.addMapper(GetUserInfoAnnotation.class);

SqlSession session = sessionFactory.openSession();  
</code></pre><p><strong>其他操作，增删查改：</strong></p>
<p>select user_id, userName, password from user where user_id =#{user_id}</p>
<p>insert into user (userName, password) values(#{userName}, #{password})</p>
<p>update user set userName = #{userName}, password = #{password} where user_id = #{user_id}</p>
<p>delete from user where user_id = #{user_id}</p>
<p>使用实例：</p>
<pre><code>//1. 声明配置文件的目录

String resource = &quot;conf.xml&quot;;

//2. 加载应用配置文件

InputStream is = HelloMybatis.class.getClassLoader().getResourceAsStream(resource);

//3. 创建SqlSessionFactory

SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);

//4. 获取session

SqlSession session = sessionFactory.openSession(true);

//5. 获取操作类

GetUserInfo getUserInfo = session.getMapper(GetUserInfo.class);

//插入用户

User user = new User(&quot;xiaoming&quot;, &quot;123456&quot;);

getUserInfo.addUser(user);

System.out.println(user.getId());

//查询用户

user = getUserInfo.getUser(user.getId());

System.out.println(user.getId() + &quot; &quot; + user.getUserName() + &quot; &quot; + user.getPassword());

//更改用户

user.setUserName(&quot;LiMing&quot;);

getUserInfo.updateUser(user);

//删除用户

getUserInfo.deleteUser(user);

//关闭session

session.close();
</code></pre><p><strong>Mybatis传递多个参数的方法</strong></p>
<p>DAO层函数</p>
<pre><code>Public User selectUser(@param(“userName”)String name,@param(“userArea”)String area);
</code></pre><p>对应Mapper</p>
<pre><code>&lt;select id=&quot; selectUser&quot; resultMap=&quot;BaseResultMap&quot;&gt;
   select  *  from user_user_t   where user_name = #{userName，jdbcType=VARCHAR} and user_area=#{userArea,jdbcType=VARCHAR}
&lt;/select&gt; 
</code></pre><p><strong>复杂查询，使用ResultMap，实现复杂查询结果到复杂对象关联关系的转化</strong></p>
<p><strong>Constructor</strong></p>
<p>类在实例化时，用来注入结果到构造方法中</p>
<p>idArg —— ID参数；标记结果作为ID可以帮助提高整体性能</p>
<p>arg —— 注入到构造方法的一个普通结果</p>
<p><strong>Collection</strong></p>
<p>实现一对多的关联</p>
<p>id —— 一个ID结果；标记结果作为ID可以帮助提高整体性能</p>
<p>result —— 注入到字段或JavaBean属性的普通结果</p>
<p><strong>Mapper的xml文件内容：</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.netease.mybatis.practice.UserOp&quot;&gt;
    &lt;select id=&quot;getUser&quot; parameterType=&quot;int&quot; resultMap=&quot;UserMap&quot;&gt;
    select u.user_id as user_id, userName, password, c.id as courseId, courseName from user u left
    join
    UserCourse uc on u.user_id = uc.user_id left
    join
    course c on c.id = uc.course_id    where u.user_id =#{user_id}
    &lt;/select&gt;

    &lt;resultMap id=&quot;UserMap&quot; type=&quot;com.netease.mybatis.practice.User&quot;&gt;
        &lt;constructor&gt;
            &lt;idArg column=&quot;user_id&quot; javaType=&quot;int&quot; /&gt;
            &lt;arg column=&quot;userName&quot; javaType=&quot;String&quot; /&gt;
            &lt;arg column=&quot;password&quot; javaType=&quot;String&quot; /&gt;
        &lt;/constructor&gt;
        &lt;collection property=&quot;courses&quot; ofType=&quot;com.netease.mybatis.practice.Course&quot;&gt;
            &lt;id property=&quot;courseId&quot; column=&quot;courseId&quot; /&gt;
            &lt;result property=&quot;courseName&quot; column=&quot;courseName&quot; /&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre><p>collection项若为Integer，String等类型，可设为</p>
<pre><code>&lt;collection property=&quot;list&quot; column=&quot;productname&quot; ofType=&quot;java.lang.String&quot;&gt;
   &lt;result column=&quot;productname&quot; /&gt;
&lt;/collection&gt;
</code></pre><p><strong>Association，实现复杂类型之间的关联</strong></p>
<p>id —— 一个ID结果；标记结果作为ID可以帮助提高整体性能</p>
<p>result —— 注入到字段或JavaBean属性的普通结果</p>
<p>xml文件内容中增加association项，修改为：</p>
<pre><code>&lt;collection property=&quot;courses&quot; ofType=&quot;com.netease.mybatis.practice.Course&quot;&gt;
            &lt;id property=&quot;courseId&quot; column=&quot;courseId&quot; /&gt;
            &lt;result property=&quot;courseName&quot; column=&quot;courseName&quot; /&gt;
            &lt;association property=&quot;teacher&quot; column=&quot;teacherId&quot; javaType=&quot;com.netease.mybatis.practice.Teacher&quot;&gt;
                &lt;id property=&quot;teacherId&quot; column=&quot;teacherId&quot; /&gt;
                &lt;result property=&quot;teacherName&quot; column=&quot;teacherName&quot; /&gt;
            &lt;/association&gt;
&lt;/collection&gt;
</code></pre><p><strong>Mybatis自带连接池</strong></p>
<p>连接池常用配置选项</p>
<p>poolMaximumActiveConnections:</p>
<p>数据库最大活跃连接数，不宜设置过大</p>
<p>poolMaximumIdleConnections:</p>
<p>最大空闲连接数，一般设置与poolMaximum相同即可</p>
<p>poolMaximumCheckoutTime:</p>
<p>获取连接时如果没有idleConnection同时activeConnection达到最大值，则从activeConnection列表第一个连接开始检查，如果超过此时间，则使其失效，返回该连接，建议设置为预期最大SQL执行时间</p>
<p>poolTimeToWait：</p>
<p>获取服务器连接的超时时间，如果超时，打印日志重新获取连接。默认为20s</p>
<p>poolPingEnabled：</p>
<p>启用连接侦测，检查连接池中的连接是否为有效连接，默认为关闭，建议开启</p>
<p>poolPingQuery：</p>
<p>侦测SQL，建议使用select 1，开销小</p>
<p>poolPingConnectionsNotUsedFor：</p>
<p>侦测时间，建议小于服务器端超时时间，MySQL默认超时8小时</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/学习笔记-Spring框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KioLuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://b-ssl.duitang.com/uploads/item/201602/18/20160218194039_c2Kmt.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KioLuo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/13/学习笔记-Spring框架/" itemprop="url">
                  学习笔记--Spring框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T19:05:13+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>//概述</strong></p>
<p>轻量级，一站式，开发框架</p>
<p>IoC，Inversion of Control，控制反转</p>
<p>DI，Dependency Injection，依赖注入</p>
<p>AOP，Aspect-Oriented Programming，面向切面编程：业务逻辑与非业务逻辑分离，如日志、安全…</p>
<p>IoC容器：</p>
<p>对象创建、装配</p>
<p>对象生命周期管理</p>
<p>上下文环境</p>
<p><strong>//IoC容器</strong></p>
<p>IoC = ApplicationContext  (org.springframework.context,  spring-context)</p>
<p>初始化</p>
<p>ApplicationContext context = new ClassPathXmlApplicationContext(“application-context.xml”);</p>
<p>或</p>
<p>ApplicationContext context = new FileSystemXmlApplicationContext(“/home/user/conf/application-context.xml”);</p>
<p>或在web.xml中</p>
<pre><code>&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:application-context.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre><p><strong>Bean定义</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;bean id=&quot;screwDriver&quot; class=&quot;com.netease.course.ScrewDriver&quot;&gt;&lt;/bean&gt;

&lt;/beans&gt;
</code></pre><p><strong>Bean使用</strong></p>
<p>//初始化容器</p>
<p>ApplicationContext context = new ClassPathXmlApplicationContext(“application-context.xml”);</p>
<p>//获取对象</p>
<p>ScrewDriver screwDriver = context.getBean(“screwDriver”, ScrewDriver.class);</p>
<p>//使用对象</p>
<p>screwDriver.use();</p>
<p><strong>Bean作用域</strong></p>
<p>singleton，单例</p>
<pre><code>&lt;bean id=&quot;screwDriver&quot; class=&quot;com.netease.course.ScrewDriver&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;
</code></pre><p>默认为单例<br>prototype，每次引用创建一个实例</p>
<pre><code>&lt;bean id=&quot;screwDriver&quot; class=&quot;com.netease.course.ScrewDriver&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
</code></pre><p>request scope, requestBean<br>session scope, sessionBean<br>application scope, appBean<br>global scope</p>
<p><strong>Bean生命周期回调</strong></p>
<p>创建，申请资源<br>可以通过实现接口</p>
<pre><code>public interface InitializingBean {
    void afterPropertiesSet() throws Exception;
}
</code></pre><p>或者直接在application-context.xml中配置</p>
<pre><code>&lt;bean id=&quot;screwDriver&quot; class=&quot;com.netease.course.ScrewDriver&quot; init-method=&quot;init&quot;&gt;&lt;/bean&gt;
</code></pre><p>对应代码</p>
<pre><code>public class ScrewDriver {
   public void init() {
        System.out.println(&quot;Init screwDriver&quot;);
   }
}
</code></pre><p>销毁<br>可以通过实现接口</p>
<pre><code>public interface DisposableBean {
    void destroy() throws Exception;
}
</code></pre><p>或者直接在application-context.xml中配置</p>
<pre><code>&lt;bean id=&quot;screwDriver&quot; class=&quot;com.netease.course.ScrewDriver&quot; destroy-method=&quot;cleanup&quot;&gt;&lt;/bean&gt;
</code></pre><p>对应代码</p>
<pre><code>public class ScrewDriver {
   public void cleanup() {
        System.out.println(&quot;Cleanup screwDriver&quot;);
   }
}
</code></pre><p>关闭Bean</p>
<pre><code>((ConfigurableApplicationContext) context).close();
</code></pre><p><strong>依赖注入</strong></p>
<p>构造函数，强依赖</p>
<p>Setter函数，可选依赖</p>
<p>配置bean的类的构造函数的参数</p>
<pre><code>&lt;bean id=&quot;straightHeader&quot; class=&quot;com.netease.course.StraightHeader&quot;&gt;
     &lt;constructor-arg value=&quot;red&quot;&gt;&lt;/constructor-arg&gt;
     &lt;constructor-arg value=&quot;15&quot;&gt;&lt;/constructor-arg&gt;
 &lt;/bean&gt;
</code></pre><p>或</p>
<pre><code>&lt;bean id=&quot;straightHeader&quot; class=&quot;com.netease.course.StraightHeader&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;red&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;15&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><p>或</p>
<pre><code>&lt;bean id=&quot;straightHeader&quot; class=&quot;com.netease.course.StraightHeader&quot;&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;red&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg type=&quot;int&quot; value=&quot;15&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><p>或</p>
<pre><code>&lt;bean id=&quot;straightHeader&quot; class=&quot;com.netease.course.StraightHeader&quot;&gt;
    &lt;constructor-arg name=&quot;color&quot; value=&quot;red&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;size&quot; value=&quot;15&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><p>需要传递集合类型的构造函数参数（如map）时</p>
<pre><code>&lt;bean id=&quot;straightHeader&quot; class=&quot;com.netease.course.StraightHeader&quot;&gt;
    &lt;constructor-arg&gt;
        &lt;map&gt;
            &lt;entry key=&quot;color&quot; value=&quot;red&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;size&quot; value=&quot;15&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;size&quot; value=&quot;15&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><p>传入list时</p>
<pre><code>&lt;bean id=&quot;straightHeader&quot; class=&quot;com.netease.course.StraightHeader&quot;&gt;
    &lt;constructor-arg&gt;
        &lt;list&gt;
            &lt;value&gt;red&lt;/value&gt;
            &lt;value&gt;15&lt;/value&gt;
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;size&quot; value=&quot;15&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><p>传入Properties时</p>
<pre><code>&lt;bean id=&quot;straightHeader&quot; class=&quot;com.netease.course.StraightHeader&quot;&gt;
    &lt;constructor-arg&gt;
        &lt;props&gt;
            &lt;prop key=&quot;color&quot;&gt;red&lt;/prop&gt;
            &lt;prop key=&quot;size&quot;&gt;15&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;size&quot; value=&quot;15&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><p>从外部倒入配置时</p>
<pre><code>  &lt;bean id=&quot;straightHeader&quot; class=&quot;com.netease.course.StraightHeader&quot;&gt;
      &lt;constructor-arg name=&quot;color&quot; value=&quot;${color}&quot;&gt;&lt;/constructor-arg&gt;
      &lt;constructor-arg name=&quot;size&quot; value=&quot;${size}&quot;&gt;&lt;/constructor-arg&gt;
  &lt;/bean&gt;
  &lt;bean id=&quot;headerProperties&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
    &lt;property name=&quot;location&quot; value=&quot;classpath:header.properties&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>在一个bean中添加所依赖的bean</p>
<pre><code>&lt;bean id=&quot;screwDriver&quot; class=&quot;com.netease.course.ScrewDriver&quot;&gt;
    &lt;constructor-arg&gt;
        &lt;ref bean=&quot;straightHeader&quot; /&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><p>通过Setter方法注入依赖</p>
<pre><code>&lt;bean id=&quot;straightHeader&quot; class=&quot;com.netease.course.StraightHeader&quot;&gt;
    &lt;property name=&quot;color&quot; value=&quot;${color}&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;size&quot; value=&quot;${size}&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p><strong>自动装配</strong></p>
<p>constructor是按byType方式注入</p>
<pre><code>&lt;bean id=&quot;screwDriver&quot; class=&quot;com.netease.course.ScrewDriver&quot; autowire=&quot;constructor&quot;&gt;
 &lt;/bean&gt;
</code></pre><p>或</p>
<pre><code>&lt;bean id=&quot;screwDriver&quot; class=&quot;com.netease.course.ScrewDriver&quot; autowire=&quot;byName&quot;&gt;
 &lt;/bean&gt;
</code></pre><p>或</p>
<pre><code>&lt;bean id=&quot;screwDriver&quot; class=&quot;com.netease.course.ScrewDriver&quot; autowire=&quot;byType&quot;&gt;
 &lt;/bean&gt;
</code></pre><p><strong>Annotation</strong></p>
<p>@Component：定义Bean，或@Component(“name”)</p>
<p>@Value：properties注入</p>
<p>@Autowired &amp; @Resource：自动装配依赖</p>
<p>@PostConstruct &amp; @PreDestroy：生命周期回调</p>
<p>在xml中加入</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.netease.course&quot; /&gt;
</code></pre><p><strong>//AOP技术</strong></p>
<p>AOP术语</p>
<p>Aspect：日志、安全等功能</p>
<p>Join point：函数执行或者属性访问</p>
<p>Advice：在某个函数执行点上要执行的切面功能</p>
<p>Pointcut：匹配横切目标函数的表达式</p>
<p>Advice类型</p>
<p>Before：函数执行之前</p>
<p>After returning：函数正常返回之后</p>
<p>After throwing：函数抛出异常之后</p>
<p>After finally：函数返回之后</p>
<p>Around：函数执行前后</p>
<p>Spring AOP</p>
<p>非完整AOP实现</p>
<p>整合AOP和与IoC</p>
<p>XML schema-based AOP</p>
<p>@AspectJ annotation-based AOP</p>
<p><strong>@AspecsJ annotation-based AOP</strong></p>
<p>aspectjweaver.jar</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop-2.0.xsd&quot;&gt;

    &lt;aop:aspectj-autoproxy /&gt;

&lt;/beans&gt;
</code></pre><p><strong>定义Aspect</strong></p>
<pre><code>&lt;bean id=&quot;loggingAspect&quot; class=&quot;com.netease.course.LoggingAspect&quot;&gt;
        &lt;!-- configure properties of aspect here as normal --&gt;
&lt;/bean&gt;
</code></pre><p>相应代码中类名前加入@Aspect</p>
<p><strong>定义Pointcut</strong></p>
<pre><code>@Pointcut(&quot;execution(* com.netease.course.Calculator.*(..))&quot;)

private void arithmetic() {}
</code></pre><p><strong>Pointcut表达式</strong></p>
<p>designator(modifiers? return-type declaring-type? name(param) throws?)</p>
<p>designator: execution, within</p>
<p>modifiers: public, private</p>
<p>return-type: 返回类型，*</p>
<p>declaring-type: 包名，类名</p>
<p>name: 函数名，*</p>
<p>param: 参数列表，()无参，(..)任意参数</p>
<p>throws: 异常类型</p>
<p>可以组合</p>
<p><strong>定义Advice</strong></p>
<pre><code>@Before(&quot;com.netease.course.LoggingAspect.arithmetic()&quot;)

public void doLog() {

  //

}
</code></pre><p>或</p>
<pre><code>@Before(&quot;execution(* com.netease.course.Calculator.*(..))&quot;)

public void doLog() {

    //

}
</code></pre><p>或</p>
<pre><code>@AfterReturning(&quot;com.netease.course.LoggingAspect.arithmetic()&quot;)

public void doLog() {

    //

}
</code></pre><p>或</p>
<pre><code>@AfterThrowing(&quot;com.netease.course.LoggingAspect.arithmetic()&quot;)

public void doLog() {

    //

}
</code></pre><p>或</p>
<pre><code>@After(&quot;com.netease.course.LoggingAspect.arithmetic()&quot;)

public void doLog() {

    //

}
</code></pre><p><strong>Advice参数</strong></p>
<p>函数上下文信息</p>
<pre><code>@Before(&quot;com.netease.course.LoggingAspect.arithmetic()&quot;)

public void doLog(JoinPoint jp) {

    System.out.println(jp.getSignature() + &quot;, &quot; + jp.getArgs());

}
</code></pre><p> 或   </p>
<pre><code>@Around(&quot;com.netease.course.LoggingAspect.arithmetic()&quot;)

public void doLog(ProceedingJoinPoint pjp) {

    System.out.println(&quot;start method: &quot; + pjp.toString());

    Object retVal = pjp.proceed();

    System.out.println(&quot;stop method: &quot; + pjp.toString());

}
</code></pre><p>返回值</p>
<pre><code>@AfterReturning(pointcut=&quot;com.netease.course.LoggingAspect.arithmetic()&quot;),

                returning=&quot;retVal&quot;)

public void doLog(Object retVal) {

    //

}
</code></pre><p>异常</p>
<pre><code>@AfterThrowing(pointcut=&quot;com.netease.course.LoggingAspect.arithmetic()&quot;),

               throwing=&quot;ex&quot;)

public void doLog(IllegalArgumentException ex) {

    //

}
</code></pre><p>目标函数参数</p>
<pre><code>@Before(&quot;com.netease.course.LoggingAspect.arithmetic() &amp;&amp; args(a, ..)&quot;)

public void doLog(JoinPoint jp, int a) {

    //

}
</code></pre><p><strong>XML schema-based AOP</strong></p>
<p>定义Aspect和PointCut</p>
<pre><code>&lt;aop:config&gt;
    &lt;aop:aspect id=&quot;loggingAspect&quot; ref=&quot;loggingBean&quot;&gt;
        &lt;aop:pointcut id=&quot;arithmetic&quot; expression=&quot;execution(* com.netease.course.Calculator.*(..))&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre><p>定义Advice</p>
<pre><code>&lt;aop:config&gt;
    &lt;aop:aspect id=&quot;loggingAspect&quot; ref=&quot;loggingBean&quot;&gt;
        &lt;aop:before pointcut-ref=&quot;arithmetic&quot; method=&quot;doLog&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre><p>或</p>
<pre><code>&lt;aop:config&gt;
    &lt;aop:aspect id=&quot;loggingAspect&quot; ref=&quot;loggingBean&quot;&gt;
        &lt;aop:before pointcut=&quot;execution(* com.netease.course.Calculator.*(..))&quot; method=&quot;doLog&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre><p>或</p>
<pre><code>&lt;aop:config&gt;
    &lt;aop:aspect id=&quot;loggingAspect&quot; ref=&quot;loggingBean&quot;&gt;
        &lt;aop:after-returning pointcut-ref=&quot;arithmetic&quot; returning=&quot;retVal&quot; method=&quot;doLog&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre><p>或</p>
<pre><code>&lt;aop:config&gt;
    &lt;aop:aspect id=&quot;loggingAspect&quot; ref=&quot;loggingBean&quot;&gt;
        &lt;aop:after-throwing pointcut-ref=&quot;arithmetic&quot; throwing=&quot;ex&quot; method=&quot;doLog&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre><p>或</p>
<pre><code>&lt;aop:aspect id=&quot;loggingAspect&quot; ref=&quot;loggingBean&quot;&gt;
    &lt;aop:around pointcut-ref=&quot;arithmetic&quot; method=&quot;doLog&quot; /&gt;
&lt;/aop:aspect&gt;
</code></pre><p><strong>//数据访问</strong></p>
<p>DAO，Data Access Object</p>
<p>数据访问相关接口</p>
<p>ORM，Object Relation Mapping</p>
<p>对象关系映射</p>
<p>DataSource (javax.sql)</p>
<p>DriverManagerDataSource (org.springframework.jdbc.datasource)</p>
<p>BasicDataSource (org.apache.commons.dbcp)</p>
<pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot; /&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location=&quot;db.properties&quot; /&gt;
</code></pre><p>JdbcTemplate (org.springframework.jdbc.core)<br>设置JdbcTemplate的数据库配置信息</p>
<pre><code>private JdbcTemplate jdbcTemplate;

@Autowired
public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
}
</code></pre><p>查询操作</p>
<pre><code>int rowCount = this.jdbcTemplate.queryForObject(&quot;select count(*) from user&quot;, Integer.class);
int countOfNamedJoe = this.jdbcTemplate.queryForObject(&quot;select count(*) from user where first_name = ?&quot;, Integer.class, &quot;Joe&quot;);
String lastName = this.jdbcTemplate.queryForObject(&quot;select last_name from user where id = ?&quot;, new Object[]{1212L}, String.class);
</code></pre><p>更改操作</p>
<pre><code>this.jdbcTemplate.update(&quot;insert into user (first_name, last_name) values (?, ?)&quot;, &quot;Meimei&quot;, &quot;Han&quot;);
或
this.jdbcTemplate.execute(&quot;create table user (id integer, first_name varchar(100), last_name varchar(100))&quot;);
</code></pre><p>对象匹配</p>
<pre><code>User user = this.jdbcTemplate.queryForObject(&quot;select last_name from user where id = ?&quot;,
        new Object[]{1212L},
        new RowMapper&lt;User&gt;() {
    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        User user = new User();
        user.setFirstName(rs.getString(&quot;first_name&quot;));
        user.setLastName(rs.getString(&quot;last_name&quot;));
        return user;
    }
});
</code></pre><p>或</p>
<pre><code>List&lt;User&gt; users = this.jdbcTemplate.query(&quot;select last_name from user where id = ?&quot;,
        new Object[]{1212L},
        new RowMapper&lt;User&gt;() {
    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        User user = new User();
        user.setFirstName(rs.getString(&quot;first_name&quot;));
        user.setLastName(rs.getString(&quot;last_name&quot;));
        return user;
    }
});
</code></pre><p>定义JdbcTemplate</p>
<pre><code>public class JdbcExampleDao implements ExampleDao {
    private JdbcTemplate jdbcTemplate;
    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
    //...DAO接口实现
}
</code></pre><p>可以在xml中配置相应的bean<br>也可以用annotation的方法，如下：</p>
<pre><code>@Repository
public class JdbcExampleDao implements ExampleDao {
    private JdbcTemplate jdbcTemplate;
    @Autowired
    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
    //...DAO接口实现
}
</code></pre><p>NamedParameterJdbcTemplate (org.springframework.jdbc.core)</p>
<pre><code>private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

@Autowired
public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate= new NamedParameterJdbcTemplate (dataSource);
}

public int countOfUserByFirstName(String firstName) {
    String sql = &quot;select count(*) from usertest where first_name = :first_name&quot;;
    Map&lt;String, String&gt; namedParameters = Collections.singletonMap(&quot;first_name&quot;, firstName);
    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}
</code></pre><p>其他api接口</p>
<pre><code>queryForObject(String sql, Map&lt;String, ?&gt; paramMap, RowMapper&lt;T&gt; rowMapper)
queryForObject(String sql, SqlParameterSource paramSource, Class&lt;T&gt; requiredType)

SqlParameterSource: MapSqlParameterSource, BeanPropertySqlParameterSource (org.springframework.jdbc.core.namedparam)
如：
public int countOfUserByFirstName(User user) {
    String sql = &quot;select count(*) from usertest where first_name = :first_name&quot;;
    SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(user);
    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}
</code></pre><p>异常处理</p>
<p>DataAccessException, “unchecked”, 是一个基类 （org.springframework.dao）</p>
<p><strong>//事务管理</strong></p>
<p>spring事务管理</p>
<p>统一的事务编程模型，编程式事务及声明式事务（AOP）</p>
<pre><code>public interface PlatformTransactionManager {

    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;

    void commit(TransactionStatus status) throws TransactionException;

    void rollback(TransactionStatus status) throws TransactionException;

}
</code></pre><p>事务管理器</p>
<p>PlatformTransactionManager (org.springframework.transaction)：</p>
<p>DataSourceTransactionManager (org.springframework.jdbc.datasource), JDBC</p>
<p>HibernateTransactionManager (org.springframework.orm.hibernate), Hibernate</p>
<p>TransactionDefinition</p>
<p>getName：事务名称</p>
<p>getIsolationLevel：隔离级别</p>
<p>getPropagationBehavior：传播行为</p>
<p>getTimeout：超时时间</p>
<p>isReadOnly：是否只读</p>
<p>TransactionStatus</p>
<p>isNewTransaction：是否是新事务</p>
<p>hasSavePoint：是否有savepoint（诊断，NESTED）</p>
<p>isCompleted：是否完成</p>
<p>isRollbackOnly：事务结果是否是rollback-only<br>setRollbackOnly：设置事务为rollback-only</p>
<p>隔离级别</p>
<p>ISOLATION_READ_UNCOMMITTED：读未提交</p>
<p>ISOLATION_READ_COMMITTED：读提交</p>
<p>ISOLATION_REPEATABLE_READ：重复读</p>
<p>ISOLATION_SERIALIZABLE：串行化</p>
<p>ISOLATION_DEFAULT：默认</p>
<p>传播行为</p>
<p>PROPAGATION_MANDATORY：必须在一个事务中运行，不存在则抛异常</p>
<p>PROPAGATION_NEVER：不应该在事务中运行，存在则抛异常</p>
<p>PROPAGATION_NOT_SUPPORTED：不应该在事务中运行，存在则挂起</p>
<p>PROPAGATION_SUPPORTS：不需要事务，有则在事务中执行</p>
<p>PROPAGATION_REQUIRED：必须在事务中执行，如果不存在，则启动新事务（内部事务会影响外部事务）</p>
<p>PROPAGATION_NESTED：必须在事务中执行，如果不存在，则启动新事务（事务之间互不影响）</p>
<p>PROPAGATION_REQUIRES_NEW：必须在新事务中执行，挂起当前事务（独立physical事务）</p>
<p><strong>声明式事务</strong></p>
<p>添加schema</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop-2.0.xsd&quot;&gt;
</code></pre><p>定义事务管理器</p>
<pre><code>&lt;bean id=&quot;txManager&quot;
    class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
    destroy-method=&quot;close&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot; /&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
&lt;/bean&gt;
&lt;context:property-placeholder location=&quot;db.properties&quot; /&gt;
</code></pre><p>定义事务Advice</p>
<pre><code>&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; /&gt;
        &lt;tx:method name=&quot;*&quot; /&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre><p>定义Pointcut</p>
<pre><code>&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;daoOperation&quot;
        expression=&quot;execution(* com.netease.course.AccountDao.*(..))&quot; /&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;daoOperation&quot; /&gt;
&lt;/aop:config&gt;
</code></pre><p>配置<tx:method></tx:method></p>
<p>name: 匹配的函数名称，支持*匹配<br>propagation：事务传播行为<br>isolation：事务隔离级别<br>timeout：超时<br>read-only：是否只读事务<br>rollback-for：触发回滚的异常，用逗号分隔<br>no-rollback-for：不触发回滚的异常</p>
<p>采用annotation方法<br>@Transactional<br>xml中添加</p>
<pre><code>&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt;
</code></pre><p>相应代码</p>
<pre><code>@Transactional(propagation=Propagation.REQUIRED, rollbackFor=Exception.class)
public boolean deleteClusterByClusterId(Sring clusterId) {
    // do work
}
</code></pre><p>@transactional<br>value：使用的TransactionManager<br>propagation：事务传播行为<br>isolation：事务隔离级别<br>timeout：超时<br>readOnly：是否只读<br>rollbackFor：触发回滚的异常类对象数组<br>rollbackForClassName：触发回滚的异常类名称数组<br>noRollbackFor：不触发回滚的异常类对象数组<br>noRollbackForClassName：不触发回滚的异常类名称数组</p>
<p><strong>编程式事务</strong></p>
<p>定义TransactionTemplate</p>
<pre><code>public class SimpleService implements Service {
    private final TransactionTemplate transactionTemplate;
    public SimpleService(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
        this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
        this.transactionTemplate.setTimeout(30);
    }
}
</code></pre><p>使用TransactionTemplate</p>
<pre><code>public Object someMethod() {
    return transactionTemplate.execute(new TransactionCallback() {
        public Object doInTransaction(TransactionStatus status) {
            updateOperation1();
            return resultOfUpdateOperation2();
        }
    });
}
</code></pre><p>或（不返回结果）</p>
<pre><code>public Object someMethodWithoutResult() {
    return transactionTemplate.execute(new TransactionCallbackWithoutResult() {
        protected void doInTransactionWithoutResult(TransactionStatus status) {
            updateOperation1();
            updateOperation2();
        }
    });
}
</code></pre><p>或（设置为遇到异常时只能回滚）</p>
<pre><code>public Object someMethodWithoutResult() {
    return transactionTemplate
            .execute(new TransactionCallbackWithoutResult() {
                protected void doInTransactionWithoutResult(
                        TransactionStatus status) {
                    try {
                        updateOperation1();
                        updateOperation2();
                    } catch (SomeBusinessException e) {
                        status.setRollbackOnly();
                    }
                }
            });
}
</code></pre><p>PlatformTransactionManager的实现</p>
<pre><code>DefaultTransactionDefinition def = new DefaultTransactionDefinition();
def.setName(&quot;TxName&quot;);
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
try {
    //do something
} catch (MyException ex) {
    txManager.rollback(status);
    throw ex;
}
txManager.commit(status);
</code></pre><p><strong>整合MyBatis</strong></p>
<p>SqlSessionFactory<br>添加mybatis-spring依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>定义SqlSessionFactoryBean</p>
<pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:sqlMapConfig.xml&quot; /&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:sample/config/mappers/**/*.xml&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>定义Mapper</p>
<pre><code>public interface UserMapper {

    @Select(&quot;SELECT * FROM users WHERE id = #{userId}&quot;)
    User getUser(@Param(&quot;userId&quot;) String userId);
}
</code></pre><p>配置结果映射</p>
<pre><code>@Results({
    @Result(property=&quot;id&quot;, column=&quot;id&quot;),
    @Result(property=&quot;firstName&quot;, column=&quot;first_name&quot;),
    @Result(property=&quot;lastName&quot;, column=&quot;last_name&quot;)
})
</code></pre><p>或者采用xml的方法，见Mybatis部分</p>
<p>定义Mapper Bean</p>
<pre><code>&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;
    &lt;property name=&quot;mapperInterface&quot; value=&quot;com.netease.course.UserMapper&quot; /&gt;
    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>或采用自动发现的机制</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://mybatis.org/schema/mybatis-spring
    http://mybatis.org/schema/mybatis-spring.xsd&quot;&gt;

    &lt;mybatis:scan base-package=&quot;com.netease.course&quot; /&gt;
&lt;/beans&gt;
</code></pre><p>当需要指定SqlSessionFactory时</p>
<pre><code>&lt;mybatis:scan base-package=&quot;com.netease.course&quot; factory-ref=&quot;sqlSessionFactory&quot; /&gt;
</code></pre><p>或者</p>
<pre><code>&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.netease.course&quot; /&gt;
    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>使用Mapper</p>
<pre><code>public class SomeService {
    @Autowired
    private UserMapper userMapper;
    public User getUser(String userId) {
        return userMapper.getUser(userId);
    }
}
</code></pre><p>定义SqlSessionTemplate使用</p>
<pre><code>&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>SqlSessionTemplate使用</p>
<pre><code>public class UserDao {
    @Autowired
    private SqlSession sqlSession;
    public User getUser(String userId) {
        return (User) sqlSession.selectOne(&quot;com.netease.course.UserMapper.getUser&quot;, userId);
    }
}
</code></pre><p><strong>//Web框架</strong></p>
<p>DispatcherServlet</p>
<p>[servlet-name]-servlet.xml<br>HandlerMapping<br>Controllers<br>View解析相关</p>
<p>WebApplicationContext</p>
<p>ContextLoaderListener</p>
<pre><code>&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/applicationContext*.xml&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre><p>Servlet WebApplicationContext (containing controllers, view resolvers, and other web-related beans)<br>Root WebAppliacationContext (containing middler-tier services, datasources, etc.)</p>
<p><strong>实现Controller</strong></p>
<pre><code>@Controller
@RequestMapping(value = &quot;/hello&quot;)
public class HelloController {
    @RequestMapping(value = &quot;/spring&quot;)
    public void spring(HttpServletResponse response) throws IOException {
        response.getWriter().write(&quot;Hello, Spring Web!!&quot;);
    }
}
</code></pre><p><strong>定义Controller</strong></p>
<p>自动发现</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.netease.course&quot; /&gt;
</code></pre><p>@RequestMapping<br>name: 名称<br>value &amp; path: 路径，如”/hello”<br>method: 请求方法，如”GET”<br>params: 请求参数<br>headers: 请求头<br>consumes: 请求的媒体类型，”Content-Type”<br>produces: 响应的媒体类型，”ACCEPT”</p>
<p>注入路径中的变量</p>
<pre><code>@RequestMapping(value=&quot;/users/{userId}&quot;)
public String webMethod(@PathVariable String userId) {
    //do work
}
</code></pre><p>或</p>
<pre><code>@RequestMapping(value=&quot;/users/{userId:[a-z]+}&quot;)
public String webMethod(@PathVariable String userId) {
    //do work
}
</code></pre><p>函数参数<br>HttpServletRequest / HttpServletResponse, HttpSession (Servlet API)<br>Reader / Writer<br>@PathVariable<br>@RequestParam<br>@RequestHeader<br>HttpEntity<br>@RequestBody<br>Map / Model / ModelMap</p>
<p>函数返回值<br>void<br>String: view名称，@ResponseBody<br>HttpEntity<br>View<br>Map<br>Model<br>ModelAndView</p>
<p><strong>函数实现</strong></p>
<pre><code>@RequestMapping(value=&quot;/spring/{user}&quot;)

public void helloSpring(

        @PathVariable(&quot;user&quot;) String user,

        @RequestParam(&quot;msg&quot;) String msg,

        @RequestHeader(&quot;host&quot;) String host,

        HttpServletRequest request,

        Writer writer) throws IOException {

    writer.write(&quot;URI: &quot; + request.getRequestURI());

    writer.write(&quot;Hello, &quot; + user + &quot;: &quot; + msg + &quot;, host=&quot; + host);

}
</code></pre><p>或</p>
<pre><code>@RequestMapping(value=&quot;/spring/login&quot;)

public void login(@ModelAttribute User user, Writer writer) {

    //do work

}
</code></pre><p>或</p>
<pre><code>@RequestMapping(value=&quot;/users/login&quot;)

public String login(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;password&quot;) String password, ModelMap map) {

    map.addAttribute(&quot;name&quot;, name);

    map.addAttribute(&quot;password&quot;, &quot;******&quot;);

    return &quot;user&quot;;

}
</code></pre><p><strong>ModelMap</strong><br>ModelMap的实例是由bboss mvc框架自动创建并作为控制器方法参数传入，用户无需自己创建。</p>
<pre><code>public String xxxxmethod(String someparam,ModelMap model)   
{   
     //省略方法处理逻辑若干   
      //将数据放置到ModelMap对象model中,第二个参数可以是任何java类型   
      model.addAttribute(&quot;key&quot;,someparam);   
     ......   
     //返回跳转地址   
      return &quot;path:handleok&quot;;   
}  
</code></pre><p><strong>ModelAndView</strong><br>ModelAndView的实例是由用户手动创建的，这也是和ModelMap的一个区别。</p>
<pre><code>public ModelAndView xxxxmethod(String someparam)   
{   
     //省略方法处理逻辑若干   
      //构建ModelAndView实例，并设置跳转地址   
      ModelAndView view = new ModelAndView(&quot;path:handleok&quot;);   
      //将数据放置到ModelAndView对象view中,第二个参数可以是任何java类型   
      view.addObject(&quot;key&quot;,someparam);   
     ......   
     //返回ModelAndView对象view   
      return view;   
}  
</code></pre><p>上传文件</p>
<p>定义bean</p>
<pre><code>&lt;bean id=&quot;multipartResolver&quot;
    class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;100000&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>相应代码</p>
<pre><code>@RequestMapping(value=&quot;/form&quot;, method=RequestMethod.POST)
public String handleFormUpload(@RequestParam(&quot;file&quot;) MultipartFile file) {
    // save the file
}
</code></pre><p>相应依赖</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
  &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
  &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>HttpEntity</p>
<pre><code>@RequestMapping(value=&quot;/something&quot;)
public ResponseEntity&lt;String&gt; handle(HttpEntity&lt;byte[]&gt; requestEntity) {
    String requestHeader = requestEntity.getHeaders().getFirst(&quot;MyRequestHeader&quot;);
    byte[] requestBody = requestEntity.getBody();
    // do something with requestHeader and requestBody
    HttpHeaders responseHeaders = new HttpHeaders();
    responseHeaders.set(&quot;MyResponseHeader&quot;, &quot;MyValue&quot;);
    return new ResponseEntity&lt;String&gt;(&quot;hello spring&quot;, responseHeaders, HttpStatus.CREATED);
}
</code></pre><p>@RequestBody &amp; @ResponseBody</p>
<pre><code>@RequestMapping(value=&quot;/spring&quot;)
@ResponseBody
public String spring(@RequestBody String body) throws IOException {
    return &quot;hello&quot; + body;
}
</code></pre><p>MessageConverter，返回Java对象的转化<br>RequestBody —&gt; Object: 参数<br>ResponseBody &lt;— Object: 返回值</p>
<p>xml文件配置</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:mvc=“http://www.springframework.org/schema/mvc”
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.netease.course&quot; /&gt;
    &lt;mvc:annotation-driven /&gt;
&lt;/beans&gt;
</code></pre><p>添加相应依赖，如JSON相关依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
    &lt;version&gt;2.6.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.6.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p><strong>View解析</strong></p>
<p>String      名称</p>
<p>View</p>
<p>ModelAndView</p>
<p>Map</p>
<p>Model</p>
<p><strong>ViewResolver (org.springframework.web.servlet)：</strong></p>
<p>InternalResourceViewResolver (org.springframework.web.servlet.view)<br>FreeMarkerViewResolver (org.springframework.web.servlet.view.freemarker)<br>ContentNegotiatingViewResolver (org.springframework.web.servlet.view)</p>
<p>InternalResourceViewResovler<br>Servlet, JSP<br>bean定义</p>
<pre><code>&lt;bean id=&quot;viewResolver&quot;
    class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>resultView ——-&gt; /WEB-INF/jsp/resultView.jsp</p>
<p>FreeMarkerViewResolver<br>FreeMarker<br>bean定义</p>
<pre><code>&lt;bean id=&quot;freemarkerConfig&quot;
    class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
    &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/freemarker/&quot; /&gt;
&lt;/bean&gt;
&lt;bean id=&quot;viewResolver&quot;
    class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
    &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt;
    &lt;property name=&quot;contentType&quot; value=&quot;text/html; charset=utf-8&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>ContentNegotiatingViewResolver<br>ViewResovler的组合<br>扩展名：user.json, user.xml, user.pdf<br>Accept头（media types)：application / json, application / xml<br>bean定义</p>
<pre><code>&lt;bean
    class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;
    &lt;property name=&quot;viewResolvers&quot;&gt;
        &lt;list&gt;
            &lt;bean id=&quot;viewResolver&quot;
                class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
                &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt;
                &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt;
                &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;defaultViews&quot;&gt;
        &lt;list&gt;
            &lt;bean
                class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>DefaultRequestToViewNameTranslator<br>example/admin/index.html ———&gt; admin/index<br>example/display.html ——-&gt; display</p>
<p><strong>ContentNegotiatingViewResolver 根据路径后缀，选择不同视图</strong></p>
<p>方法一：使用扩展名</p>
<p><a href="http://localhost:8080/learn/user.xml" target="_blank" rel="external">http://localhost:8080/learn/user.xml</a> 获取xml类型数据</p>
<p><a href="http://localhost:8080/learn/user.json" target="_blank" rel="external">http://localhost:8080/learn/user.json</a>  获取json类型数据</p>
<p><a href="http://localhost:8080/learn/user" target="_blank" rel="external">http://localhost:8080/learn/user</a>  使用默认view呈现，如jsp</p>
<p>方法二：使用http 请求头的Accept</p>
<p>GET /user HTTP/1.1</p>
<p>Accept:application/xml</p>
<p>GET /user HTTP/1.1</p>
<p>Accept:application/json</p>
<p>方法三：使用参数</p>
<p><a href="http://localhost:8080/learn/user?format=xml" target="_blank" rel="external">http://localhost:8080/learn/user?format=xml</a></p>
<p><a href="http://localhost:8080/learn/user?format=json" target="_blank" rel="external">http://localhost:8080/learn/user?format=json</a></p>
<p>  同一资源，多种表述 </p>
<pre><code>&lt;bean id=&quot;contentNegotiationManager&quot; class=&quot;org.springframework.web.accept.ContentNegotiationManagerFactoryBean&quot;&gt;  
    &lt;!-- 是否启用扩展名支持，默认为true --&gt;  
    &lt;property name=&quot;favorPathExtenion&quot; value=&quot;true&quot; /&gt;  
    &lt;!-- 是否启用参数支持，默认为true --&gt;  
    &lt;property name=&quot;favorParameter&quot; value=&quot;false&quot; /&gt;  
    &lt;!-- 是否忽略掉accept header,默认为false --&gt;  
    &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot; /&gt;  

    &lt;!-- 扩展名到mimeType的映射 --&gt;  
    &lt;property name=&quot;mediaTypes&quot;&gt;  
        &lt;map&gt;  
            &lt;!-- 例如：/user.json 中的 .json 会映射到 application/json --&gt;  
            &lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt;  
            &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt;          
        &lt;/map&gt;  
    &lt;/property&gt;  

    &lt;!-- 如果所有mediaType都没匹配上，就使用defaultContentType --&gt;  
    &lt;property name=&quot;defaultContentType&quot; value=&quot;text/html&quot;/&gt;  
&lt;/bean&gt;  

&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;  
    &lt;!-- 解析器的执行顺序 --&gt;  
    &lt;property name=&quot;order&quot; value=&quot;1&quot; /&gt;  
    &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;contentNegotiationManager&quot; /&gt;  

    &lt;property name=&quot;defaultViews&quot;&gt;  
        &lt;list&gt;  
            &lt;bean class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;&gt;&lt;/bean&gt;  
            &lt;bean class=&quot;org.springframework.web.servlet.view.xml.MarshallingView&quot;&gt;  
                &lt;constructor-arg&gt;  
                    &lt;bean class=&quot;org.springframework.oxm.jaxb.Jaxb2Marshaller&quot;&gt;  
                        &lt;property name=&quot;classesToBeBound&quot;&gt;  
                            &lt;list&gt;  
                                &lt;value&gt;com.learn.model.User&lt;/value&gt;  
                            &lt;/list&gt;  
                        &lt;/property&gt;  
                    &lt;/bean&gt;  
                &lt;/constructor-arg&gt;  
            &lt;/bean&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  

&lt;/bean&gt;  
&lt;!-- 上面没匹配到则会使用这个视图解析器 ,解析为jsp  --&gt;  
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;  
    &lt;property name=&quot;order&quot; value=&quot;2&quot; /&gt;  
    &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;   
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;  
&lt;/bean&gt;  
</code></pre><p>Controller中可以用RequestMapping匹配多个路径后缀</p>
<pre><code>@RequestMapping(value = {&quot;/users&quot;, &quot;/users.html&quot;, &quot;/users.json&quot;})

public String getUsersInfo(ModelMap map) {

    List users = userServiceImp.getUsers();

    map.addAttribute(&quot;users&quot;, users);

    return &quot;users&quot;;

}
</code></pre><p><strong>FreeMarker</strong></p>
<p>模板引擎</p>
<p>数据模型</p>
<p>对象：hashes</p>
<p>基本类型：scalars</p>
<p>注释</p>
<p>&lt;#– 这是注释 –&gt;</p>
<p>插值：表达式</p>
<p>${animal.name}</p>
<p>直接指定值：</p>
<pre><code>字符串，如“Zoo”, &apos;Zoo&apos;

数字，如123.45

布尔值，如true，false

序列，如[&quot;zoo&quot;, &quot;bar&quot;, 123]

值域，如0..9，0..&lt;10

哈希表，如{&quot;name&quot;:&quot;green mouse&quot;, &quot;price&quot;:150}
</code></pre><p>检索变量：</p>
<pre><code>顶层变量：user

哈希表数据：user.name, user[&quot;name&quot;]

列表数据：products[5]
</code></pre><p>连接操作：</p>
<pre><code>users + &quot;guest&quot;

passwords + &quot;joe&quot;:&quot;secret123&quot;
</code></pre><p>算术操作</p>
<p>逻辑操作</p>
<p>比较操作</p>
<p>FTL标签：指令</p>
<p>开始标签：&lt;#directivename parameters&gt;</p>
<p>结束标签：</p>
<p>if指令</p>
<pre><code>&lt;#if user==&quot;Big Joe&quot;&gt;, our beloved leader
</code></pre><p>list指令</p>
<pre><code>&lt;#list animals as animal&gt;

  ${animal.name}${animal.price} Euros
</code></pre><p>include指令</p>
<pre><code>&lt;#include &quot;/copyright_footer.html&quot;&gt;
</code></pre><p>使用</p>
<p>创建配置</p>
<pre><code>Configuration cfg = new Configuration(Configuration.VERSION_2_3_0);

cfg.setDirectoryForTemplateLoading(new File(&quot;/where/you/store/templates&quot;));

cfg.setDefaultEncoding(&quot;UTF-8&quot;);

cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
</code></pre><p>定义模板</p>
<p>定义数据模型</p>
<p>如</p>
<pre><code>Map root = new HashMap&lt;&gt;();

root.put(&quot;user&quot;, &quot;Big Joe&quot;);

Map latestProduct = new HashMap&lt;&gt;();

root.put(&quot;latestProduct&quot;, latestProduct);

latestProduct.put(&quot;url&quot;, &quot;products/greenmouse.html&quot;);

latestProduct.put(&quot;name&quot;, &quot;greenmouse&quot;);
</code></pre><p>添加依赖</p>
<pre><code>&lt;dependency&gt;

    &lt;groupId&gt;org.freemarkergroupId&gt;

    &lt;artifactId&gt;freemarkerartifactId&gt;

    &lt;version&gt;2.3.23version&gt;

dependency&gt;
</code></pre><p>输出结果</p>
<pre><code>Template ftl = cfg.getTemplate(&quot;user.ftl&quot;);

Writer outWriter = new OutputStreamWriter(System.out);

ftl.process(root, outWriter);
</code></pre><p><strong>工程模板</strong></p>
<p>一般java目录</p>
<p>com.netease.course.dao</p>
<p>com.netease.course.meta</p>
<p>com.netease.course.service</p>
<p>com.netease.course.service.impl</p>
<p>com.netease.course.utils</p>
<p>com.netease.course.web.controller</p>
<p>com.netease.course.web.filter</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/学习笔记-Servlet技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KioLuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://b-ssl.duitang.com/uploads/item/201602/18/20160218194039_c2Kmt.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KioLuo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/13/学习笔记-Servlet技术/" itemprop="url">
                  学习笔记--Servlet技术
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T19:05:03+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p><strong>//Servlet概述</strong></p>
<p>一个servlet就是一个java类，并提供基于请求-响应模式的web服务。</p>
<p><strong>//创建Servlet</strong></p>
<p>新建继承HttpServlet的类，覆盖init(), destroy(), service(HttpServletRequest req, HttpServletResponse res), doGet(HttpServletRequest req, HttpServletResponse res)方法</p>
<p><strong>//配置Servlet</strong></p>
<p>在web.xml中servlet项加入项，如：</p>
<p>  data1</p>
<p>  value1</p>
<p>  data2</p>
<p>  value2</p>
<p>TestServlet</p>
<p>com.netease.server.example.web.controller.TestServlet</p>
<p>代码中相应方法：</p>
<pre><code>ServletConfig config = this.getServletConfig();

String v1 = config.getInitParameter(&quot;data1&quot;);  
</code></pre><p>全局配置：</p>
<p>在servlet项外加入项，如：</p>
<p>  globalData1</p>
<p>  123</p>
<p>代码中相应方法：</p>
<pre><code>ServletContext context = this.getServletContext();

String globalV1 = context.getInitParameter(&quot;globalData1&quot;);  
</code></pre><p>ServletMapping匹配规则：</p>
<p>支持模糊匹配</p>
<p>精确路径匹配（完全匹配）—&gt; 最长路径匹配（最长前缀匹配）—&gt;  扩展名匹配 —&gt; default servlet或放弃</p>
<p>更改servlet默认启动时间：</p>
<p>在元素中增加元素，负数为第一次请求时启动该servlet，大于等于0则在servlet容器启动时启动servlet，数字越小，优先级越高，如：</p>
<p>0</p>
<p>配置错误页面：</p>
<pre><code>404

/404.html
</code></pre><p>配置欢迎页面：</p>
<p>元素，可包含多个元素，顺序加载</p>
<p>MIME类型映射</p>
<p>定义扩展文件名映射类型，包含两个子元素：和</p>
<p><strong>//Servelt共享动态属性</strong></p>
<p>一个servlet代码中：</p>
<pre><code>ServletContext context = this.getServletContext();  

context.setAttribute(&quot;attribute1&quot;, &quot;123&quot;);  
</code></pre><p>另一个servlet代码中：</p>
<pre><code>String globalV1 = (String)context.getAttribute(&quot;attribute1&quot;);  
</code></pre><p><strong>//Servlet读取外部资源配置文件信息</strong></p>
<p>三种方法：</p>
<p>1. getResource</p>
<p>代码如：</p>
<pre><code>ServletContext context = this.getServletContext();  

URL url = context.getResource(&quot;/WEB-INF/log4j.properties&quot;);

InputStream in = url.openStream();

String propertyValue = GeneralUtil.getPropery(&quot;log4j.rootCategory&quot;, in);  
</code></pre><p>2. getResourceAsStream</p>
<p>代码如：</p>
<pre><code>InputStream in2 = context.getResourceAsStream(&quot;/WEB-INF/log4j.properties&quot;);

String p2 = GeneralUtil.getPropery(&quot;log4j.rootCategory&quot;, in2); 
</code></pre><p>3. getRealPath</p>
<p>代码如：</p>
<pre><code>String path = context.getRealPath(&quot;/WEB-INF/log4j.properties&quot;);

File file = new File(path);

InputStream in3 = new FileInputStream(file);

String p3 = GeneralUtil.getPropery(&quot;log4j.rootCategory&quot;, in3);  
</code></pre><p><strong>//HttpServletRequest实现类方法：</strong></p>
<p>1. 获得客户机信息</p>
<p>getRequestURL方法返回客户端发出请求时的完整URL。</p>
<p>getRequestURI方法返回请求行中的资源名部分。</p>
<p>getQueryString 方法返回请求行中的参数部分。</p>
<p>getRemoteAddr方法返回发出请求的客户机的IP地址</p>
<p>getRemoteHost方法返回发出请求的客户机的完整主机名</p>
<p>getRemotePort方法返回客户机所使用的网络端口号</p>
<p>getLocalAddr方法返回WEB服务器的IP地址。</p>
<p>getLocalName方法返回WEB服务器的主机名</p>
<p>getMethod得到客户机请求方式</p>
<p>getServerPath()获取请求的文件的路径</p>
<p>2. 获得客户机请求头</p>
<p>getHeader(string name)方法</p>
<p>getHeaders(String name)方法</p>
<p>getHeaderNames方法</p>
<p>3. 获得客户机请求参数(客户端提交的数据)</p>
<p>getParameter(name)方法 获取请求中的参数，该参数是由name指定的</p>
<p>getParameterValues（String name）方法 获取指定名称参数的所有值数组。它适用于一个参数名对应多个值的情况。如页面表单中的复选框，多选列表提交的值。</p>
<p>getParameterNames方法 返回一个包含请求消息中的所有参数名的Enumeration对象。通过遍历这个Enumeration对象，就可以获取请求消息中所有的参数名。</p>
<p>getCharacterEncoding() 返回请求的字符编码方式</p>
<p>getAttributeNames()返回当前请求的所有属性的名字集合赋值:setAttribute()</p>
<p>getAttribute(String name) 返回name指定的属性值</p>
<p>getsession()返回和客户端相关的session，如果没有给客户端分配session，则返回null</p>
<p>getParameterMap():返回一个保存了请求消息中的所有参数名和值的Map对象。Map对象的key是字符串类型的参数名，value是这个参数所对应的Object类型的值数组</p>
<p>addHeader(String name,String value)  将指定的名字和值加入到响应的头信息中</p>
<p><strong>//HttpServletResponse实现类方法：</strong></p>
<p>encodeURL(String url)  编码指定的URL</p>
<p>sendError(int sc)  使用指定状态码发送一个错误到客户端</p>
<p>setDateHeader(String name,long date)  将给出的名字和日期设置响应的头部</p>
<p>setHeader(String name,String value)  将给出的名字和值设置响应的头部</p>
<p>setStatus(int sc)  给当前响应设置状态码</p>
<p>setContentType(String ContentType)  设置响应的MIME类型 ,页面的设置文本类型,获取或设置输出流的 HTTP MIME 类型。输出流的 HTTP MIME 类型。默认值为“text/html”</p>
<p>getOutputStream()  字节输出流对象</p>
<p>getWriter()   字符的输出流对象</p>
<p><strong>//Cookie和Session</strong></p>
<p>关于Cookie</p>
<p>cookie数量限制：20个，每个大小限制：4kb</p>
<pre><code>Cookie userNameCookie = new Cookie(&quot;userName&quot;, userName);  //创建cookie

userNameCookie.setMaxAge(10 * 60);        //设置cookie有效时间

response.addCookie(userNameCookie);        //在响应中加入cookie

Cookie[] cookies = request.getCookies();        //从请求中获取cookie

cookie.getValue();          //从cookie中获取值

cookie.getName();          //从cookie中获取名字
</code></pre><p>关于Session</p>
<p>默认有效期30分钟，setMaxInactiveInterval设置有效期，invalidate使session失效</p>
<pre><code>HttpSession session = request.getSession();

String name = (String) session.getAttribute(&quot;userName&quot;); 

session.setMaxInactiveInterval(2 * 60);

session.setAttribute(&quot;userName&quot;, userName);

session.invalidate();
</code></pre><p>在部署描述符web.xml中配置有效期：</p>
<p>5</p>
<p><strong>//请求转发与重定向</strong></p>
<p>请求转发：</p>
<p>获取RequestDispatcher：</p>
<p>方法1：</p>
<p>RequestDispatcher rd = req.getRequestDispatcher(“/forwardExample”);        //可以是绝对路径或者相对路径</p>
<p>方法2：</p>
<p>RequestDispatcher rd = this.getServletContext().getNameDispatcher(“ServletForwardExample”); //转发到的servlet名称</p>
<p>或者</p>
<p>RequestDispatcher rd = this.getServletContext().getRequestDispatcher(“/forwardExample”);       //只能是绝对路径</p>
<p>转发：</p>
<p>rd.forward(req, resp);</p>
<p>请求重定向：</p>
<p>resp.sendRedirect(“redirectExample”);          //相对路径则访问本web，绝对路径可以访问其他web</p>
<p><strong>//过滤器与监听器</strong></p>
<p>启动顺序：ServletContext—&gt;listener—&gt;filter—&gt;servlet</p>
<p>过滤器：</p>
<p>创建实现Filter接口的类作为过滤器，在web.xml中增加项和，可定义多个，可配置FilterConfig，如下：</p>
<p>filterParam</p>
<p>111</p>
<p>TestFilter</p>
<p>com.netease.server.example.web.controller.filter.TestFilter</p>
<p>TestFilter</p>
<p>/hello/world/*</p>
<p>代码中：</p>
<pre><code>String value = filterConfig.getInitParameter(&quot;filterParam&quot;);
</code></pre><p>在doFilter方法中可对request进行处理，如：</p>
<pre><code>@Override

public void doFilter(ServletRequest request, ServletResponse response,

        FilterChain chain) throws IOException, ServletException {

    System.out.println(&quot;filter doFilter method&quot;);

    HttpServletRequest req = (HttpServletRequest) request;

    HttpSession session = req.getSession();

    if (session.getAttribute(&quot;username&quot;) == null) {

        HttpServletResponse res = (HttpServletResponse) response;

        res.sendRedirect(&quot;../index.html&quot;);

    } else {

        chain.doFilter(request, response);

    }

}
</code></pre><p>监听器：</p>
<p>分类</p>
<p>1. 监听应用程序环境 ServletContext</p>
<p>ServletContextListener</p>
<p>ServletContextAttributeListener</p>
<p>2. 监听用户请求对象 ServletRequest</p>
<p>ServletRequestListener</p>
<p>ServletRequestAttributeListener</p>
<p>3. 监听用户会话对象 HttpSession</p>
<p>HttpSessionListener</p>
<p>HttpSessionAttributeListener</p>
<p>HttpSessionActivationListener</p>
<p>HttpSessionBindingListener</p>
<p>创建实现相关接口的类，如实现HttpSessionAttributeListener，ServletContextListener, ServletRequestListener接口的类</p>
<p>在web.xml中增加项：</p>
<p>  com.netease.server.example.web.controller.listener.TestListener</p>
<p><strong>//Servlet并发处理</strong></p>
<p>特征：单实例，多线程，线程不安全</p>
<p>变量的线程安全：</p>
<p>–参数变量本地化</p>
<p>–使用同步块synchronized</p>
<p>属性的线程安全：</p>
<p>–SerletContext线程不安全</p>
<p>–HttpSession理论上线程安全</p>
<p>–ServletRequest线程安全</p>
<p>避免在Servlet中创建线程</p>
<p>多个Servlet访问外部对象加锁</p>
<p>在代码中加入</p>
<p>synchronized (this) {</p>
<p>…</p>
<p>}</p>
<p><strong>//JSP</strong></p>
<p>动态网页技术标准</p>
<p>简化的servlet</p>
<p>JSP = Html + Java + JSP tag</p>
<p>JSP处理流程：</p>
<p>客户端—&gt;发送JSP请求—&gt;JSP文件—&gt;转换为Servlet文件—&gt;编译为class文件—&gt;执行并载入servlet实例—&gt;返回响应到客户端</p>
<p>JSP基本语法：</p>
<p>1. 静态内容</p>
<p>模板数据</p>
<p>2. 指令</p>
<p>page指令</p>
<p>–定义页面的依赖属性，比如脚本语言、error页面、缓存需求等</p>
<p>include指令</p>
<p>–包含其他文件</p>
<p>taglib指令</p>
<p>–引入标签库的定义</p>
<p>3. 注释</p>
<p>&lt;%– 注释 –%&gt;</p>
<p>4. 表达式</p>
<p>&lt;%= 表达式 %&gt;</p>
<p> 如下：</p>
<p> Today’s date: &lt;%= (new java.util.Date()).toLocaleString() %&gt; </p>
<p>5. 声明</p>
<p>&lt;%! declaration; [declaration; ] + … %&gt;</p>
<p>如：&lt;%! int a, b, c; %&gt;</p>
<p>6. 脚本</p>
<p>&lt;% 代码片段 %&gt;</p>
<p>如下：</p>
<p>&lt;% out.println(“Your IP address is : “ + request.getRemoteAddr()); %&gt;</p>
<p>JSP内置对象</p>
<p>request             HttpServletRequest类的实例</p>
<p>response          HttpServletResponse类的实例</p>
<p>out                    PrintWriter类的实例，用于把结果输出至网页上</p>
<p>session            HttpSession类的实例</p>
<p>applicaiton       ServletContext类的实例，与应用上下文有关</p>
<p>config               ServletConfig类的实例</p>
<p>page                 类似于Java中的this关键字</p>
<p>pageContext    PageContext类的实例，提供对JSP页面的所有对象以及所有命名空间的访问</p>
<p>Exception         Exception类的对象，代表发生错误的JSP页面对应的异常对象</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/学习笔记-MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KioLuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://b-ssl.duitang.com/uploads/item/201602/18/20160218194039_c2Kmt.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KioLuo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/13/学习笔记-MySQL/" itemprop="url">
                  学习笔记--MySQL
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T19:04:49+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>//安装mysql5.7解压版</strong></p>
<p>1. 解压</p>
<p>2. 设置环境变量 </p>
<p>PATH中加入mysql的bin路径</p>
<p>3. 修改my-default.ini</p>
<p>[mysqld]</p>
<p> basedir = D:\MySQL\Server\mysql-5.6.20-win32<br> datadir = D:\MySQL\Server\data<br> port = 3306</p>
<p>4. 安装mysql服务</p>
<p>在bin下执行：</p>
<p>D:\MySQL\Server\mysql-5.6.20-win32\bin&gt;mysqld -install<br>Service successfully installed.</p>
<p><strong>//MySQL管理</strong></p>
<p><strong>//启动及关闭MySQL</strong></p>
<p>启动mysql服务</p>
<p>若在myql目录中没有data文件夹，则会启动失败，需要在bin中执行：</p>
<p>mysqld –initialize-insecure –user=mysql</p>
<p>会自动创建data文件夹，现在可以启动mysql服务：</p>
<p>net start mysql</p>
<p>登录mysql：</p>
<p>mysql -u root -p</p>
<p>默认密码为空</p>
<p>添加密码：</p>
<p>mysqladmin -u root password “new_password”</p>
<p>关闭mysql服务</p>
<p>mysqladmin -u root -p shutdown</p>
<p><strong>//用户设置</strong></p>
<p>创建用户</p>
<p>CREATE USER ‘username’@’host’ IDENTIFIED BY ‘password’;</p>
<p>说明:username - 你将创建的用户名, host - 指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%. password - 该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器.</p>
<p>注意：%为任意远程主机，localhost和127.0.0.1权限不一样</p>
<p>例子: CREATE USER ‘dog’@’localhost’ IDENTIFIED BY ‘123456’;</p>
<p>CREATE USER ‘pig’@’192.168.1.101_’ IDENDIFIED BY ‘123456’;</p>
<p>CREATE USER ‘pig’@’%’ IDENTIFIED BY ‘123456’;</p>
<p>CREATE USER ‘pig’@’%’ IDENTIFIED BY ‘’;</p>
<p>CREATE USER ‘pig’@’%’;</p>
<p>授权</p>
<p>GRANT privileges ON databasename.tablename TO ‘username’@’host’</p>
<p>说明: privileges - 用户的操作权限,如SELECT , INSERT , UPDATE 等(详细列表见该文最后面).如果要授予所的权限则使用ALL.;databasename - 数据库名,tablename-表名,如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示, 如</em>.*.</p>
<p>注意:用以上命令授权的用户不能给其它用户授权,如果想让该用户可以授权,用以下命令:</p>
<p>GRANT privileges ON databasename.tablename TO ‘username’@’host’ WITH GRANT OPTION;</p>
<p>设置与更改用户密码</p>
<p>SET PASSWORD FOR ‘username’@’host’ = PASSWORD(‘newpassword’);如果是当前登陆用户用SET PASSWORD = PASSWORD(“newpassword”);</p>
<p>例子: SET PASSWORD FOR ‘pig’@’%’ = PASSWORD(“123456”);</p>
<p>撤销用户权限</p>
<p>REVOKE privilege ON databasename.tablename FROM ‘username’@’host’;</p>
<p>注意: 假如你在给用户’pig’@’%’授权的时候是这样的(或类似的):GRANT SELECT ON test.user TO ‘pig’@’%’, 则在使用REVOKE SELECT ON <em>.</em> FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作.相反,如果授权使用的是GRANT SELECT ON <em>.</em> TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select 权限.</p>
<p>删除用户：</p>
<p>DROP USER ‘username’@’host’;</p>
<p>重新载入授权表：</p>
<p>FLUSH PRIVILEGES;</p>
<p>在 mysql 数据库中的 user 表添加新用户：</p>
<pre><code>INSERT INTO user

          (host, user, password,

           select_priv, insert_priv, update_priv)

           VALUES (&apos;localhost&apos;, &apos;guest&apos;,

           PASSWORD(&apos;guest123&apos;), &apos;Y&apos;, &apos;Y&apos;, &apos;Y&apos;);
</code></pre><p>注意：在 MySQL5.7 中 user 表的 password 已换成了authentication_string</p>
<p>通过GRANT命令添加用户并添加权限：</p>
<pre><code>mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP

    -&gt; ON TUTORIALS.*

    -&gt; TO &apos;zara&apos;@&apos;localhost&apos;

    -&gt; IDENTIFIED BY &apos;zara123&apos;;
</code></pre><p><strong>示例：</strong></p>
<pre><code>mysql &gt; create database example default character set utf8;

mysql &gt; create user &apos;server&apos;@&apos;%&apos; identified by &apos;example&apos;;

mysql &gt; grant all on example.* to &apos;server&apos;@&apos;%&apos; identified by &apos;example&apos;;

mysql &gt; use example;

mysql &gt; CREATE TABLE `User` (

      `id` int(11) unsigned NOT NULL AUTO_INCREMENT,

      `userName` varchar(50) NOT NULL DEFAULT &apos;&apos;,

      `userPassword` varchar(50) NOT NULL DEFAULT  &apos;&apos;,

      `userDesc` varchar(100) NOT NULL DEFAULT  &apos;&apos;,

      PRIMARY KEY (`id`)

      ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

mysql &gt; INSERT INTO `User` (`userName`, `userPassword`, `userDesc`) VALUES

       (&apos;test_user&apos;, &apos;test_password&apos;, &apos;Test user for server example&apos;);
</code></pre><p><strong>//管理MySQL的常用命令</strong></p>
<pre><code>mysqladmin -u root -p create ;            //创建数据库

mysqladmin -u root -p drop ;          //删除数据库

CREATE database example default character set utf8;                //创建数据库

USE &lt;数据库名&gt;;        //选择要操作的数据库，以后的MySQL命令都只针对该数据库

SHOW DATABASES;            //列出MySQL数据库管理系统所管理的数据库列表

SHOW TABLES;           //列出指定数据库中的所有表，需要先使用use 数据库

SHOW INDEX FROM &lt;数据表&gt;;               //显示数据表的详细索引信息，包括PRIMARY KEY（主键）

SHOW COLUMNS FROM &lt;数据表&gt;;        //显示数据表的详细列头信息

SHOW TABLE STATUS FROM &lt;数据库&gt; LIKE &apos;需要匹配的字符串&apos;\G;          //该命令将输出Mysql数据库管理系统的性能及统计信息

CREATE TABLE table_name (column_name column_type);            //创建数据表

SHOW PROCESSLIST;       //显示数据库连接线程列表

SHOW CREATE TABLE table_name;        //显示表信息

SHOW VARIABLES LIKE &apos;%character%&apos;;          //显示字符集编码信息
</code></pre><p>实例：</p>
<pre><code>mysql&gt; CREATE TABLE runoob_tbl(-&gt; runoob_id INT NOT NULL AUTO_INCREMENT,-&gt; runoob_title VARCHAR(100) NOT NULL,-&gt; runoob_author VARCHAR(40) NOT NULL,-&gt; submission_date DATE,-&gt; PRIMARY KEY ( runoob_id )-&gt;  ) ENGINE=InnoDB DEFAULT CHARSET = utf8;Query OK,  0 rows affected (0.16 sec)

DROP TABLE table_name;            //删除数据表

INSERT INTO table_name (field1, field2, ... fieldN) VALUES (value1, value2, ...valueN);            //插入数据

SELECT column_name, column_name FROM table_name [WHERE Clause] [OFFSET M] [LIMIT N];    //查询数据

UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause];           //更新数据

DELETE FROM table_name [WHERE Clause];              //删除数据

SELECT field1, field2, ... fieldN table_name1, table_name2,... table_nameN WHERE field1 LIKE condition1;            //where从句中like和%的使用

SELECT field1, field2, ...fieldN table_name1, table_name2, ...table_nameN ORDER BY field1, [field2...] ASC [DESC]
</code></pre><p>//排序</p>
<pre><code>set names utf8;              //设置为utf8编码

SET sql_mode=&apos;NO_AUTO_VALUE_ON_ZERO&apos;;              //设置AUTO_INCREMENT的值从0开始
</code></pre><p>//GROUP BY语法，在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。</p>
<pre><code>SELECT column_name,  function(column_name) FROM table_name
WHERE column_name operator value
GROUP BY column_name;
</code></pre><p>实例：</p>
<pre><code>mysql&gt; SELECT name, COUNT(*) FROM   employee_tbl GROUP BY name;

mysql&gt; SELECT name, SUM(singin)  as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;

mysql&gt; SELECT coalesce(name,  &apos;总数&apos;), SUM(singin)  as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;
</code></pre><p><strong>//MySQL连接的使用</strong></p>
<p>//使用INNER JOIN</p>
<pre><code>例：SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;

等价于：SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;
</code></pre><p>//使用LEFT JOIN</p>
<pre><code>例：SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
</code></pre><p>//使用RIGHT JOIN</p>
<pre><code>例：SELECT b.runoob_id, b.runoob_author, a.runoob_count FROM tcount_tbl a RIGHT JOIN runoob_tbl b ON a.runoob_author = b.runoob_author;
</code></pre><p>//使用NULL</p>
<p>必须使用IS NULL，或IS NOT NULL，或&lt;=&gt;用于比较两个NULL</p>
<p><strong>//MySQL正则表达式</strong></p>
<p>MySQL中使用 REGEXP 操作符来进行正则表达式匹配。</p>
<p>| 模式 | 描述 |<br>| ^ | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 |<br>| $ | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 |<br>| . | 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。 |<br>| […] | 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 |<br>| [^…] | 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。 |<br>| p1|p2|p3 | 匹配 p1 或 p2 或 p3。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 |<br>| <em> | 匹配前面的子表达式零次或多次。例如，zo</em> 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 |<br>| + | 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 |<br>| {n} | n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 |<br>| {n,m} | m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 |</p>
<p><strong>//MySQL事务</strong></p>
<p>1，开始一个事务</p>
<p>start transaction</p>
<p>2, 做保存点</p>
<p>savepoint 保存点名称</p>
<p>3, 操作</p>
<p>4，可以回滚，可以提交，没有问题，就提交，有问题就回滚。</p>
<p>例：</p>
<pre><code>SET AUTOCOMMIT = 0;               //设置为不自动提交，因为MYSQL默认立即执行

BEGIN;             //开始事务定义

...;             //操作

ROLLBACK;             //有问题回滚

COMMIT;               //成功则执行事务
</code></pre><p><strong>//MySQL的ALTER命令</strong></p>
<p>//添加删除表字段</p>
<pre><code>ALTER TABLE testalter_tbl  DROP i;             //删除i字段，不能删除最后一个字段

ALTER TABLE testalter_tbl ADD i INT;         //增加i字段并定义类型

ALTER TABLE testalter_tbl ADD i INT FIRST;             //使用MySQL提供的关键字 FIRST (设定位第一列)

ALTER TABLE testalter_tbl ADD i INT AFTER c;                 //AFTER 字段名（设定位于某个字段之后）
</code></pre><p>//修改字段类型和名称</p>
<pre><code>ALTER TABLE testalter_tbl MODIFY c CHAR(10);                //把字段 c 的类型从 CHAR(1) 改为 CHAR(10)

ALTER TABLE testalter_tbl CHANGE i j BIGINT;              //把字段i名称改为j，并将类型改为BIGINT

ALTER TABLE testalter_tbl MODIFY j BIGINT NOT NULL DEFAULT 100;      //指定字段 j 为 NOT NULL 且默认值为100，若不指定默认值为NULL
</code></pre><p>//修改字段默认值</p>
<pre><code>ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;            //使用 ALTER 来修改字段的默认值

ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;              //使用 ALTER 命令及 DROP子句来删除字段的默认值
</code></pre><p>//修改表名</p>
<pre><code>ALTER TABLE testalter_tbl RENAME TO alter_tbl;        //将数据表 testalter_tbl 重命名为 alter_tbl
</code></pre><p><strong>//MySQL创建索引</strong></p>
<p>//普通索引</p>
<pre><code>CREATE INDEX indexName ON tableName(columnName(length));        //创建索引，方法1

ALTER TABLE tableName ADD INDEX indexName(columnName(length));             //修改表结构，方法2

CREATE TABLE mytable( ID INT NOT NULL,  username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)));             //创建表时直接指定，方法3

DROP INDEX indexName ON tableName;                //删除索引
</code></pre><p>//唯一索引</p>
<pre><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list);              //添加一个主键，要确保主键不为NULL

CREATE UNIQUE INDEX indexName ON mytable(username(length));              //创建索引，方法1

ALTER table mytable ADD UNIQUE [indexName] (username(length));               //修改表结构，方法2

CREATE TABLE mytable( ID INT NOT NULL,  username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)));                          //创建表时指定，方法3

 ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list);               //添加全文索引

ALTER TABLE tbl_name DROP INDEX (column_list);                 //删除索引

ALTER TABLE tbl_name DROP PRIMARY KEY;          //删除主键

SHOW INDEX FROM tableName\G;                 //显示索引信息
</code></pre><p><strong>//MySQL临时表</strong></p>
<pre><code>CREATE TEMPORARY TABLE tableName (...);             //创建临时表
</code></pre><p>删除临时表与删除其他表一样，但show tables不能显示临时表</p>
<p><strong>//MySQL复制表</strong></p>
<pre><code>SHOW CREATE TABLE runoob_tbl \G;                      //获取创建数据表(CREATE TABLE) 语句

复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。

INSERT INTO ... SELECT... 语句来实现复制表的内容

mysql&gt; INSERT INTO clone_tbl (runoob_id,-&gt; runoob_title,-&gt; runoob_author,-&gt; submission_date)-&gt; SELECT runoob_id,runoob_title,-&gt; runoob_author,submission_date -&gt; FROM runoob_tbl;
</code></pre><p><strong>//获取服务器元数据</strong></p>
<pre><code>SELECT VERSION();            //服务器版本信息

SELECT DATABASE();               //当前数据库名

SELECT USER();         //当前用户名

SHOW STATUS;          //服务器状态

SHOW VARIABLES;           //服务器配置变量
</code></pre><p><strong>//MySQL序列使用</strong></p>
<p>使用AUTO_INCREMENT定义列</p>
<pre><code>LAST_INSERT_ID()             //获取最后的插入表中的自增的值的函数
</code></pre><p>重置序列：</p>
<pre><code>mysql&gt; ALTER TABLE insect DROP id; mysql&gt; ALTER TABLE insect -&gt; ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST,-&gt; ADD PRIMARY KEY (id);
</code></pre><p>设置序列的开始值：</p>
<pre><code>mysql&gt; ALTER TABLE t AUTO_INCREMENT =  100;
</code></pre><p>或者在创建时直接AUTO_INCREMENT = 100</p>
<p><strong>//MySQL处理重复数据</strong></p>
<p>防止表中出现重复数据</p>
<p>防止重复插入：</p>
<pre><code>INSERT IGNORE INTO

REPLACE INTO
</code></pre><p>设置唯一索引：</p>
<pre><code>CREATE TABLE person_tbl ( first_name CHAR(20) NOT NULL, last_name CHAR(20) NOT NULL, sex CHAR(10) UNIQUE (last_name, first_name));
</code></pre><p>统计重复数据：</p>
<pre><code>mysql&gt; SELECT COUNT(*)  as repetitions, last_name, first_name -&gt; FROM person_tbl -&gt; GROUP BY last_name, first_name -&gt; HAVING repetitions &gt;  1;
</code></pre><p>过滤重复数据：</p>
<pre><code>mysql&gt; SELECT DISTINCT last_name, first_name -&gt; FROM person_tbl -&gt; ORDER BY last_name;
</code></pre><p>或使用GROUP BY来读取</p>
<p>删除重复数据：</p>
<pre><code>mysql&gt; CREATE TABLE tmp SELECT last_name, first_name, sex -&gt; FROM person_tbl;-&gt; GROUP BY (last_name, first_name); mysql&gt; DROP TABLE person_tbl; mysql&gt; ALTER TABLE tmp RENAME TO person_tbl;
</code></pre><p>或者通过添加主键/索引的方法：</p>
<pre><code>mysql&gt; ALTER IGNORE TABLE person_tbl -&gt; ADD PRIMARY KEY (last_name, first_name);
</code></pre><p><strong>//MySQL导出数据</strong></p>
<p><strong>使用SELECT … INTO OUTFILE …语句导出数据</strong></p>
<pre><code>mysql&gt; SELECT * FROM runoob_tbl -&gt; INTO OUTFILE &apos;/tmp/tutorials.txt&apos;;
</code></pre><p>指定格式，如CSV格式：</p>
<pre><code>mysql&gt; SELECT * FROM passwd INTO OUTFILE &apos;/tmp/tutorials.txt&apos;-&gt; FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos;-&gt; LINES TERMINATED BY &apos;\r\n&apos;;
</code></pre><p>或</p>
<pre><code>SELECT a,b,a+b INTO OUTFILE &apos;/tmp/result.text&apos; FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos; LINES TERMINATED BY &apos;\n&apos; FROM test_table;
</code></pre><p>使用LOAD DATA INFILE可以将文件读回数据库</p>
<p><strong>导出表作为原始数据：</strong></p>
<p>mysqldump是mysql用于转存储数据库的实用程序。它主要产生一个SQL脚本，其中包含从头重新创建数据库所必需的命令CREATE TABLE INSERT等。</p>
<pre><code>$ mysqldump -u root -p --no-create-info \ --tab=/tmp RUNOOB runoob_tbl
password ******
</code></pre><p>导出SQL格式的数据：</p>
<pre><code>$ mysqldump -u root -p RUNOOB runoob_tbl &gt;  dump.txt
password ******
</code></pre><p>导出整个数据库：</p>
<pre><code>$ mysqldump -u root -p RUNOOB &gt; database_dump.txt
password ******
</code></pre><p>导出所有数据库：</p>
<pre><code>$ mysqldump -u root -p --all-databases &gt; database_dump.txt
password ******
</code></pre><p>将数据库拷贝到其他主机：</p>
<pre><code>$ mysqldump -u root -p database_name table_name &gt;  dump.txt
password *****

$ mysql -u root -p database_name &lt;  dump.txt
password *****
</code></pre><p>你也可以使用以下命令将导出的数据直接导入到远程的服务器上，但请确保两台服务器是相通的，是可以相互访问的：p&gt; $ mysqldump -u root -p database_name \ | mysql -h other-host.com database_name</p>
<p><strong>//MySQL导入数据</strong></p>
<p><strong>使用LOAD DATA导入数据</strong></p>
<pre><code>mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl;
</code></pre><p>如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。</p>
<p>指定FIELDS和LINES</p>
<pre><code>mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl -&gt; FIELDS TERMINATED BY &apos;:&apos;-&gt; LINES TERMINATED BY &apos;\r\n&apos;;
</code></pre><p>指定顺序</p>
<pre><code>mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos;-&gt; INTO TABLE mytbl (b, c, a);
</code></pre><p><strong>使用mysqlimport导入数据</strong></p>
<pre><code>$ mysqlimport -u root -p --local  --fields-terminated-by=&quot;:&quot; \ --lines-terminated-by=&quot;\r\n&quot; database_name dump.txt
password *****
</code></pre><p>使用 –columns 选项来设置列的顺序</p>
<pre><code>$ mysqlimport -u root -p --local  --columns=b,c,a \
    database_name dump.txt
password *****
</code></pre><p>mysqlimport的常用选项介绍</p>
<p>| 选项 | 功能 |<br>| -d or –delete | 新数据导入数据表中之前删除数据数据表中的所有信息 |<br>| -f or –force | 不管是否遇到错误，mysqlimport将强制继续插入数据 |<br>| -i or –ignore | mysqlimport跳过或者忽略那些有相同唯一 关键字的行， 导入文件中的数据将被忽略。 |<br>| -l or -lock-tables | 数据被插入之前锁住表，这样就防止了， 你在更新数据库时，用户的查询和更新受到影响。 |<br>| -r or -replace | 这个选项与－i选项的作用相反；此选项将替代 表中有相同唯一关键字的记录。 |<br>| –fields-enclosed- by= char | 指定文本文件中数据的记录时以什么括起的， 很多情况下 数据以双引号括起。 默认的情况下数据是没有被字符括起的。 |<br>| –fields-terminated- by=char | 指定各个数据的值之间的分隔符，在句号分隔的文件中， 分隔符是句号。您可以用此选项指定数据之间的分隔符。 默认的分隔符是跳格符（Tab） |<br>| –lines-terminated- by=str | 此选项指定文本文件中行与行之间数据的分隔字符串 或者字符。 默认的情况下mysqlimport以newline为行分隔符。 您可以选择用一个字符串来替代一个单个的字符： 一个新行或者一个回车。 |</p>
<p><strong>SQL数据类型</strong></p>
<p>| INTEGER或INT | 通常为32位整数 |<br>| SMALLINT | 通常为16位整数 |<br>| NUMERIC(m, n), DECIMAL(m, n) 或 DEC(m, n) | m位长的定点十进制数，其中小数点后为n位 |<br>| FLOAT(n) | 运算精度为n位二进制数的浮点数 |<br>| REAL | 通常为32位浮点数 |<br>| DOUBLE | 通常为64位浮点数 |<br>| CHARACTER(n)或CHAR(n) | 固定长度为n的字符串 |<br>| VARCHAR(n) | 最大长度为n的字符串 |<br>| BOOLEAN | 布尔值 |<br>| DATE | 日历日期 |<br>| TIME | 当前时间 |<br>| TIMESTAMP | 当前日期和时间 |<br>| BLOB | 二进制大对象 |<br>| CLOB | 字符大对象 |</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/学习笔记-maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KioLuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://b-ssl.duitang.com/uploads/item/201602/18/20160218194039_c2Kmt.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KioLuo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/13/学习笔记-maven/" itemprop="url">
                  学习笔记--maven
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T19:04:38+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>//更改镜像库</strong></p>
<pre><code>在&lt;mirrors&gt;元素里面加一个&lt;mirror&gt;配置
&lt;mirror&gt;
    &lt;id&gt;aliyun&lt;/id&gt;
    &lt;mirrorOf&gt;centeral&lt;/mirrorOf&gt;
    &lt;name&gt;aliyun mirror&lt;/name&gt;
    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
&lt;/mirror&gt;

在&lt;profiles&gt;中加一个&lt;profile&gt;配置

&lt;profile&gt;
    &lt;id&gt;aliyun&lt;/id&gt;
    &lt;activation&gt;
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
    &lt;/activation&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;pluginRepositories&gt;
            &lt;pluginRepository&gt;
                &lt;id&gt;aliyun&lt;/id&gt;
            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
            &lt;/pluginRepository&gt;
      &lt;/pluginRepositories&gt;
&lt;/profile&gt;
</code></pre><p><strong>//配置默认JDK版本</strong></p>
<p>方法一：</p>
<p>在maven的配置文件settings.xml中的标签里添加如下代码，设置默认JRE编译版本为1.7</p>
<pre><code>&lt;profile&gt;
  &lt;id&gt;jdk-1.7&lt;/id&gt;

  &lt;activation&gt;
     &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
     &lt;jdk&gt;1.7&lt;/jdk&gt;
  &lt;/activation&gt;

  &lt;properties&gt;
    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
    &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt;
  &lt;/properties&gt;
&lt;/profile&gt;
</code></pre><p>方法二：在pom.xml的中添加如下代码，修改maven默认的JRE编译版本，1.7代表JRE编译的版本</p>
<pre><code>&lt;plugin&gt;    
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;    
    &lt;configuration&gt;
        &lt;source&gt;1.7&lt;/source&gt;    
        &lt;target&gt;1.7&lt;/target&gt;    
    &lt;/configuration&gt;
&lt;plugin&gt;
</code></pre><p><strong>//创建Kitchen项目</strong></p>
<p>mvn archetype:generate -DgroupId=com.netease.restaurant -DartifactId=Kitchen -Dpackage=com.netease -Dversion=1.0.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-quickstart</p>
<p><strong>//创建Restaurant</strong></p>
<p>mvn archetype:generate -DgroupId=com.netease.restaurant -DartifactId=Restaurant -Dpackage=com.netease -Dversion=1.0.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-webapp</p>
<p><strong>//maven工程和java工程转换</strong></p>
<p>mvn eclipse:eclipse<br>或<br>mvn eclipse:myeclipse</p>
<p>eclipse中转换</p>
<p>maven工程转为一般工程：工程右键–&gt;Maven–&gt;Disable Maven Nature转为一般工程</p>
<p>一般工程转为maven工程：工程右键–&gt;Configure–&gt;Convert to maven project</p>
<p><strong>//查看帮助</strong></p>
<p>mvn help:describe -Dplugin= -Dgoal= -Ddetail=true</p>
<p>mvn help:help -Ddetail=true</p>
<p>mvn help:describe -Dplugin=war<br>或者<br>mvn help:describe -Dplugin=org.apache.maven.plugins:maven-war-plugin<br>或者</p>
<p>mvn help:describe -DgroupId=org.apache.maven.plugins -DartifactId=maven-war-plugin</p>
<p><strong>//修改tomcat的context path</strong></p>
<p>Tomcat自身可以通过修改配置文件server.xml，在和之间插入如下语句:</p>
<pre><code>&lt;Context path=&quot;/xxxx&quot; docBase=&quot;F:\xxxx\WebRoot&quot; debug=&quot;0&quot; privileged=&quot;true&quot;&gt; &lt;/Context&gt;
</code></pre><p>对应maven的tomcat插件弄法如下：</p>
<pre><code>&lt;!-- tomcat 7 --&gt;
&lt;plugin&gt;
&lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
&lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;2.0-SNAPSHOT&lt;/version&gt;
&lt;configuration&gt;
&lt;path&gt;${context.path}&lt;/path&gt;
&lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt;
&lt;server&gt;tomcat7&lt;/server&gt;
&lt;username&gt;admin&lt;/username&gt;
&lt;password&gt;admin&lt;/password&gt;
&lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/学习笔记-JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KioLuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://b-ssl.duitang.com/uploads/item/201602/18/20160218194039_c2Kmt.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KioLuo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/13/学习笔记-JavaScript/" itemprop="url">
                  学习笔记--JavaScript
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T19:04:22+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如何插入JS</p>
<p><code>&lt;script type=&quot;text/javascript&quot;&gt;</code></p>
<p><code>document.write(&quot;开启JS之旅!&quot;);</code></p>
<p><code>script&gt;</code></p>
<p>外部引入javascript文件</p>
<p><code>&lt;script src=&quot;script.js&quot;&gt;script&gt;</code></p>
<p>常用互动方法：</p>
<p><code>document.write()</code></p>
<p><code>alert()</code></p>
<p><code>confirm()</code></p>
<p><code>prompt()</code></p>
<p><code>window.open()</code></p>
<p><code>window.close()</code></p>
<p>DOM（文档对象模型）</p>
<p><code>var obj = document.getElementById(&quot;id&quot;)</code></p>
<p><code>document.body</code></p>
<p><code>obj.innerHTML</code></p>
<p><code>obj.style.color</code></p>
<p><code>obj.style.fontSize</code></p>
<p><code>obj.style.display</code></p>
<p><code>obj.className</code></p>
<p>创建数组语法：</p>
<p><code>var myarray=new  Array();</code></p>
<p><code>var myarray =  new  Array(66,80,90,77,59);//创建数组同时赋值</code></p>
<p><code>var myarray =  [66,80,90,77,59];//直接输入一个数组（称 “字面量数组”）</code></p>
<p>定义函数</p>
<p><code>function add2(x,y)</code></p>
<p><code>{</code></p>
<p><code>sum = x + y;</code></p>
<p><code>return sum;  //返回函数值,return后面的值叫做返回值。</code></p>
<p><code>}</code></p>
<p>主要事件表</p>
<p>| </p>
<p>onclick  </p>
<p> | 鼠标单击事件 |<br>| onmouseover | 鼠标经过事件     |<br>| onmouseout     | 鼠标离开事件     |<br>| onchange     | 文本框内容改变事件     |<br>| onselect     | 文本框内容被选中事件     |<br>| onfocus     | 光标聚集     |<br>| onblur     | 光标离开     |<br>| onload     | 网页载入     |<br>| onunload     | 网页关闭 |</p>
<p>  Date日期对象</p>
<p><code>get/setDate()</code></p>
<p><code>get/setFullYear()</code></p>
<p><code>get/setYear()</code></p>
<p><code>get/setMonth()</code></p>
<p><code>get/setHours()</code></p>
<p><code>get/setMinutes()</code></p>
<p><code>get/setSeconds()</code></p>
<p><code>get/setTime()</code></p>
<p>parseInt()</p>
<p>字符串</p>
<p>charAt()</p>
<p>toUpperCase()</p>
<p>toLowerCase()</p>
<p>indexOf(subString, startIndex)</p>
<p>split(separator, limit)</p>
<p>substring(startpos, endpos)</p>
<p>substr(startPos, length)</p>
<p><strong>Math对象</strong>，无需创建，直接使用</p>
<p><strong>Array数组对象</strong></p>
<p>| concat()     | 连接两个或更多数组     |<br>| join()     | 把数组所有元素放进字符串，可用指定分隔符进行分隔     |<br>| pop()     | 删除并返回数组的最后一个元素     |<br>| push()     | 向数组的末尾添加一个或更多元素，返回新的长度     |<br>| reverse()     | 颠倒数组中的元素顺序     |<br>| shift()     | 删除并返回数组的第一个元素     |<br>| slice()     | 从某个已有的数组返回选定的元素     |<br>| sort()     | 对数组的元素进行排序     |<br>| splice()     | 删除元素并向数组添加新元素     |<br>| toSource()     | 返回该对象的源代码 |<br>| toString()     | 把数组转换为字符串，返回结果     |<br>| toLocaleString()   | 把数组转换为本地数组     |<br>| unshift()     | 向数组的开头添加一个或更多元素     |<br>| valueOf()     | 返回数组对象的原始值 |</p>
<p><strong>window对象方法</strong></p>
<p>| alert()     | 显示带有一段消息和一个确认按钮的对话框     |<br>| prompt()     | 显示可提示用户输入的对话框     |<br>| confirm()     | 显示带有一段消息和一个确认按钮、一个取消按钮的对话框     |<br>| open() | 打开一个新的浏览器窗口     |<br>| close()     | 关闭浏览器窗口     |<br>| print()     | 打印当前窗口的内容     |<br>| focus()     | 把焦点给予一个窗口     |<br>| blur()     | 把键盘焦点从顶层窗口移开     |<br>| moveBy()     | 可相对窗口的当前坐标把它移动指定的像素     |<br>| moveTo()     | 把窗口的左上角移动到一个指定的坐标 |<br>| resizeBy()     | 按照指定的像素重新调整窗口的大小     |<br>| resizeTo()     | 把窗口的大小调整到指定的宽度和高度     |<br>| scrollBy()     | 按照指定的像素滚动内容     |<br>| scrollTo()     | 将内容滚动到指定的坐标     |<br>| setInterval()     | 每隔指定的时间执行代码     |<br>| setTimeout()     | 在一定的延迟后执行代码     |<br>| clearInterval()     | 清除setInterval()设置     |<br>| clearTimeout()     | 清除setTimeout()设置 |</p>
<p><strong>History对象</strong></p>
<p>window.history.[属性 | 方法]</p>
<p>window.history.length</p>
<p>window.history.back() 等价于window.history.go(-1)</p>
<p>window.history.forward() 等价于window.history.go(1)</p>
<p>window.history.go()</p>
<p><strong>Location对象</strong></p>
<p>location.[属性 | 方法]</p>
<p>属性</p>
<p>| hash     | 设置或返回从#开始的url     |<br>| host     | 设置或返回主机名和当前URL的端口号     |<br>| hostname     | 设置或返回当前URL的主机名     |<br>| port     | 设置或返回当前URL的端口号     |<br>| href     | 设置或返回完整的URL     |<br>| pathname     | 设置或返回当前URL的路径部分     |<br>| protocol     | 设置或返回当前URL的协议     |<br>| search     | 设置或返回从？开始的URL部分 |</p>
<p>方法</p>
<p>| assign()     | 加载新的文档     |<br>| reload()     | 重新加载当前文档     |<br>| replace()     | 用新的文档替换当前文档 |</p>
<p><strong>Navigator对象</strong></p>
<p>navigator.[属性]</p>
<p>| appCodeName     | 浏览器代码名的字符串显示     |<br>| appName     | 返回浏览器的名称     |<br>| appVersion | 返回浏览器的平台和版本信息     |<br>| platform     | 返回运行浏览器的系统平台     |<br>| userAgent     | 返回由客户机发送服务器的user-agent头部的值 |</p>
<p><strong>Screen对象</strong></p>
<p>用于获取用户的屏幕信息</p>
<p>window.screen.属性        也可以不使用window这个前缀</p>
<p>| availHeight     | 窗口可以使用的屏幕高度，单位像素     |<br>| availWidth     | 窗口可以使用的屏幕宽度，单位像素     |<br>| colorDepth     | 用户浏览器表示的颜色位数，通常为32位（每像素的位数） |<br>| pixelDepth     | 用户浏览器表示的颜色位数，通常为32位（每像素的位数） |<br>| height     | 屏幕的高度，单位像素     |<br>| width     | 屏幕的宽度，单位像素 |</p>
<p><strong>DOM对象</strong></p>
<p>元素节点，属性节点，文本节点</p>
<p>节点属性</p>
<p>| nodeName     | 返回一个字符串，其内容是给定节点的名字     |<br>| nodeType     | 返回一个整数，这数值代表给定节点的类型     |<br>| nodeValue     | 返回给定节点的当前值     |<br>| childNodes     | 返回数组，这个数组由给定节点的子节点组成     |<br>| firstChild     | 返回第一个子节点     |<br>| lastChild     | 返回最后一个子节点     |<br>| parentNode     | 返回一个给定节点的父节点     |<br>| nextSibling     | 返回给定节点的下一个子节点     |<br>| previousSibling     | 返回给定节点的上一个子节点     |</p>
<p><strong>DOM操作</strong></p>
<p>| createElement(element) | 创建一个新的元素节点     |<br>| createTextNode()     | 创建一个包含指定文本的文本节点     |<br>| appendChild()     | 指定节点的最后一个子节点列表后添加一个子节点     |<br>| insertBefore()     | 将一个给定节点插入到一个给定节点的子节点后面     |<br>| removeChild()     | 删除一个给定节点的子节点     |<br>| replaceChild()     | 把一个父节点的子节点替换为另一个子节点 |</p>
<p>document.getElementsByName()    //返回给定名字的元素标签数组</p>
<p>document.getElementsByTagName()   //返回相应标签名的元素标签数组</p>
<p>elementNode.getAttribute(name)  //通过元素节点的属性名称获取属性的值</p>
<p>elementNode.setAttribute(name, value) //增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值</p>
<p>在超链接中加入javascript</p>
<p><code>&lt;a href=&quot;javascript:replaceMessage()&quot;&gt;...a&gt;</code></p>
<p>点击按钮时加入javascript</p>
<p>浏览器窗口可视区域大小</p>
<p><code>window.innerWidth</code></p>
<p><code>window.innerHeight</code></p>
<p>在不同浏览器都实用的 JavaScript 方案：</p>
<p>var w= document.documentElement.clientWidth<br>      || document.body.clientWidth;<br>var h= document.documentElement.clientHeight<br>      || document.body.clientHeight;</p>
<p>网页尺寸scrollHeight</p>
<p>var w=document.documentElement.scrollWidth<br>   || document.body.scrollWidth;<br>var h=document.documentElement.scrollHeight<br>   || document.body.scrollHeight;</p>
<p>网页尺寸offsetHeight</p>
<p>offsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。</p>
<p> var w= document.documentElement.offsetWidth || document.body.offsetWidth;</p>
<p>var h= document.documentElement.offsetHeight || document.body.offsetHeight;</p>
<p>网页卷去的距离与偏移量</p>
<p>scrollLeft、scrollTop、offsetLeft、offsetTop</p>
<p>offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。</p>
<p><strong>编程挑战示例（选项卡切换）</strong></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;实践题 - 选项卡&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        *{padding:0px;margin: 0px;font:12px normal &quot;microsoft yahei&quot;;}
        #tabs {width:290px;padding:5px;height:150px;margin:20px;}
        #tabs ul{list-style:none;display: block;height:30px;line-height:30px;border-bottom:2px saddlebrown solid;}
        #tabs ul li{background:#fff;cursor:pointer;float:left;list-style:none;height:28px;line-height:28px;margin:0px 3px;border:1px solid #aaaaaa;border-bottom:none;display:inline-block;width:60px;text-align: center;}
        #tabs ul li.on{border-top:2px solid saddlebrown;border-bottom: 2px solid #fff;}
        #tabs div{height:120px;line-height: 25px;border:1px solid #336699;border-top:none;padding:5px;}
        .hide{display: none;}
    &lt;/style&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
         window.onload = function(){
             var oTab = document.getElementById(&quot;tabs&quot;);
             var oUl = oTab.getElementsByTagName(&quot;ul&quot;)[0];
             var oLis = oUl.getElementsByTagName(&quot;li&quot;);
             var oDivs= oTab.getElementsByTagName(&quot;div&quot;);
             for(var i= 0,len = oLis.length;i&lt;len;i++){
                 oLis[i].index = i;
                 oLis[i].onclick = function() {
                     for(var n= 0;n&lt;len;n++){
                         oLis[n].className = &quot;&quot;;
                         oDivs[n].className = &quot;hide&quot;;
                     }
                     this.className = &quot;on&quot;;
                     oDivs[this.index].className = &quot;&quot;;
                 }
             };
         }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;tabs&quot;&gt;
    &lt;ul&gt;
        &lt;li class=&quot;on&quot;&gt;房产&lt;/li&gt;
        &lt;li&gt;家居&lt;/li&gt;
        &lt;li&gt;二手房&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div&gt;
        275万购昌平邻铁三居 总价20万买一居&lt;br&gt;
        200万内购五环三居 140万安家东三环&lt;br&gt;
        北京首现零首付楼盘 53万购东5环50平&lt;br&gt;
        京楼盘直降5000 中信府 公园楼王现房&lt;br&gt;
    &lt;/div&gt;
    &lt;div class=&quot;hide&quot;&gt;
        40平出租屋大改造 美少女的混搭小窝&lt;br&gt;
        经典清新简欧爱家 90平老房焕发新生&lt;br&gt;
        新中式的酷色温情 66平撞色活泼家居&lt;br&gt;
        瓷砖就像选好老婆 卫生间烟道的设计&lt;br&gt;
    &lt;/div&gt;
    &lt;div class=&quot;hide&quot;&gt;
        通州豪华3居260万 二环稀缺2居250w甩&lt;br&gt;
        西3环通透2居290万 130万2居限量抢购&lt;br&gt;
        黄城根小学学区仅260万 121平70万抛!&lt;br&gt;
        独家别墅280万 苏州桥2居优惠价248万&lt;br&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/学习笔记-Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KioLuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://b-ssl.duitang.com/uploads/item/201602/18/20160218194039_c2Kmt.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KioLuo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/13/学习笔记-Java/" itemprop="url">
                  学习笔记--Java
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T19:04:07+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>//输入输出</strong></p>
<p>Scanner in = new Scanner(System.in);</p>
<p>int a = in.nextInt();</p>
<p>int b = in.next();</p>
<p>System.out.println(in.nextLine());</p>
<p><strong>//输入流 InputStream</strong></p>
<p>System.in.read(buffer);        //读取输入流存到buffer（byte[]类型）中</p>
<p>System.in.read();        //读一个字节，若结尾返回-1</p>
<p>System.in.read(buffer, int off, int len);        //    读len个字节，从buffer[off]开始存</p>
<p>System.in.skip(n);        //输入流跳过n个字节</p>
<p>System.in.available();</p>
<p>System.in.mark();        //标记</p>
<p>System.in.reset();        //返回标记处</p>
<p>System.in.markSupported;        //是否支持标记</p>
<p>System.in.close();        //关闭输入流</p>
<p> //类java.io.StreamTokenizer可以获取输入流并将其分析为Token(标记)。StreamTokenizer的nextToken方法将读取下一个标记,下一个标记的类型在ttype字段中返回。关于令牌的附加信息可能是在nval字段或标记生成器的sval 字段，结束标志为TT_EOF。</p>
<p>StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); </p>
<p>st.nextToken();</p>
<p>int m=(int)st.nval;</p>
<p><strong>//输出流 OutputStream</strong></p>
<p>System.out.write(int b);</p>
<p>System.out.write(byte[] b);</p>
<p>System.out.write(byte[] b, int off, int len);</p>
<p>System.out.flush();</p>
<p>System.out.close();</p>
<p><strong>//文件流</strong></p>
<p><strong>//二进制数据读写（字节流）</strong></p>
<p>FileOutputStream out = new FileOutputStream(“a.txt”);        //根据字节读写数据</p>
<p>out.write(buffer);</p>
<p>out.close(); </p>
<p>FileInputStream in = new FileInputStream(“a.txt”);</p>
<p>in.read();</p>
<p>in.close();</p>
<p>DataOutputStream out = new DataOutputStream(</p>
<pre><code>new BufferedOutputStream(

    new FileOutputStream(&quot;a.txt&quot;)));        //读写基本类型数据
</code></pre><p>out.writeInt(int a);</p>
<p>DataInputStream in = new DataInputStream(</p>
<pre><code>new BufferedInputStream(

      new FileInputStream(&quot;a.txt&quot;)));
</code></pre><p>in.readInt();</p>
<p><strong>//文本数据读写（字符流）</strong></p>
<p>PrintWriter out = new PrintWriter(</p>
<pre><code>new BufferedWriter(

          new OutputStreamWriter(

                   new FileOutputStream(&quot;a.txt&quot;))));        //输出文本数据
</code></pre><p>out.println(“abcdefg”);</p>
<p>out.format(“格式”,…);</p>
<p>out.printf(“格式”, …);</p>
<p>out.print(基本类型);</p>
<p>BufferedReader in = new BufferedReader(</p>
<pre><code>new InputStreamReader(

      new FileInputStream(&quot;a.txt&quot;)));                   //读文本数据         
</code></pre><p>String line = in.readLine();</p>
<p>in.getLineNumber();</p>
<p>FileReader in = new FileReader(String fileName);        //在给定从中读取数据的文件名的情况下新建FileReader</p>
<p>FileReader in = new FileReader(File file);             //在给定从中读取数据的File的情况下新建FileReader</p>
<p><strong>//转换编码</strong></p>
<p>InputStreamReader(InputStream in, String charsetName);        //创建使用指定字符集的InputStreamReader</p>
<p><strong>//网络端口连接读写数据</strong></p>
<p>Socket  socket = new Socket(InetAddress.getByName(“localhost”), 12345);        //建立与本地12345端口的连接</p>
<p>PrintWriter out = new PrintWriter(</p>
<pre><code>new BufferedWriter(

     new OutputStreamWriter(

           socket.getOutputStream())));                            //建立对socket的输出流
</code></pre><p><strong>//读写对象</strong></p>
<p>class Student implements Serializable {</p>
<p>…</p>
<p>}                                                                                           //类实现Serializable串行化接口</p>
<p>ObjectOutputStream out = new ObjectOutputStream(</p>
<pre><code>new FileOutputStream(&quot;a.dat&quot;));                        //对象输出流
</code></pre><p>out.writeObject(Student stu1);</p>
<p>ObjectInputStream in = new ObjectInputStream(</p>
<pre><code>new FileInputStream(&quot;a.dat&quot;);                            //对象输入流
</code></pre><p>out.readObject(Student stu2);</p>
<p><strong>//字符串操作</strong></p>
<p>String s = new String();</p>
<p>s.equals(“abc”);</p>
<p>s1.compareTo(s2);</p>
<p>s.substring(n);</p>
<p>s.substring(n1, n2);</p>
<p>s.charAt(index);</p>
<p>s.indexOf(c);</p>
<p>s.indexOf(c, n);</p>
<p>s.indexOf(t);        //也可以寻找字符串位置</p>
<p>s.lastIndexOf(c);        //从右边开始找</p>
<p>s.startsWith(t);        //是否由字符串t开始</p>
<p>s.endsWith(t);        //是否由字符串t结尾</p>
<p>s.trim();        //把字符串两端的空格删掉</p>
<p>s.replace(c1, c2);        //把s中所有的c1都换成c2</p>
<p>s.toLowerCase();        //把s中所有的大写字母换成小写字母</p>
<p>s.toUpperCase();        //把s中所有的小写字母换成大写字母</p>
<p>s.split(“ “);        //按某个字符（比如空格）将字符串提取出来</p>
<p>StringBuffer sb = new StringBuffer();        //用作字符串缓存器</p>
<p>StringBuilder sb = new StringBuilder();      //与StringBuffer相似，没有实现线程安全功能</p>
<p>sb.append(“”);        //增加一个字符串</p>
<p>sb.insert(n, “”);      //插入字符串</p>
<p>sb.toString();        //转换成字符串</p>
<p>String.format(“Hello, %s. Next year, you’ll be %d”, name, age);            //格式化字符串</p>
<p><strong>//Java中的包装类</strong></p>
<p>Integer类的常用方法：</p>
<p>byteValue()        //将Integer转换为byte类型</p>
<p>doubleValue()       //将Integer转换为double类型</p>
<p>…</p>
<p>基本类型转换为字符串：</p>
<p>Integer.toString(int n)        //转换为字符串类型</p>
<p>String.valueOf(int n)           //int类型转换为字符串类型</p>
<p>字符串转换为基本类型：</p>
<p>Integer.parseInt(Stirng s)    //将字符串转换为int类型</p>
<p>Integer.valueOf(String s)             //将字符串转换为Integer类型</p>
<p><strong>//时间类</strong></p>
<p>Date d = new Date();              //java.util包中，默认无参构建当前时间</p>
<p>SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);             //java.text包中，创建目标格式对象</p>
<p>String today = sdf.format(d);            //将时间格式化为指定格式</p>
<p>Date date = sdf.parse(today);        //将字符串按指定格式转化为时间</p>
<hr>
<p>Calendar c = Calendar.getInstance();                    //java.util.Calendar，创建Calendar对象，初始化为当前时间</p>
<p>int year = c.get(Calendar.YEAR);</p>
<p>int month = c.get(Calendar.MONTH)+1;              //0表示1月份</p>
<p>int day = c.get(Calendar.DAY_OF_MONTH);</p>
<p>int hour = c.get(Calendar.HOUR_OF_DAY);</p>
<p>int minute = c.get(Calendar.MINUTE);</p>
<p>int second = c.get(Calendar.SECOND);</p>
<p>Date date = c.getTime();           //Date和Calendar类互转</p>
<p>Long time = c.getTimeInMillis();              //获取当前毫秒数</p>
<p><strong>//数学函数</strong></p>
<p>Math.abs(a);        // java.lang包，求绝对值</p>
<p>Math.pow(a);        //指数运算</p>
<p>Math.random();        //产生从0到1间的随机数</p>
<p>Math.round(a);        //求近似</p>
<p>Math.floor();           //返回小于参数的最大整数</p>
<p>Math.ceil();           //返回大于参数的最小整数</p>
<p><strong>//集合</strong></p>
<p><strong>//容器类</strong></p>
<p>Collection接口，子接口有Set，List，Queue，实现类有ArrayList, LinkedList, HashSet</p>
<p>Map接口，实现类有HashMap</p>
<hr>
<p>ArrayList list = new ArrayList();        //定义ArrayList容器，ArrayList是List接口的一个实现类，List是Collection的子接口</p>
<p>list.add(s);        //增加元素</p>
<p>list.add(n, s);   //在位置n上插入元素</p>
<p>list.addAll(Array.asList(array));         //将数组转换为list并添加到list中</p>
<p>list.addAll(n, Array.asList(array));        //插入到指定位置</p>
<p>list.remove(s);   //删除指定元素或指定位置元素</p>
<p>list.removeAll(Array.asList(array));        //删除list中指定的元素集合</p>
<p>list.set(n, s);      //修改n位置的元素为s</p>
<p>list.size();          //返回大小</p>
<p>Iterator it = list.iterator();           //获取list的迭代器</p>
<p>it.hasNext();         //判断迭代器是否有下一个元素</p>
<p>it.Next();            //利用迭代器获取下一个元素</p>
<p><strong>//HashMap散列表</strong></p>
<p>HashMap coinnames = new HashMap();</p>
<p>coinnames.put(1, “penny”);        //放进键值对</p>
<p>coinnames.get(1);        //返回键1对应的值</p>
<p>coinnames.containsKey(1);        //是否包含某键</p>
<p>coinnames.keySet();        //返回键的集合</p>
<p><strong>//图形界面包</strong></p>
<p>import javax.swing.JFrame;        //图形窗口</p>
<p>import javax.swing.JPanel;        //图形面板</p>
<p>import javax.swing.JButton;        //图形按钮</p>
<p>import java.awt.Color;        //颜色设置</p>
<p>import java.awt.Graphics;        //绘制图像</p>
<p>import java.awt.BorderLayout;        //组件布局管理</p>
<p>import java.awt.event.ActionEvent;        //事件处理</p>
<p>import java.awt.event.ActionListener;        //事件监听</p>
<p>import javax.swing.JScrollPane;        //滚动面板</p>
<p>import javax.swing.JTable;        //图形表格</p>
<p>import javax.swing.table.TableModel;        //表格的数据模型接口</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/学习笔记-Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KioLuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://b-ssl.duitang.com/uploads/item/201602/18/20160218194039_c2Kmt.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KioLuo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/13/学习笔记-Git/" itemprop="url">
                  学习笔记--Git
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T19:03:55+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>//帮助</p>
<p>git help </p>
<p>git  –help</p>
<p>git  -h</p>
<p>//配置</p>
<p>//用户配置</p>
<p>git config –global user.name “John Everything”      </p>
<p>git config –global user.email test@example.com</p>
<p>//配置级别</p>
<p>–local 默认，只影响本仓库  (.git/config)</p>
<p>–global  影响当前用户所有仓库  (~/.gitconfig)</p>
<p>–system 影响全系统的仓库  (/etc/gitconfig)</p>
<p>//查看仓库状态</p>
<p>git status</p>
<p>//初始化仓库</p>
<p>git init </p>
<p>//添加文件到暂存区（使跟踪文件）</p>
<p>git add </p>
<p>//添加忽略文件</p>
<p>./gitignore中配置忽略文件</p>
<p>//删除文件</p>
<p>git rm –cached  //仅从暂存区删除</p>
<p>git rm  //从暂存区和工作目录删除</p>
<p>git rm $(git ls-files –deleted)   //删除所有被跟踪，但在工作目录已被删除的文件</p>
<p>//提交文件</p>
<p>git commit -m “initial commit”</p>
<p>git commit -a -m “initial commit”</p>
<p>//提交历史</p>
<p>git log</p>
<p>git log –oneline</p>
<p>git log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit</p>
<p>//设置命令别名</p>
<p>git config alias. </p>
<p>git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”</p>
<p>//查看版本差异</p>
<p>git diff         //查看工作目录与暂存区的差异</p>
<p>git diff –cached []        //暂存区与某次提交的差异，默认为HEAD</p>
<p>git diff []         //工作目录与某次提交的差异</p>
<p>//撤销工作目录修改</p>
<p>git checkout – </p>
<p>//撤销暂存区内容</p>
<p>git reset HEAD </p>
<p>//撤销全部改动</p>
<p>git checkout HEAD – </p>
<p>//分支操作</p>
<p>git branch            //增加分支</p>
<p>git branch -d             //删除分支</p>
<p>git branch -v            //显示所有分支信息</p>
<p>//切换分支</p>
<p>git checkout        //切换到某分支</p>
<p>git checkout -b          //创建并切换到某分支</p>
<p>git checkout               //切换到某commit ID</p>
<p>git checkout -            //切换到上一分支</p>
<p>//回退到某次提交状态</p>
<p>git reset –mixed        //回退到某提交状态，并恢复暂存区</p>
<p>git reset –hard         //回退到某提交状态，恢复暂存区和工作目录</p>
<p>git reset –soft          //回退到某提交状态，保持暂存区和工作目录不变</p>
<p>//查看最近提交信息</p>
<p>git reflog</p>
<p>//对commitId使用捷径</p>
<p>A^          //A上的父提交</p>
<p>A~n         //A之前的第N次提交</p>
<p>//保存工作目录和暂存区</p>
<p>git stash save ‘first save’             //保存到stash区，返回干净的暂存区和工作目录</p>
<p>git stash list          //列出stash区的目录</p>
<p>git stash apply stash@{0}        //载入stash区的某次存储</p>
<p>git stash drop stash@{0}         //删除stash区的某次存储</p>
<p>捷径：stash pop = stash apply + stash drop</p>
<p>//分支合并</p>
<p>git merge       //在branch1中将branch1和branch2合并</p>
<p>git merge  –no-ff         //防止使用fast-forward方式的合并</p>
<p>//查看git信息</p>
<p>git cat-file -p HEAD         //查看HEAD信息</p>
<p>//发生冲突时，手动修改文件后进行手动提交</p>
<p>git add .</p>
<p>git commit -m ‘resolve’</p>
<p>//修剪提交历史支线，变基</p>
<p>git rebase master           //使其他分支在master分支上重演，变为线性提交</p>
<p>git rebase –onto master        //选择性地使commitId之后的提交在master上重演</p>
<p>//使用标签</p>
<p>git tag v0.1 e39d0b2</p>
<p>git tag -a 0.1.3 -m “Release version 0.1.3″         //  -a 0.1.3是增加 名为0.1.3的标签，  -m 后面跟着的是标签的注释</p>
<p>git push origin –tags        //–tags参数表示提交所有tag至服务器端，普通的git push origin master操作不会推送标签到服务器端。</p>
<p>git tag -d 0.1.3         //删除标签</p>
<p>git push origin :refs/tags/0.1.3           //删除远端服务器的标签</p>
<p>//远程连接服务器</p>
<p>git init ~/git-server –bare          //初始化一个本地的远程服务器，裸仓库，没有工作目录</p>
<p>git push /users/test/git-server master          //提交到远程服务器</p>
<p>git push -u origin master           //如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用Git push</p>
<p>//配置远程映射</p>
<p>git remote add origin ~/git-server         //添加一个远程仓库别名</p>
<p>git remote -v                   //查看远程仓库信息</p>
<p>//获取远程仓库的提交</p>
<p>git fetch origin master</p>
<p>git pull = git fetch + git merge</p>
<p>//获取获取远程仓库</p>
<p>git clone = git init + git remote + git pull</p>
<p>git clone ~/git-server test         //从服务器端将仓库克隆到本地test</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/读书笔记-Java核心技术-基础篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KioLuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://b-ssl.duitang.com/uploads/item/201602/18/20160218194039_c2Kmt.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KioLuo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/13/读书笔记-Java核心技术-基础篇/" itemprop="url">
                  读书笔记--Java核心技术--基础篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T19:03:40+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>第三章   Java基本程序设计—————————————————————–</strong></p>
<p><strong>Java有8种基本类型</strong></p>
<p>4种整型：int, long, short, byte；长整型后缀加L，0x前缀表示十六进制，0前缀表示八进制，0b前缀表示二进制</p>
<p>2种浮点类型：float, double；后缀F表示float，后缀D表示double，默认使用double</p>
<p>常量Double.POSITIVE_INFINITY，Double.NEGATIVE_INFINITY，Double.NaN，表示正无穷大，负无穷大，非数值。</p>
<p>判断是否非数值用Double.isNaN(x)</p>
<p>1种字符类型：char，采用UTF-16编码描述一个代码单元，最好不要在程序中使用char类型，除非需要对UTF-16代码单元进行操作</p>
<p>1种boolean类型，整型和布尔类型不能互相转换</p>
<p>final定义常量，static final定义一个类常量，const为Java保留的关键字，但目前没有使用</p>
<p>strictfp关键字标记的方法必须使用严格的浮点计算</p>
<p><strong>String类常用方法：</strong></p>
<pre><code>char charAt(int index);         //返回给定位置的代码单元，一般用于了解底层代码单元，较少使用

int codePointAt(int index);              //给定位置开始或结束的代码点

int offSetByCodePoints(int startIndex, int cpCount);         //返回从startIndex索引开始，位移cpCount后的代码点索引

int compareTo(String other);         //比较字符串大小，若字符串位于other之前返回负，字符串位于other之后返回正，如果字符串相等则为0

boolean endsWith(String suffix);         //是否以suffix结尾

boolean startsWith(String prefix);       //是否以prefix开头

boolean equals(Object other);        //判断是否相同

boolean equalsIgnoreCase(String other);          //忽略大小写判断是否相同

int indexOf(String str);            

int indexOf(String str, int fromIndex);

int indexOf(int cp);

int indexOf(int cp, int fromIndex);           //返回与字符串str或代码点cp匹配的第一个子串的开始位置

int lastIndexOf(String str);

int lastIndexOf(String str, int fromIndex);

int lastIndexOf(int cp);

int lastIndexOf(int cp, int fromIndex);            //返回与字符串str或代码点cp匹配的最后一个子串的开始位置

int length();         //返回字符串长度

int codePointCount(int startIndex, int endIndex);           //返回startIndex和endIndex-1之间的代码点数量

String replace(charSequence oldString, charSequence newString);          //用newString代替字符串中所有的oldString

String substring(int beginIndex);

String substring(int beginIndex, int endIndex);         //提取从beginIndex到串尾或endIndex-1的字符串

String toLowerCase();          //将所有大写转换为小写

String toUpperCase();         //小写转大写

String trim();             //返回删除了串头和串尾空格的新字符串
</code></pre><p><strong>StringBuilder常用方法：</strong></p>
<pre><code>int length();

StringBuilder append(String str);

StringBuilder append(char c);

StringBuilder appendCodePoint(int cp);

StringBuilder setCharAt(int i, char c);

StringBuilder insert(int offset, String str);

StringBuilder insert(int offset, char c);

StringBuilder delete(int startIndex, int endIndex);

String toString();
</code></pre><p>从控制台读取密码：</p>
<pre><code>Console cons = System.console();

String userName = cons.readLine(&quot;User name: &quot;);

char[] passwd = cons.readPassword(&quot;Password: &quot;);
</code></pre><p>日期与时间格式化:</p>
<p>%&lt;参数索引&gt;$&lt;标志&gt;&lt;宽度&gt;t&lt;转换字符&gt;</p>
<p>%&lt;参数索引&gt;$&lt;标志&gt;&lt;宽度&gt;.&lt;精度&gt;&lt;转换字符&gt;</p>
<p><strong>文件输入输出：</strong></p>
<pre><code>Scanner in = new Scanner(Paths.get(myfile.txt));        //用File对象构造一个scanner对象

PrintWriter = new PrintWriter(&quot;myfile.txt&quot;);            //构造PrintWriter对象写入文件

Scanner(File f);

Scanner(String data);

PrintWriter = new PrintWriter(String fileName);

static Path get(String pathName);
</code></pre><p>带标签的break语句，标签需放在希望跳出的最外层循环之前，并紧跟一个冒号</p>
<p><strong>大数值</strong></p>
<p>BigInteger和BigDecimal</p>
<p>BigInteger a = BigInteger.valueOf(100);</p>
<p>不能使用算术运算符，需要使用方法add和multiply、divide</p>
<p><strong>数组</strong></p>
<pre><code>int[] b = Arrays.copyOf(a, a.length);        //将数组a的内容拷贝到b中

Arrays.sort(a);         //对数组a中的元素采用快速排序法进行排序

Arrays.toString(a);             //将数组a转化为字符串如[1, 2, 3, ...]

Arrays.binarySearch(type[] a, type v);            //二分搜索法查找值v，查找成功则返回下标值，否则返回负数值r

Arrays.fill(type[] a, type v);           //将数组a中的所有元素设置为值v

Arrays.equals(type[] a, type[] b);             //判断两数组是否相等

Arrays.deepToString(a);           //将多维数组a转化为字符串
</code></pre><p><strong>第四章  对象与类—————————————————————————</strong></p>
<p><strong>常用预定义类</strong></p>
<p><strong>java.util.GregorianCalendar 1.1</strong></p>
<pre><code>GregorianCalendar()             //构造一个日历对象表示默认地区默认时区的当前时间

GregorianCalendar(int year, int month, int day)            //用指定时间构造一个日历对象

int get(int field)           //返回给定域的值

void set(int field, int value)           //设置指定域的值

void set(int year, int month, int day)              //设置新时间

void add(int field, int amount)          //对指定域进行计算

int getFirstDayOfWeek()             //获取当前用户所在地区星期的第一天

void setTime(Date time)             //将时间设置为指定点

Date getTime()            //获取当前时间
</code></pre><p><strong>java.text.DateFormatSymbols 1.1</strong></p>
<pre><code>String[] getShortWeekdays()

String[] getShortMonths()

String[] getWeekdays()

String[] getMonths()
</code></pre><p>需要可变数据域的拷贝，用clone()方法</p>
<p>一个方法可以访问所属类的所有对象的私有数据</p>
<p>Java的构造器可以通过this()调用同一个类的另一个构造器，而C++不能</p>
<p>Java可以直接初始化实例域的初值，或者调用方法对域直接初始化；而C++不能直接在声明中直接初始化，但可以用初始化列表语法</p>
<p>初始化块，静态初始化块</p>
<p><strong>java.util.Random 1.0</strong></p>
<pre><code>Random()           //构造一个新的随机数生成器

int nextInt(int n)             //返回一个1 ~ n-1之间的随机数
</code></pre><p>可以为任何一类添加finalize方法，finalize方法将在垃圾回收器清除对象之前调用</p>
<p>设置类路径</p>
<p>最好采用-classpath或-cp选项指定类路径，如</p>
<p>java -classpath /home/user/classdir:.:/home/user/achives/achive.jar MyProg</p>
<p>或</p>
<p>java -classpath c:\classdir;.;c:\achives\achive.jar MyProg</p>
<p>javac编译器总是在当前目录中查找文件，而Java虚拟机仅在类路径中有”.”目录时才查看当前目录，如果设置类路径忘记包含”.”，则程序能通过编译，却不能运行</p>
<p>javadoc工具可以由源文件生成一个html文档</p>
<p>注释以/<em>*开始，以</em>/结束</p>
<p>@author作者描述</p>
<p>@param变量描述</p>
<p>@return返回描述</p>
<p>@throws抛出异常描述</p>
<p>包与概述注释：单独的package.html或package-info.java和overview.html</p>
<p>注释抽取：</p>
<p>javadoc -d docDirectory packageName           //一个包</p>
<p>javadoc -d docDirectory packageName1 packageName2…              //多个包</p>
<p>javadoc -d docDirectory *.java                  //默认包</p>
<p><strong>第五章  继承—————————————————————————</strong></p>
<p>在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型</p>
<p>在覆盖一个方法时，子类方法不能低于超类方法的可见性</p>
<p><strong>final类和方法</strong></p>
<p>final类不允许扩展，即阻止继承，没有子类，final类中的方法自动成为final方法，即不能覆盖这个方法。也可以单独定义final方法</p>
<p>只能在继承层次内进行类型转换，在将超类转换成子类时应用instanceof进行检查</p>
<p>abstract抽象类和抽象方法，包含一个或多个抽象方法的类本身必须声明为抽象类，若子类没有定义全部的抽象方法，则子类也必须声明为抽象类</p>
<p>类即使不含抽象方法，也可以声明为抽象类，抽象类不能被实例化</p>
<p>protected对本包和所有子类可见，默认（不用修饰符）为对本包可见</p>
<p>子类中的方法只能访问子类对象中被protected的域，而不能访问其他超类对象中protected的域</p>
<p><strong>Object类</strong></p>
<p>equals方法</p>
<p>如果子类能够拥有自己的相等概念，则对称性需求强制采用getClass检测；如果由超类决定相等的概念，那么可以用instanceof进行检测。</p>
<p>对于数组类型的域，可以使用静态方法Array.equals()检测数组元素是否相等</p>
<p><strong>java.util.Arrays 1.2</strong></p>
<pre><code>static boolean equals(type[] a, type[] b)                   //如果两个数组的长度相同，而且对应位置上的元素也相同，则返回true，数组的元素类型可以是Object或其他基本类型
</code></pre><p><strong>java.util.Objects 7</strong></p>
<pre><code>static boolean equals(Object a, Object b)                   //如果都为null则返回true，如果只有其中之一为null，返回false，否则返回a.equals(b)        
</code></pre><p>hashCode()方法</p>
<p>如果重新定义equals()方法，就必须重新定义hashCode()方法，这两个定义必须一致</p>
<p><strong>java.lang.Object 1.0</strong></p>
<pre><code>int hashCode()               //返回对象的散列码，两个相等的对象要求返回相等的散列码
</code></pre><p><strong>java.lang.Objects 7.0</strong></p>
<pre><code>int hash(Object,...,Object)        //返回一个散列码，由提供的所有对象的散列码组合得到

static int hashCode(Object a)                 //如果a为null返回0，否则返回a.hashCode()
</code></pre><p><strong>java.util.Arrays 1.2</strong></p>
<pre><code>static int hashCode(type[] a)               //计算数组a的散列码

toString()方法

getClass().getName()          //获得类名的字符串
</code></pre><p>只要对象与一个字符串通过操作符“+”连接起来，Java编译就会自动调用toString()方法</p>
<pre><code>Arrays.toString(type[] a)          //打印数组

Arrays.deepToString(type[][] a)               //打印多维数组
</code></pre><p><strong>java.lang.Object 1.0</strong></p>
<pre><code>Class getClass()               //返回包含对象信息的类对象

boolean equals()             //比较两个对象是否相等，如果两个对象指向同一块区域为true

String toString()            //返回描述该对象值的字符串
</code></pre><p><strong>java.lang.Class 1.0</strong></p>
<pre><code>String getName()            //返回类名字

Class getSuperClass()                 //返回该类的超类信息
</code></pre><p><strong>泛型数组</strong></p>
<pre><code>ArrayList()             //构造一个空数组列表，T不允许为基本类型

.add()          //增加元素

.ensureCapacity(int n)              //确定分配n个元素的数组

.size()           //返回数组列表的当前元素数量

.trimToSize()               //确认数组大小不再变化时，调用该方法将存储空间大小调整为当前元素数目所需空间

.toArray(type[] a)           //转换为数组并存到a
</code></pre><p><strong>java.util.ArrayList 1.2</strong></p>
<pre><code>void set(int index, T obj)                //设置指定位置的元素值

T get(int index)             //返回指定位置的元素值

void add(int index, T obj)          //向后移动元素以便插入新元素值

T remove(int index)             //删除一个元素，并将后面的元素向前移动，返回所删除元素值
</code></pre><p>包装器，基本类型对应的类</p>
<p>自动装箱，自动拆箱</p>
<p><strong>java.lang.Integer 1.0</strong></p>
<pre><code>int intValue()       //以int形式返回Integer的值

static String toString(int i)           //以一个新String对象的形式返回给定数值i的十进制表示

static String toString(int i, int radix)             //返回数值i的给定radix参数进制的表示

static int parseInt(String s)             

static int parseInt(String s, int radix)         //返回字符串s表示的数值，给定字符串表示的是radix参数进制

static Integer valueOf(String s)            

static Integer valueOf(String s, int radix)
</code></pre><p><strong>java.text.NumberFormat 1.1</strong></p>
<pre><code>Number parse(String s)         //返回给定字符串s表示的数值
</code></pre><p><strong>参数数量可变的方法</strong></p>
<pre><code>method(Object... args)         //args为参数数组
</code></pre><p><strong>枚举类</strong></p>
<pre><code>public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE };

所有枚举类型都是Enum类的子类，可以在枚举类中添加构造器、方法和域，构造器只是在构造枚举常量时被调用

Size.SMALL.toString();        //将返回字符串SMALL

Size s = Enum.valueOf(Size.class, &quot;SMALL&quot;);            //toString()的逆方法，返回Size.SMALL

Size[] values = Size.values();             //返回包含全部枚举值的数组

Size.SMALL.ordinal();          //将返回枚举常量的位置，这里返回0

Size.SMALL.compareTo(Size MEDIUM)            //如果SMALL出现在枚举常量MEDIUM前，则返回一个负值，相等返回0，否则返回正值
</code></pre><p><strong>反射</strong></p>
<p>Class类</p>
<p><strong>java.lang.Class 1.0</strong></p>
<pre><code>e.getClass()           //返回Class类的实例

e.getClass().getName()          //返回类的名字

e.getClass().newInstance()          //快速创建一个类的实例，使用默认构造器

Class.forName(className)          //返回类名对应的Class对象，手工加载类

E.class            //返回类型E对应的Class类的实例
</code></pre><p><strong>java.lang.reflect.Constructor 1.1</strong></p>
<pre><code>Object newInstance(Object[] args)                //构造一个这个构造器所属类的新实例
</code></pre><p><strong>java.lang.Throwable 1.0</strong></p>
<pre><code>void printStackTrace()         //打印栈的轨迹输出到标准错误流
</code></pre><p><strong>java.lang.Class 1.0</strong></p>
<pre><code>Field[] getFields()

Field[] getDeclaredFields()         //返回一个包含Field对象的数组，记录了这个类和其超类的公有域

Method[] getMethods()

Method getMethod(String name, Class... parameterTypes)            //根据方法签名返回特定方法

Method[] getDeclaredMethods()            //返回一个包含Method对象的数组，getMethods()将返回所有公有方法，包括从超类继承的公有方法；getDeclaredMethods()返回这个类或接口的全部方法，不包括由超类继承的方法

Constructor[] getConstructors()

Constructor[] getDeclaredConstructors()          //返回包含Constructor对象的数组
</code></pre><p><strong>java.lang.reflect.Field</strong></p>
<p><strong>java.lang.reflect.Method</strong></p>
<p><strong>java.lang.reflect.Constructor</strong></p>
<pre><code>Class getDeclaringClass()          

Class[] getExceptionTypes()

int getModifiers()

String getName()

Class[] getParameterTypes()

Class getReturnType()
</code></pre><p><strong>java.lang.reflect.Modifier</strong></p>
<pre><code>static String toString(int modifiers)

static boolean isAbstract(int modifiers)

static boolean isFinal(int modifiers)

static boolean isPublic(int modifiers)         //检测对应修饰符在modifiers中的位

...

Class cl = harry.getClass();

Field f = cl.getDeclaredField(&quot;name&quot;);

Object v = f.get(harry)               //返回一个对象，其值为harry对象相应的该域的值

f.setAccessible(true);       //setAccessible()方法是AccessibleObject类中的一个方法，是Field，Method，Constructor的公共超类

AccessibleObject.setAccessible(fields, true)          //设置fields域可访问

f.set(obj, value)          //将obj对象的f域设置为新值
</code></pre><p><strong>java.lang.reflect.Array</strong></p>
<pre><code>static Object get(Object array, int index)

static xxx getXxx(Object array, int index)         //xxx是基本类型的一种

static void set(Object array, int index, Object newValue)

static void setXxx(Object array, int index, xxx newValue)         //xxx是基本类型的一种

static int getLength(Object array)

static Object newInstance(Class componentType, int length)

static Object newInstance(Class componentType, int[] lengths)          //返回一个具有给定类型给定维数的新数组
</code></pre><p><strong>调用任意方法</strong></p>
<p>建议仅仅在必要的时候才使用Method对象，最好使用接口和内部类</p>
<p><strong>java.lang.reflect.Method 1.1</strong></p>
<pre><code>public Object invoke(Object implicitParameter, Object[] explicitParameters)               //调用这个对象所描述的方法，传递给定参数，返回方法的返回值
</code></pre><p><strong>第6章–接口与内部类————————————————————————————————</strong></p>
<p><strong>接口</strong></p>
<p>接口中的方法自动地属于public，因此不必提供关键字public</p>
<p><strong>java.lang.Comparable 1.0</strong></p>
<pre><code>int compareTo(T other)                    //用这个对象和other进行比较，如果这个对象小于other返回负数，相等为0，否则返回正值
</code></pre><p><strong>java.util.Arrays 1.2</strong></p>
<pre><code>static void sort(Object[] a)           //使用mergesort算法对数组a中的元素进行排序，要求数组中的元素必须实现了Comparable接口的类，并且元素之间可比较
</code></pre><p><strong>java.lang.Integer 7</strong></p>
<pre><code>static int compare(int x, int y)              //如果x

接口中不能包含实例域或静态方法，可以包含常量，常量自动为public static final

Cloneable接口是标记接口，没有方法
</code></pre><p><strong>javax.swing.JOptionPane 1.2</strong></p>
<pre><code>static void showMessageDialog(Component parent, Object message)             //显示包含一条信息和OK按钮的对话框，这个对话框将位于其parent组件的中央，若parent组件为null，则位于屏幕中央
</code></pre><p><strong>javax.swing.Timer 1.2</strong></p>
<pre><code>Timer(int interval, ActionListener listener)                 //构造一个定时器，每隔interval毫秒就通告listener一次

void start()

void stop()
</code></pre><p><strong>java.awt.Toolkit 1.0</strong></p>
<pre><code>static Toolkit getDefaultToolkit()          //获得默认的工具箱，包含GUI环境的信息

void beep()           //发出一声铃响
</code></pre><p><strong>内部类</strong></p>
<p>内部类既可以访问自身数据域，也可以访问外围类对象的数据域</p>
<p>内部类的对象总有一个对外围类对象的隐式引用，称为outer</p>
<p>内部类可以私有，常规类只有包可见性和公有可见性</p>
<p>内部类语法规则</p>
<pre><code>OuterClass.this          //外围类引用的正规语法

OuterClass.InnerClass innerObject = outerObject.new InnerClass(construction parameters)           //构造内部类对象，在外围类的作用域之外引用公有内部类
</code></pre><p>局部内部类</p>
<p>局部类不能用public或private修饰符进行声明，它的作用域限定在声明这个局部类的块中</p>
<p>局部类不仅能够访问包含他们的外部类，还能访问声明为final的局部变量</p>
<p>final关键字可以应用于局部变量、实例变量和静态变量。创建变量之后只能赋值一次</p>
<p>匿名内部类</p>
<p>语法格式：</p>
<pre><code>new SuperType(construction parameters)

{

    inner class methods and datas

}
</code></pre><p>或</p>
<pre><code>new InterfaceType()

{

    methods and datas

}
</code></pre><p>利用内部类语法进行“双括号初始化”：</p>
<p>如</p>
<pre><code>method(new ArrayList() {{ add("Harry"); add("Tony"); }})            //外层括号建立了ArrayList的一个匿名子类，内层括号是一个对象构造块
</code></pre><p>静态内部类</p>
<p>在内部类不需要访问外围类对象的时候，应该使用静态内部类，而且只有内部类可以声明为static，静态方法中必须使用静态内部类</p>
<p>声明在接口中的内部类自动成为static和public类</p>
<p><strong>代理类</strong></p>
<p>所有的代理类都扩展于Proxy类，一个代理类只有一个实例域：调用处理器，即实现了InvocationHandler接口的类对象。</p>
<p>代理类是在程序运行过程中创建的</p>
<p><strong>java.lang.reflect.InvocationHandler 1.3</strong></p>
<pre><code>Object invoke(Object proxy, Method method, Object[] args)         //定义代理对象调用方法时希望执行的动作
</code></pre><p><strong>java.lang.reflect.Proxy 1.3</strong></p>
<pre><code>static getProxyClass(ClassLoader loader, Class[] interfaces)              //返回实现指定接口的代理类

static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler handler)            //构造一个实现指定接口的代理类的实例，所有方法都将调用给定代理处理器对象的invoke()方法

static boolean isProxyClass(Class c)           //如果是一个代理类则返回true
</code></pre><p><strong>第10章–部署应用程序和applet————————————————————————————————</strong></p>
<p><strong>JAR文件</strong></p>
<p>JAR文件打包命令：</p>
<p>jar cvf JARFileName File1 File2 …</p>
<p>添加清单文件到JAR文件中：</p>
<p>jar cfm JARFileName ManifestFileName …</p>
<p>更新清单文件：</p>
<p>jar ufm JARFileName ManifestFileName</p>
<p>使用e选项指定程序的入口点</p>
<p>jar cvfe MyProgram.jar com.company.mypkg.MainAppClass filesToAdd</p>
<p>启动jar应用程序</p>
<p>java -jar MyProgram.jar</p>
<p>在windows平台中，双击jar文件，通过javaw -jar命令相关联来启动文件，与java命令不同，javaw不打开shell窗口</p>
<p><strong>java.lang.Class 1.0</strong></p>
<pre><code>URL getResource(String name)

InputStream getResourceAsStream(String name)             //找到与类位于同一位置的资源，返回一个可以加载资源的URL或输入流。如果没有则返回NULL
</code></pre><p>密封包：</p>
<p>在清单指令中加入：</p>
<p>Name: com/company/mypkg/</p>
<p>Sealed: true</p>
<p><strong>第11章–异常、断言、日志和调试————————————————————————————————</strong></p>
<p><strong>异常</strong></p>
<p>Java异常层次结构</p>
<p>{ Throwable { Error, Exception { IOException, RuntimeException } } }</p>
<p>未检查异常（unchecked），派生于Error, RuntimeException的所有异常</p>
<p>已检查异常（checked），所有其他异常</p>
<p>一个方法必须声明所有可能抛出的已检查异常，而未检查异常要么不可控制，要么就应该避免发生</p>
<p><strong>java.lang.Throwable 1.0</strong></p>
<pre><code>Throwable()            //默认Throwable构造器

Throwable(String message)             //构造一个新的Throwable对象，带有特定的详细描述信息

Throwable(String message, Throwable cause)             //用给定的原因构造一个Throwable对象

String getMessage()          //获得Throwable对象的详细描述信息
</code></pre><p>如果编写一个覆盖超类的方法，而这个方法又没有抛出异常，那么这个方法就必须捕获方法代码中的每一个已检查异常，不允许在子类的throws说明符中出现超过超类方法所列出的异常类范围</p>
<p>捕获多个异常</p>
<p>catch(FileNotFoundException | UnknownHostException e) {…}</p>
<p>捕获多个异常时，异常变量隐含为final变量</p>
<p>使用包装技术，抛出子系统中的高级异常，而不丢失原始异常信息</p>
<pre><code>Throwable se = new ServletException(&quot;database error&quot;);

se.initCause(e);                                //将原始异常设置为新异常的原因

throw se;

Throwable e = se.getCause();

带资源的try()语句

try (Resource res = ...)

{

...

}
</code></pre><p>try块退出时，会自动调用res.close()，当close()抛出异常时，原来的异常会被重新抛出，close()的异常被抑制，并通过addSuppressed()方法被增加到原来的异常中，通过getSuppressed()获取</p>
<p>分析堆栈跟踪（StackTrace）元素</p>
<pre><code>StackTraceElement[] frames = e.getStackTrace();                //得到StackTraceElement对象的数组

Thread.getStackTrace()           //产生所有线程的堆栈跟踪
</code></pre><p><strong>java.lang.StackTraceElement 1.4</strong></p>
<pre><code>String getFileName()             //返回这个元素运行时的源文件名，不存在则返回null

int getLineNumber()            //返回这个元素运行时的源文件行数，不存在则返回-1

String getClassName()              //返回这个元素运行时对应的类的全名

String getMethodName()                 //返回这个元素运行时对应的方法名

boolean isNativeMethod()             //如果这个元素运行时在一个本地方法中，返回true

String toString()            //如果存在的话，返回一个包含类名、方法名、文件名、行数的格式化字符串
</code></pre><p><strong>断言</strong></p>
<p>断言只应该用于在测试阶段确定程序内部的错误位置，当代码发布时，这些插入的检测语句会被自动移走</p>
<p>assert 条件；</p>
<p>assert 条件 : 表达式；            //若为false则抛出AssertionError异常</p>
<p>启用和禁用断言</p>
<p>在运行程序时用-enableassertions或-ea启用</p>
<p>java -enableassertions MyApp</p>
<p>java -ea:MyClass -ea:com.mycompany.mypkg… MyApp</p>
<p>用选项-disableassertions或-da禁用特定类和包的断言</p>
<p>对于系统类，需要使用-enablesystemassertions和-esa开关启用断言</p>
<p><strong>java.lang.ClassLoader 1.0</strong></p>
<pre><code>void setDefaultAssertionStatus(boolean status)              //对于通过类加载器加载的所有类来说，如果没有显式的说明类或包的断言状态，则开启或禁用断言

void.setClassAssertionStatus(String className, boolean status)           //对于给定的类和内部类，启用或关闭断言

void setPackageAssertionStatus(String packageName, boolean status)          //对于给定包和其子包中的类，启用或关闭断言

void clearAssertionStatus()         //移除所有包和类的显式断言状态设置，并禁用所有通过这个类加载器加载的所有类的断言
</code></pre><p><strong>日志</strong></p>
<p>基本日志</p>
<p>默认日志记录器 Logger.global</p>
<p>Logger.getGlobal().info(“…”);</p>
<p>7个日志记录器级别：</p>
<p>SEVERE，WARNING，INFO，CONFIG，FINE，FINER，FINEST，默认只记录前三个级别</p>
<p>logger.setLevel(Level.FINE)              //FINE和更高级别都可以记录</p>
<p>Level.ALL, Level.OFF 可以开启和关闭所有级别的记录</p>
<p>修改日志管理器配置</p>
<p>默认配置文件存在于：e/lib/logging.properties</p>
<p>若要使用另一个配置文件，要将java.util.logging.config.file设置为配置文件的存储位置，并用命令启动</p>
<p>java -Djava.util.logging.config.file=configFile MainClass</p>
<p>修改默认的日志记录级别：</p>
<p>.level=INFO</p>
<p>指定自己的日志记录级别：</p>
<p>com.mycompany.myapp.level=FINE</p>
<p>要将相应日志记录发送到控制台上：</p>
<p>java.util.logging.ConsoleHandler.level=FINE</p>
<p>处理器</p>
<p>绕过默认配置的父处理器，安装自己的处理器：</p>
<pre><code>Logger logger = Logger.getLogger(&quot;com.mycompany.myapp&quot;);

logger.setLevel(Level.FINE);

logger.setUseParentHandlers(false);

Handler handler = new ConsoleHandler();

handler.setLevel(Level.FINE);

logger.addHandler(handler);
</code></pre><p>日志API提供了两个处理器类型：FileHandler和SocketHandler</p>
<pre><code>logger.setFilter(filter)           //安装一个过滤器到日志中

logger.setFormatter(formatter)        //安装一个格式化器到日志中
</code></pre><p><strong>java.util.logging.Logger 1.4</strong></p>
<pre><code>Logger getLogger(String loggerName)

Logger getLogger(String loggerName, String bundleName)       //获得给定名字的日志记录器，loggerName：具有层次结构的日志记录器名，bundleName：用来查看本地消息的资源名

void severe(String message)

void warning(String message)

void info(String message)

void config(String message)

void fine(String message)

void finer(String message)

void finest(String message)         //记录一个由方法名和给定消息指示级别的日志记录

void entering(String className, String methodName)

void entering(String className, String methodName, Object param)

void entering(String className, String methodName, Object[] param)

void exiting(String className, String methodName)

void exiting(String className, String methodName, Object result)         //记录一个描述进入/退出方法的日志记录，其中应该包含给定参数或返回值

void throwing(String className, String methodName, Throwable t)         //记录一个描述抛出给定异常对象的日志记录

void log(Level level, String message)

void log(Level level, String message, Object obj)

void log(Level level, String message, Object objs)

void log(Level level, String message, Throwable t)          //记录一个给定级别和消息的日志记录，其中可以包括给定对象或者可抛出对象。要想包括对象，消息中必须包含格式化占位符，如{0}，{1}

void logp(Level level, String className, String methodName, String message)

void logp(Level level, String className, String methodName, String message, Object obj)

void logp(Level level, String className, String methodName, String message, Object objs)

void logp(Level level, String className, String methodName, String message, Throwable t)              //记录一个给定级别、准确的调用者信息和消息的日志记录，其中可以包括对象或可抛出对象

void logrb(Level level, String className, String methodName, String bundleName, String message)

void logrb(Level level, String className, String methodName, String bundleName, String message, Object obj)

void logrb(Level level, String className, String methodName, String bundleName, String message, Object objs)

void logrb(Level level, String className, String methodName, String bundleName, String message, Throwable t)   //记录一个给定级别、调用者信息、资源包名和消息的日志记录，其中可以包括对象

Level getLevel()

void setLevel(Level l)         //获得和设置这个日志记录器的级别

Logger getParent()

void setParent(Logger l)      //获得和设置这个日志记录器的父日志记录器

Handler[] getHandlers()           //获得这个日志记录器的所有处理器

void addHandler(Handler h)

void removeHandler(Handler h)            //增加或删除这个日志记录器中的一个处理器

boolean getUseParentHandlers()

void setUseParentHandlers(boolean b)             //获得和设置“use parent handler”属性，如果为true，则日志记录器会将全部的日志记录转发给它的父处理器

Filter getFilter()

void setFilter(Filter f)            //获得和设置这个日志记录器的过滤器
</code></pre><p><strong>java.util.logging.Handler 1.4</strong></p>
<pre><code>abstract void publish(LogRecord record)           //将日志记录发送到希望的目的地

abstract void flush()          //刷新所有已缓冲的数据

abstract void close()           //刷新所有已缓冲的数据，并释放所有相关资源

Filter getFilter()

void setFilter(Filter f)            //获得和设置这个处理器的过滤器

Formatter getFormatter()

void setFormatter(Formatter f)           //获得和设置这个处理器的格式化器

Level getLevel()

void setLevel(Level l)           //获得和设置这个处理器的级别
</code></pre><p><strong>java.util.logging.ConsoleHandler 1.4</strong></p>
<pre><code>ConsoleHandler()            //构造一个新的控制台处理器
</code></pre><p><strong>java.util.logging.FileHandler 1.4</strong></p>
<pre><code>FileHandler(String pattern)

FileHandler(String pattern, boolean append)

FileHandler(String pattern, int limit, int count)

FileHandler(String pattern, int limit, int count, boolean append)             //构造一个文件处理器，pattern：构造日志文件名的模式，limit：在打开一个新日志文件前，日志文件可以包含的近似最大字节数，count：循环序列的文件数量，append：追加模式
</code></pre><p><strong>java.util.logging.LogRecord 1.4</strong></p>
<pre><code>Level getLevel()             //获得这个日志记录的记录级别

String getLoggerName()              //获得正在记录这个日志记录的日志记录器的名字

ResourseBundle getresourceBundle()

String getresourceBundleName()            //获得用于本地化消息的资源包或资源包的名字，没有则返回null

String getMessage()              //获得本地化和格式化之前的原始消息

Object[] getParameters()              //获得参数对象，没有则返回null

Throwable getThrown()          //获得被抛出的对象

String getSourceClassName()

String getSourceMethodName()              //获得记录这个日志记录的代码区域

long getMillis()                //获得创建时间，以毫秒为单位，从1970年开始

long getSequenceNumber()              //获得这个日志记录的唯一序列序号

int getThreadID()          //获得创建这个日志记录的线程的唯一ID
</code></pre><p><strong>java.util.logging.Filter 1.4</strong></p>
<pre><code>boolean isLoggable(LogRecord record)             //如果给定日志记录需要记录，则返回true
</code></pre><p><strong>java.util.logging.Formatter 1.4</strong></p>
<pre><code>abstract String format(LogRecord record)              //返回对日志记录格式化后得到的字符串

String getHead(Handler h)

String getTail(Handler h)                   //返回应该出现在包含日志记录的文档的开头和结尾的字符串

String formatMessage(LogRecord record)            //返回经过本地化和格式化后的日志记录的消息内容
</code></pre><p><strong>第12章–泛型程序设计————————————————————————————————</strong></p>
<p>不能用基本类型实例化类型参数，只能使用继承了Object的类</p>
<p>定义泛型类：</p>
<pre><code>public class Pair {

    ...

}
</code></pre><p>定义泛型方法：</p>
<pre><code>class ArrayAlg {

    public static  T getMiddle(T... a) {

        ...

    }

}
</code></pre><p>类型变量放在修饰符的后面，返回类型的前面</p>
<p>调用一个泛型方法时，在方法名前的尖括号中放入具体的类型</p>
<pre><code>String middle = ArrayAlg.getMiddle(&quot;John&quot;, &quot;Q&quot;);
</code></pre><p>类型变量的限制</p>
<pre><code>public static  T min(T[] a) ...
</code></pre><p>限定类型用&amp;分割，变量类型用逗号分割。类必须是限定列表的第一个</p>
<p>Java泛型转换的事实：</p>
<p>虚拟机中没有泛型，只有普通的类和方法</p>
<p>所有的类型参数都用它们的限定类型来替换</p>
<p>桥方法被合成用来保持多态</p>
<p>为保持类型安全性，必要时插入强制类型转换</p>
<p>运行时查询只适用于原始类型，如instanceof, getClass()</p>
<p>不能创建参数化类型的数组，但声明是合法的，只是不能创建，可以声明通配类型的数组，然后进行类型转换。如果需要收集参数化类型，只有一种安全有效的方法：使用ArrayList。</p>
<p>如Pair [] table = new Pair[10];        //ERROR</p>
<p>两种方法抑制Varargs警告：增加标注@SuppressWarnings(“unchecked”)或@SafeVarargs。</p>
<pre><code>@SafeVarargs

public static  void addAll(Collection coll, T... ts)
</code></pre><p>但是可能会在别处产生错误</p>
<p>不能实例化类型变量，不能 new T(…)</p>
<p>可以通过反射调用Class.newInstance方法构造泛型对象，但是T.class不合法，需要设计API来支配Class对象：</p>
<pre><code>public static  Pair makePair(Class cl)

{

    try { return new Pair&lt;&gt;(cl.newInstance(), cl.newInstance()) }

    catch (Exception ex) { return null; }

}
</code></pre><p>不能在静态域或方法中引用类型变量</p>
<p>不能抛出或捕获泛型类的实例</p>
<p>泛型类可以扩展或实现其他的泛型类</p>
<p>通配符类型</p>
<p>Pair, Pair是其子类型</p>
<p>超类型限定</p>
<p>？ super Manager</p>
<p>带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取</p>
<p><strong>java.lang.Class</strong></p>
<pre><code>T newInstance()              //返回默认构造器构造的一个新实例

T cast(Object obj)              //如果obj为null或有可能转换成类型T，则返回obj；否则抛出BadCastException异常

T[] getEnumConstants()                    //如果T是枚举类型，则返回所有值组成的数组，否则返回null

Class getSuperclass()                       //返回这个类的超类，如果T不是一个类或Object类，返回null

Constructor getConstructor(Class... parameterTypes)

Constructor getDeclaredConstructor(Class... parameterTypes)                       //获取公有的构造器，或带有给定参数类型的构造器
</code></pre><p><strong>java.lang.reflect.Constructor</strong></p>
<pre><code>T newInstance(Object... parameters)                  //返回用指定参数构造的新实例
</code></pre><p><strong>java.lang.Class</strong></p>
<pre><code>TypeVariable[] getTypeParameters()           //如果这个类型被声明为泛型类型，则返回泛型类型变量，否则获得一个长度为0的数组

Type getGenericSuperclass()                 //获得被声明为这一类型的超类的泛型类型

Type[] getGenericInterfaces()                    //获得类型的接口的泛型类型
</code></pre><p><strong>java.lang.reflect.Method</strong></p>
<pre><code>TypeVariable[] getTypeParameters()               //获得泛型类型变量

Type getGenericReturnType()                       //获得方法的泛型返回类型

Type[] getGenericParameterTypes()                //获得方法的泛型参数类型
</code></pre><p><strong>java.lang.reflect.TypeVariable</strong></p>
<pre><code>String getName()               //获得类型变量的名字

type[] getBounds()                //获得类型变量的子类限定
</code></pre><p><strong>java.lang.reflect.WildcardType</strong></p>
<pre><code>Type[] getUpperBounds()                    //获得这个类型变量的子类（extends）限定

Type[] getLowerBounds()                   //获得这个类型变量的超类（super）限定
</code></pre><p><strong>java.lang.reflect.ParameterizedType</strong></p>
<pre><code>Type getRawType()                  //获得这个参数化类型的原始类型

Type[] getActualTypeArguments()                     //获得这个参数化类型声明时所使用的类型参数

Type getOwnerType()                     //如果是内部类型，返回外部类型，如果是顶级类型，返回null
</code></pre><p><strong>java.lang.reflect.GenericArrayType</strong></p>
<pre><code>Type getGenericComponentType()                         //获得声明该数组类型的泛型组合类型
</code></pre><p><strong>第13章–集合————————————————————————————————</strong></p>
<p>集合接口</p>
<p>Java类库中，集合类的基本接口是Collection接口，Collection接口扩展了Iterable接口，对于标准库中任何集合都可以使用for each循环</p>
<p><strong>java.util.Collection 1.2</strong></p>
<pre><code>Iterator iterator()                      //返回一个用于访问集合中每一个元素的迭代器

int size()                      //返回当前存储在集合中的元素的个数

boolean isEmpty()                 //如果集合中没有元素，返回true

boolean contains(Object obj)                            //如果集合中包含了一个与obj相等的对象，返回true

boolean containsAll(Collection other)                     //如果集合中包含了other集合中的所有元素，返回true

boolean add(Object element)                      //添加一个元素

boolean addAll(Collection other)                //添加other集合中的所有元素

boolean remove(Object obj)                    //删除与obj相等的元素

boolean removeAll(Collection other)                  //删除other集合中的所有元素相等的元素

void clear()                      //从集合中删除所有元素

boolean retainAll(Collection other)                         //删除与other集合中元素不同的元素

Object[] toArray()                       //返回这个集合的对象数组

 T[] toArray(T[] arrayToFill)                                //返回这个集合的对象数组，如果arrayToFill足够大则放入arrayToFill，否则新建一个数组存放
</code></pre><p><strong>java.util.Iterator 1.2</strong></p>
<pre><code>boolean hasNext()                     //是否存在可访问的元素

E next()                    //返回将要访问的下一个对象，如果达到尾部则抛出NoSuchElement异常

void remove()                       //删除上一次访问的对象，必须紧跟在一个next()之后
</code></pre><p><strong>Java库中的具体集合</strong></p>
<p>| ArrayList | 一种可以动态增长和缩减的索引序列 |<br>| LinkedList | 一种可以在任何位置进行高效的插入和删除操作的有序序列 |<br>| ArrayDeque | 一种用循环数组实现的双端队列 |<br>| HashSet | 一种没有重复元素的无序集合 |<br>| TreeSet | 一种有序集 |<br>| EnumSet | 一种包含枚举类型值的集 |<br>| LinkedHashSet | 一种可以记住元素插入次序的集 |<br>| PriorityQueue | 一种允许高效删除最小元素的集合 |<br>| HashMap | 一种存储键值关联的数据结构 |<br>| TreeMap | 一种键值有序排列的映射表 |<br>| EnumMap | 一种键值属于枚举类型的映射表 |<br>| LinkedHashMap | 一种可以记住键值项添加次序的映射表 |<br>| WeakHashMap | 一种其值无用武之地后可以被垃圾回收器回收的映射表 |<br>| IdentityHashMap | 一种用==而不是equals比较键值的映射表 |</p>
<p><strong>链表</strong></p>
<p>Iterator接口中没有add方法，子接口ListIterator中包含add方法，可以用迭代器在特定位置添加元素</p>
<p>如果迭代器发现它的集合被另一个迭代器修改了，或是被集合自身的方法修改了，就会抛出一个ConcurrentMofificationException异常</p>
<p><strong>java.util.List 1.2</strong></p>
<pre><code>ListIterator listIterator()                      //返回一个列表迭代器

ListIterator listIterator(int index)                    //返回一个指定位置的列表迭代器

void add(int i, E element)                      //在给定位置添加一个元素

void addAll(int i, Collection elements)                            //将集合中的所有元素添加到指定位置

E remove(int i)                   //删除指定位置的元素并返回这个元素

E get(int i)                         //获取指定位置的元素

E set(int i, E element)                           //用新元素取代指定位置的元素，并返回旧元素

int indexOf(Object element)                      //返回与指定元素相等的元素第一次出现的位置，没有则返回-1

int lastIndexOf(Object element)                          //返回与指定元素相等的元素最后一次出现的位置
</code></pre><p><strong>java.util.ListIterator 1.2</strong></p>
<pre><code>void add(E element)                        //在当前位置前添加一个新元素

void set(E element)                          //用新元素取代next或previous上次访问的元素，如果在next或previous上次调用之后列表结构被修改了，抛出IllegalStateException异常

boolean hasPrevious()                      //当反向迭代列表时，若还有可访问的元素，返回true

E previous()                               //返回前一个对象

int nextIndex()                           //返回下一次调用next方法时访问的元素索引

int previousIndex()                             //返回下一次调用previous方法时访问的元素索引
</code></pre><p><strong>java.util.LinkedList 1.2</strong></p>
<pre><code>LinkedList()                              //构造一个空链表

LinkedList(Collection elements)                                  //构造一个链表，将集合中的所有元素添加进去

void addFirst(E element)

void addLast(E element)                      //将某个元素添加到列表的头部或尾部

E getFirst()

E getLast()                             //返回列表头部或尾部的元素

E removeFirst()

E removeLast()                            //删除并返回列表头部或尾部的元素
</code></pre><p><strong>数组列表</strong></p>
<p>在不需要同步（一个线程访问）时使用ArrayList，需要同步（多个线程访问）时使用Vector</p>
<p><strong>散列集</strong></p>
<p>散列表（hash table)</p>
<p>散列码（hash code)</p>
<p>桶（bucket）</p>
<p>散列冲突（hash collision)</p>
<p>再散列（rehashed)</p>
<p>装填因子（load factor)</p>
<p>通常，将桶数设置为预计元素数目的75%-150%，装填因子默认为0.75</p>
<p><strong>java.util.HashSet 1.2</strong></p>
<pre><code>HashSet()              //构造一个空的散列集

HashSet(Collection elements)                    //构造一个散列表，并将集合中所有的元素添加进去

HashSet(int initialCapacity)                       //构造一个空的具有指定容量的散列集

HashSet(int initialCapacity, float loadFactor)                         //构造一个具有指定容量和装载因子的空散列集
</code></pre><p><strong>java.lang.Object 1.0</strong></p>
<pre><code>int hashCode()                  //返回这个对象的散列码，必须和equals()一致
</code></pre><p><strong>java.util.TreeSet 1.2</strong></p>
<pre><code>TreeSet()                 //构造一个空树集

TreeSet(Collection elements)                        //构造一个空树集，并将集合中的元素添加进去
</code></pre><p><strong>对象的比较</strong></p>
<p><strong>java.lang.Comparable 1.2</strong></p>
<pre><code>int compareTo(T other)                  //将这个对象与另一个对象other比较
</code></pre><p><strong>java.util.Comparator 1.2</strong></p>
<pre><code>int compare(T a, T b)                     //将a与b比较
</code></pre><p><strong>java.util.SortedSet 1.2</strong></p>
<pre><code>Comparator comparator()                       //返回用于对元素进行排序的比较器，如果元素用Comparable接口的compareTo方法则返回null

E first()                //返回最小元素

E last()                  //返回最大元素
</code></pre><p><strong>java.util.NavigableSet 6</strong></p>
<pre><code>E higher(E value)

E lower(E value)                //返回大于value的最小元素，或小于value的最大元素，没有则返回null

E ceiling(E value)

E floor(E value)                     //返回大于等于value的最小元素，或小于等于value的最大元素，没有则返回null

E pollFirst()

E pollLast()                    //删除并返回这个集中的最大元素或最小元素

Iterator descendingIterator()                              //返回一个按递减顺序遍历集中元素的迭代器
</code></pre><p><strong>java.util.TreeSet 1.2</strong></p>
<pre><code>TreeSet()                  //构造一个空树集

TreeSet(Comparator c)                        //构造一个指定比较器的树集

TreeSet(SortedSet elements)                     //构造一个空树集，并将集中元素添加进去，并使用与给定集相同的比较器
</code></pre><p><strong>队列与双端队列</strong></p>
<p><strong>java.util.Queue 5.0</strong></p>
<pre><code>boolean add(E element)

boolean offer(E element)                 //添加元素到队列尾部，若队列已满则第一个方法抛出IllegalStateException，第二个方法返回false

E remove()

E poll()                      //删除并返回队列头部的元素，若队列为空，则第一个方法抛出NoSuchElementException，第二个方法返回null

E element()

E peek()                //返回但不删除队列头部的元素，若为空，第一个方法抛出NoSuchElementException，第二个方法返回null
</code></pre><p><strong>java.util.Deque 6.0</strong></p>
<pre><code>void addFirst(E element)

void addLast(E element)

boolean offerFirst(E element)

boolean offerLast(E element)              //将给定对象添加到队列的头部或尾部，若队列已满，前两个方法抛出异常，后两个方法返回null

E removeFirst()

E removeLast()

E pollFirst()

E pollLast()                              //删除并返回队列头部的元素，若队列为空，前两个方法抛出异常，后两个方法返回null

E getFirst()

E getLast()

E peekFirst()

E peekLast()                         //返回但不删除队列头部的元素，若为空，前两个方法抛出NoSuchElementException，后两个方法返回null
</code></pre><p><strong>java.util.ArrayDeque 6</strong></p>
<pre><code>ArrayDeque()                    

ArrayDeque(int initialCapacity)                        //用初始容量构造一个无限双端队列
</code></pre><p><strong>优先级队列</strong></p>
<p>优先级队列PriorityQueue使用堆结构</p>
<p><strong>java.util.PriorityQueue 5.0</strong></p>
<pre><code>PriorityQueue()

PriorityQueue(int initialCapacity)

PriorityQueue(int initialCapacity, Comparator c)
</code></pre><p><strong>映射表</strong></p>
<p><strong>java.util.Map 1.2</strong></p>
<pre><code>V get(Object key)                     //返回与键对应的值，键可以为null

V put(K key, V value)                      //将键与对应的值关系插入到映射表中

void putAll(Map entries)                         //将给定映射表中的所有条目添加到这个映射表中

boolean containsKey(Object key)                 //映射表中是否有这个键

boolean containsValue(Object value)                   //映射表中是否有这个值

Set&gt; entrySet()                         //返回Map.Entry对象的集视图，即键值对，可以从这个集中删除元素，同时也在映射表中删除该元素，但是不能添加元素

Set keySet()                       //返回所有键的集视图，可以从这个集中删除元素，同时也在映射表中删除该元素，但是不能添加元素

Collection values()                        //返回所有值的集视图，可以从这个集中删除元素，同时也在映射表中删除该元素，但是不能添加元素
</code></pre><p><strong>java.util.Map.Entry 1.2</strong></p>
<pre><code>K getKey()

V getValue()              //获得这个条目的键或值

V setValue(V newValue)                    //设置在映射表中与值对应的新值，并返回旧值
</code></pre><p><strong>java.util.HashMap 1.2</strong></p>
<pre><code>HashMap()

HashMap(int initCapacity)

HashMap(int initCapacity, float loadFactor)
</code></pre><p><strong>java.util.TreeMap 1.2</strong></p>
<pre><code>TreeMap(Comparator c)

TreeMap(Map entries)

TreeMap(SortedMap? extends K, ? extends V&gt; entries)
</code></pre><p><strong>java.util.SortedMap 1.2</strong></p>
<pre><code>Comparator comparator()              //返回对键进行排序的比较器

K firstKey()                 

K lastKey()               //返回映射表中的最小元素和最大元素
</code></pre><p><strong>集合框架</strong></p>
<p>视图与包装器</p>
<p>映射表类的keySet方法返回一个实现Set接口的类对象，这个类的方法对原映射表进行操作，这种集合称为视图</p>
<p>轻量级集包装器</p>
<p>子范围</p>
<p>不可修改视图</p>
<p>同步视图，Collections的syncronized方法</p>
<p>检查视图，Collections的checkedList方法</p>
<p><strong>java.util.Collections</strong></p>
<pre><code>static  Collection unmodifiableCollection(Collection c)

static  List unmodifiableList(List c)

static  Set unmodifiableSet(Set c)

static  SortedSet unmodifiableSortedSet(SortedSet c)

static  Map unmodifiableMap(Map c)

static  SortedMap unmodifiableSortedMap(SortedMap c)                         //构造一个集合视图，其更改器方法将抛出一个UnsupportedOperationException

static  Collection synchronizedCollection(Collection c)

static  List synchronizedList(List c)

static  Set synchronizedSet(Set c)

static  SortedSet synchronizedSortedSet(SortedSet c)

static  Map synchronizedMap(Map c)

static  SortedMap synchronizedSortedMap(SortedMap c)                                    //构造一个集合视图，其方法都是同步的

static  Collection checkedCollection(Collection c)

static  List checkedList(List c)

static  Set checkedSet(Set c)

static  SortedSet checkedSortedSet(SortedSet c)

static  Map checkedMap(Map c)

static  SortedMap checkedSortedMap(SortedMap c)                                   //构造一个集合视图，如果插入一个错误元素，将抛出ClassCastException

static  List nCopies(int n, E value)

static  Set singleton(E value)                                          //构造一个对象视图，它既可以作为一个拥有n个相同元素的不可修改列表，又可以作为拥有一个单一元素的集
</code></pre><p><strong>java.util.Arrays</strong></p>
<pre><code>static  List asList(E... array)                            //返回一个数组元素的列表视图，可修改但大小不可变
</code></pre><p><strong>java.util.List</strong></p>
<pre><code>List subList(int firstIncluded, int firstExclued)                                   //返回给定位置范围内的所有元素的列表视图
</code></pre><p><strong>java.util.SortedSet</strong></p>
<pre><code>SortedSet subSet(E firstIncluded, E firstExcluded)

SortedSet headSet(E firstExcluded)

SortedSet tailSet(E firstIncluded)                                          //返回给定位置内的元素视图
</code></pre><p><strong>java.util.NavigableSet</strong></p>
<pre><code>NavigableSet subSet(E from, boolean fromIncluded, E to, boolean toIncluded)

NavigableSet headSet(E to, boolean toIncluded)

NavigableSet tailSet(E from, boolean fromIncluded)                               //返回给定位置内的元素视图，boolean决定是否包含边界
</code></pre><p><strong>java.util.SortedMap</strong></p>
<pre><code>SortedMap subMap(K firstIncluded, K firstExcluded)

SortedMap headMap(K firstExcluded)

SortedMap tailMap(K firstIncluded)                               //返回给定范围内的键条目的映射表视图
</code></pre><p><strong>java.util.NavigableMap</strong></p>
<pre><code>NavigableMap subMap(K from, boolean fromIncluded, K to, boolean toIncluded)

NavigableMap headMap(K from, boolean fromIncluded)

NavigableMap tailMap(K to, boolean toIncluded)                         //返回在给定范围内的键条目的映射表视图，boolean决定是否包含边界
</code></pre><p><strong>集合与数组间的转换</strong></p>
<pre><code>数组转集合：

Arrays.asList(E... array)

集合转数组：

Object[] values = staff.toArray()

String[] values = staff.toArray(new String[0])

staff.toArray(new String[staff.size()])
</code></pre><p><strong>算法</strong></p>
<p>排序与混排</p>
<p>Java中的sort方法的实现：将所有元素转入一个数组，并使用一种归并排序的变体对数组进行排序，然后将排序后的数组复制回列表</p>
<p><strong>java.util.Collections</strong></p>
<pre><code>static &gt; void sort(List elements)

static  void sort(List elements, Comparator)                       //使用稳定的排序算法，对表中的元素进行排序，这种算法的时间复杂度是O(n log(n)), 其中n为列表长度

static void shuffle(List elements)

static void shuffle(List elements, Random r)                     //随机的打乱表中的元素，算法复杂度是O(n a(n))， n为列表长度，a(n)为访问元素的平均时间

static  Comparator reverseOrder()                             //返回一个比较器，它用与Comparable()接口的compareTo()方法规定的顺序的逆序对元素进行排序

static  Comparator reverseOrder(Comparator comp)                          //返回一个比较器，用comp给定的顺序的逆序进行排序
</code></pre><p>二分查找</p>
<p><strong>java.util.Collections</strong></p>
<pre><code>static  int binarySearch( elements, T key)

static  int binarySearch(List elements, Comparator c)                      //从有序列表中搜索一个键，如果元素扩展了AbstractSequentialList类，则采用线性查找，否则采用二分查找。时间复杂度为O(a(n)log(n))，n为列表长度，a(n)为元素的平均访问时间，这个方法将返回这个键在列表中的索引，如果不存在这个键则返回一个负值i。将这个键插入到索引-i-1的位置上，可以保持列表的有序性
</code></pre><p>其他简单算法</p>
<p><strong>java.util.Collections</strong></p>
<pre><code>static &gt; T min(Collection elements)

static &gt; T max(Collection elements)

static  min(Collection elements, Comparactor c)

static  max(Collection elements, Comparator c)                        //返回集合中最小的或最大的元素

static  void copy(List to, List from)                             //将原列表中的所有元素复制到目标列表的相应位置上。目标列表的长度至少与原列表一样

static  void fill(List l, T value)                              //将列表中的所有位置设置为相同的值

static  boolean addAll(Collection c, T... values)                            //将所有的值添加到集合中，如果集合改变了返回true

static  boolean replaceAll(List l, T oldValue, T newValue)                     //用newValue取代所有值为oldValue的元素

static int indexOfSubList((List l, List s)

static int lastIndexOfSubList(List l, List s)                                 //返回l中第一个或最后一个等于s子列表的索引。如果l中不存在等于s的子列表，则返回-1

static void swap(List l, int i, int j)                               //交换给定偏移量的两个元素

static void reverse(List l)                                        //逆置列表中元素的顺序，时间复杂度为O(n)

static void rotate(List l, int d)                                     //旋转列表中的元素，将索引i的条目移动到位置(i + d)%l.size()。时间复杂度为O(n)

static int frequency(Collection c, Object o)                             //返回c中与对象o相同的元素个数

boolean disjoint(Collection c1, Collection c2)                          //如果两个集合没有共同的元素，则返回true
</code></pre><p><strong>遗留的集合</strong></p>
<p>Hashtable类</p>
<p>枚举</p>
<p><strong>java.util.Enumeration</strong></p>
<pre><code>boolean hasMoreElements()                                //如果还有更多的元素可以查看，则返回true

E nextElement()                                           //返回被检测的下一个元素
</code></pre><p><strong>java.util.Hashtable</strong></p>
<pre><code>Enumeration keys()                              //返回一个遍历散列表中键的枚举对象

Enumeration elements()                            //返回一个遍历散列表中元素的枚举对象
</code></pre><p><strong>java.util.Vector</strong></p>
<pre><code>Enumeration elements()                     //返回遍历向量中元素的枚举对象
</code></pre><p>属性映射表（property map）</p>
<p>实现属性映射表的Java平台类称为Properties</p>
<p><strong>java.util.Properties</strong></p>
<pre><code>Properties()                                //创建一个空的属性映射表

Properties(Properties defaults)                     //创建一个带有一组默认值的空的属性映射表

String getProperty(String key)                             //获得属性的对应关系，返回与键对应的字符串，如果在映射表中不存在，返回默认表中与这个键对应的字符串

String getProperty(String key, string defaultValue)                        //获得在键没有找到时具有的默认值属性，将返回与键对应的字符串，如果在映射表中不存在，就返回默认的字符串

void load(InputStream in)                             //从InputStream加载属性映射表

void store(OutoutStream out, String commentString)                         //把属性映射表存储到OutputStream
</code></pre><p>栈</p>
<p>Stack类扩展为Vector类</p>
<p><strong>java.util.Stack</strong></p>
<pre><code>E push(E item)                         //将item压入栈并返回item

E pop()                                  //弹出并返回栈顶的item

E peek()                            //返回栈顶元素，但不弹出
</code></pre><p>位集</p>
<p><strong>java.util.BitSet</strong></p>
<pre><code>BitSet(int initialCpacity)                       //创建一个位集

int length()                         //返回位集的逻辑长度

boolean get(int bit)             //获得一个位

void set(int bit)                        //设置一个位，开

void clear(int bit)                         //清除一个位，关

void and(BitSet set)                            //这个位集与另一个位集进行逻辑“AND&quot;

void or(BitSet set)                          //这个位集与另一个位集进行逻辑“OR”

void xor(BitSet set)                            //逻辑“XOR”

void andNot(BitSet set)                                //清除这个位集中对应另一个位集中设置的所有位
</code></pre><p><strong>第14章–多线程————————————————————————————————</strong></p>
<p>每个进程拥有自己的一整套变量，而线程则共享数据</p>
<p>也可以通过构建一个Thread的子类来定义一个线程，如</p>
<pre><code>class MyThread extends Thread {

    public void run() {

        task code

    }

}
</code></pre><p>然后构建一个子类调用start方法</p>
<p>不要调用Thread类或Runnable对象的run()方法，只会执行run()中的任务，不会启动新线程</p>
<p><strong>java.lang.Thread</strong></p>
<pre><code>static void sleep(long millis)                        //休眠给定的毫秒数

Thread(Runnable target)                           //构造一个新线程，用于调用给定target的run()方法

void start()                    //启动线程，将调用run()方法。这个方法立即返回，并且新线程并行运行

void run()                     //调用关联Runnable()的run()方法
</code></pre><p><strong>java.lang.Runnable</strong></p>
<pre><code>void run()                      //必须覆盖这个方法，在这个方法中提供要执行的指令
</code></pre><p><strong>中断线程</strong></p>
<p>如果在每次工作迭代之后都调用sleep()方法（或其他的可中断方法），isInterrupted检测既没必要也没用处</p>
<p><strong>java.lang.Thread</strong></p>
<pre><code>void interrupt()                                   //向线程发送中断请求，线程的中断状态将被设置为true，如果目前线程被一个sleep()阻塞，将会抛出InterruptedException异常

static boolean interrupted()                         //测试当前线程（正在执行这一命令的线程）是否被中断，并将会将当前线程的中断状态设置为false

boolean isInterrupted()                               //测试线程是否被终止，不改变线程中断状态

static Thread currentThread()                        //返回代表当前执行线程的Thread对象
</code></pre><p>线程状态（6种）</p>
<p>New（新创建）</p>
<p>Runnable（可运行）</p>
<p>Blocked（被阻塞）</p>
<p>Waiting（等待）</p>
<p>Timed waiting（计时等待）</p>
<p>Terminated（被终止）</p>
<p>调度器使用时间片机制，抢占式调度系统给每一个可运行线程一个时间片来执行任务，当时间片用完，操作系统将剥夺该线程的运行权，并给另一个线程运行机会</p>
<p><strong>java.lang.Thread</strong></p>
<pre><code>void join()                            //等待终止指定的线程

void join(long millis)                         //等待指定的线程死亡或者经过指定的毫秒数

Thread.State getState()                      //得到这一线程的状态

void stop()                      //停止该线程，方法已过时

void suspend()                         //暂停这一线程的执行，方法已过时

void resume()                          //恢复线程，仅在suspend()之后调用，方法已过时
</code></pre><p>线程属性</p>
<p>线程优先级</p>
<p><strong>java.lang.Thread</strong></p>
<pre><code>void setPriority(int newPriority)                    //设置线程的优先级，必须在Thread.MIN_PRIORITY与Thread.MAX_PRIORITY之间，一般用Thread.NORM_PRIORITY优先级

static int MIN_PRIORITY                          //线程的最小优先级，值为1

static int NORM_PRIORITY                        //线程的默认优先级，值为5

static int MAX_PRIORITY                            //线程的最高优先级，值为10

static void yield()                                 //导致当前执行线程处于让步状态。如果有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调度。
</code></pre><p>守护线程</p>
<p><strong>java.lang.Thread</strong></p>
<pre><code>void setDaemon(boolean isDaemon)                      //标识该线程为守护线程或用户线程。这方法必须在线程启动之前调用
</code></pre><p>未捕获异常处理器</p>
<p>线程的run方法不能抛出任何被检测的异常</p>
<p>该处理器必须属于一个实现Thread.UncaughtExceptionHandler接口的类</p>
<p>如果不安装默认的处理器，磨人的处理器为空。如果不为独立的线程安装处理器，此时处理器就是该线程的ThreadGroup对象</p>
<p><strong>java.lang.Thread</strong></p>
<pre><code>static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)

static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()       //设置或获取未捕获异常的默认处理器

void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)

Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()                //设置或获取未捕获异常的处理器
</code></pre><p><strong>java.lang.Thread.UncaughtExceptionHandler</strong></p>
<pre><code>void uncaughtException(Thread t, Throwable e)               //当一个线程因未捕获异常而终止，按规定要将客户报告记录到日志中
</code></pre><p><strong>java.lang.ThreadGroup</strong></p>
<pre><code>void uncaughtException(Thread t, Throwable e)           //如果有父线程组，调用父线程组的这一方法；或者，如果Thread类有默认处理器，调用该处理器，否则，输出栈踪迹到标准错误流上（但如果e是一个ThreadDeath对象，栈踪迹是被禁用的）
</code></pre><p>锁对象</p>
<p>ReentrantLock类实现了Lock接口</p>
<p><strong>java.util.concurrent.locks.Lock</strong></p>
<pre><code>void lock()                    //获取这个锁，如果锁同时被另一个线程拥有则发生阻塞

void unlock()                       //释放这个锁
</code></pre><p><strong>java.util.concurrent.locks.ReentrantLock</strong></p>
<pre><code>ReentrantLock()                  //构建一个可以被用来保护临界区的可重入锁

ReentrantLock(boolean fair)                         //构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但是会降低性能
</code></pre><p>条件对象</p>
<p><strong>java.util.concurrent.locks.Lock</strong></p>
<pre><code>Condition newCondition()                       //返回一个与该锁相关的条件对象
</code></pre><p><strong>java.util.concurrent.locks.Condition</strong></p>
<pre><code>void await()                       //将该线程放到条件的等待集中

void signalAll()                        //解除该条件的等待集中的所有线程的阻塞状态

void signal()                           //从该条件的等待集中随机地选择一个线程，解除其阻塞状态
</code></pre><p>synchronized关键字</p>
<pre><code>public synchronized void method()

{

    method body

}
</code></pre><p>等价于</p>
<pre><code>public void method()

{

    this.intrinsicLock.lock();

    try

    {

        method body

    }

    finally { this.intrinsicLock.unlock(); }

}
</code></pre><p>每个对象有一个内部锁，并且该锁只有一个内部条件</p>
<p>将静态方法声明为synchronized也是合法的，当该方法被调用时，相关的类对象的内部锁被锁住，因此没有其他线程可以调用同一个类的这个或任何其他的同步静态方法</p>
<p>使用优先情况：阻塞队列 &gt; synchronized &gt; Lock/Condition</p>
<p><strong>java.lang.Object</strong></p>
<pre><code>void notifyAll()               //解除那些在该对象上调用wait方法的线程的阻塞状态，只能在同步方法或同步块内部调用

void notify()                    //随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态。

void wait()                       //导致线程进入等待状态直到它被通知。该方法只能在一个同步方法中调用。

void wait(long millis)

void wait(long millis, int nanos)                        //导致线程进入等待状态直到它被通知或者经过指定的时间
</code></pre><p>同步阻塞</p>
<pre><code>synchronized (obj)

{

    critical section

}                     //获得obj的锁
</code></pre><p>客户端锁定</p>
<p>监视器概念</p>
<p>监视器是只包含私有域的类，每个监视器类的对象有一个相关的锁，使用该锁对所有的方法进行加锁，该锁可以有任意多个相关条件</p>
<p>volatile域</p>
<p>volatile关键字为实例域的同步访问提供了一种免锁机制，如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的，但是volatile变量不能提供原子性</p>
<p>线程局部变量</p>
<p>例如SimpleDateFormat类，为每一个线程构造一个实例</p>
<pre><code>public static final ThreadLocal dateFormat =

    new ThreadLocal() {

        protected SimpleDateFormat initialValue() {

            return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);

        }

    };
</code></pre><p><strong>java.lang.ThreadLocal</strong></p>
<pre><code>T get()                      //得到这个线程的当前值。如果是首次调用get，会调用initialize来得到这个值

protected initialize()                        //应覆盖这个方法来提供一个初始值。默认情况下，返回null

void set(T t)                      //为这个线程设置一个新值

void remove()                        //删除对应这个线程的值
</code></pre><p><strong>java.util.concurrent.ThreadLocalRandom</strong></p>
<pre><code>static ThreadLocalRandom current()                       //返回特定于当前线程的Random类实例
</code></pre><p>锁测试与超时</p>
<p><strong>java.util.concurrent.locks.Lock</strong></p>
<pre><code>boolean tryLock()                     //尝试获得锁而没有发生阻塞；如果成功返回真。这个方法会抢夺可用的锁，即使该锁有公平加锁策略，即便其他线程已经等待很久也是如此

boolean tryLock(long time, TimeUnit unit)            //尝试获得锁，阻塞时间不会超过给定的值；如果成功返回true

void lockInterruptibly()             //获得锁，但是会不确定的发生阻塞，如果线程被中断，抛出InterruptedException异常
</code></pre><p><strong>java.util.concurrent.locks.Condition</strong></p>
<pre><code>boolean await(long time, TimeUnit unit)                    //进入该条件的等待集，直到线程从等待集中移除或等待了指定的时间之后才解除阻塞，如果因为等待时间到了而返回就返回false，否则返回true

void awaitUninterruptibly()                 //进入该条件的等待集，直到线程从等待集移出才解除阻塞，如果线程被中断，该方法不会抛出InterruptedException异常
</code></pre><p>读/写锁</p>
<p><strong>java.util.concurrent.locks.ReentrantReadWriteLock</strong></p>
<pre><code>Lock readLock()                    //得到一个可以被多个读操作公用的读锁，但会排斥所有写操作

Lock writeLock()                       //得到一个写锁，排斥所有其他的读操作和写操作
</code></pre><p>阻塞队列</p>
<p>阻塞队列方法</p>
<p>| add | 添加一个元素 | 如果队列满，抛出IllegalStateException异常 |<br>| element | 返回队列的头元素 | 如果队列空，抛出NoSuchElementException异常 |<br>| offer | 添加一个元素并返回true | 如果队列满，返回false<br> |<br>| peek | 返回队列的头元素 | 如果队列空，返回null<br> |<br>| poll | 移出并返回队列的头元素 | 如果队列空，返回null |<br>| put | 添加一个元素 | 如果队列满，则阻塞 |<br>| remove | 移出并返回头元素 | 如果队列空，抛出NoSuchElementException异常 |<br>| take | 移出并返回头元素 | 如果队列空，则阻塞 |</p>
<p><strong>java.util.concurrent.ArrayBlockingQueue</strong></p>
<pre><code>ArrayBlockingQueue(int capacity)

ArrayBlockingQueue(int capacity, boolean fair)       //构造一个带有指定的容量和公平性设置的阻塞队列。该队列用循环数组实现
</code></pre><p><strong>java.util.concurrent.LinkedBlockingQueue</strong></p>
<pre><code>LinkedBlockingQueue()

LinkedBlockingDeque()                 //构造一个无上限的阻塞队列或双向队列，用链表实现

LinkedBlockingQueue(int capacity)    

LinkedBlockingDeque(int capacity)                  //根据指定容量构建一个有限的阻塞队列或双向队列，用链表实现
</code></pre><p><strong>java.util.concurrent.DelayQueue</strong></p>
<pre><code>DelayQueue()             //构造一个包含Delayed元素的无界的阻塞时间有限的阻塞队列。只有那些延迟已经超过时间的元素可以从队列中移出
</code></pre><p><strong>java.util.concurrent.Delayed</strong></p>
<pre><code>long getDelay(TimeUnit unit)           //得到该对象的延迟，用给定的时间单位进行度量
</code></pre><p><strong>java.util.concurrent.PriorityBlockingQueue</strong></p>
<pre><code>PriorityBlockingQueue()

PriorityBlockingQueue(int initialCapacity)

PriorityBlockingQueue(int initialCapacity, Comparator comparator)     //构造一个无边界阻塞优先队列，用堆实现
</code></pre><p><strong>java.util.concurrent.BlockingQueue</strong></p>
<pre><code>void put(E element)           //添加元素，在必要时阻塞

E take()                           //移出并返回头元素，必要时阻塞

boolean offer(E element, long time, TimeUnit unit)          //添加给定的元素，如果成功返回true，如果必要时阻塞，直至元素已经被添加或超时

E poll(long time, TimeUnit unit)         //移出并返回头元素，必要时阻塞，直至元素可用或超时用完。失败时返回null
</code></pre><p><strong>java.util.concurrent.BlockingDeque</strong></p>
<pre><code>void putFirst(E element)

void putLast(E element)               //添加元素，必要时阻塞

E takeFirst()

E takeLast()                    //移出并返回头元素或尾元素，必要时阻塞

boolean offerFirst(E element, long time, TimeUnit unit)

boolean offerLast(E element, long time, TimeUnit unit)            //添加给定的元素，成功时返回true，必要时阻塞直至元素被添加或超时

E pollFirst(long time, TimeUnit unit)

E pollLast(long time, TimeUnit unit)               //移动并返回头元素或尾元素，必要时阻塞，直至元素可用或超时，失败时返回null
</code></pre><p><strong>java.util.concurrent.TransferQueue</strong></p>
<pre><code>void transfer(E element)

boolean tryTransfer(E element, long time, TimeUnit unit)           //传输一个值，或者尝试在给定的超时时间内传输这个值，这个调用将阻塞，直到另一个线程将元素删除。第二个方法会在调用成功时返回true
</code></pre><p><strong>线程安全的集合</strong></p>
<p>高效的映射表、集合和队列</p>
<p>这些集合返回弱一致性（weakly consisteut)的迭代器，意味着迭代器不一定能反映出它们被构造之后的所有的修改，不会抛出ConcurrentModificationException异常</p>
<p><strong>java.util.concurrent.ConcurrentLinkedQueue</strong></p>
<pre><code>ConcurrentLinkedQueue()            //构造一个可以被多线程安全访问的无边界非阻塞的队列

ConcurrentSkipListSet()

ConcurrentSkipListSet(Comparator comp)     //构造一个可以被多线程安全访问的有序集，第一个要求元素实现Comparable接口
</code></pre><p><strong>java.util.concurrent.ConcurrentHashMap</strong></p>
<p><strong>java.util.concurrent.ConcurrentSkipListMap</strong></p>
<pre><code>ConcurrentHashMap()

ConcurrentHashMap(int initialCapacity)

ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)           //构造一个可以被多线程安全访问的散列映射表

ConcurrentSkipListMap()

ConcurrentSkipListSet(Comparator comp)    //构造一个可以被多线程安全访问的有序的映射表

V putIfAbsent(K key, V value)           //如果该键没有在映射表中出现，则将给定的值同给定的键关联起来，并返回null，否则返回与该键关联的现有值

boolean remove(K key, V value)          //如果给定的键与给定的值关联，删除给定的键与值并返回真，否则返回false

boolean replace(K key, V oldValue, V newValue)      //如果给定的键当前与oldValue相关联，用它与newValue关联，否则返回false
</code></pre><p>写数组的拷贝</p>
<p>CopyOnWriteArrayList和CopyOnWriteArraySet，所有的修改线程对底层数组进行复制</p>
<p>任何集合类可以使用同步包装器（synchronization wrapper)变成线程安全的：</p>
<pre><code>List synchArrayList = Collections.synchronizedList(new ArrayList());
</code></pre><p>如果在另一个线程可能进行修改时要对集合进行迭代，仍然需要使用“客户端”锁定：</p>
<pre><code>synchronized (synchHashMap)

{

    Iterator iter = synchHashMap.keySet().iterator();

    while (iter.hasNext()) ...;

}
</code></pre><p>最好使用java.util.concurrent包中定义的集合，不使用同步包装器中的</p>
<p><strong>java.util.Collections</strong></p>
<pre><code>static  Collection synchronizedCollection(Collection c)

static  List synchronizedList(List c)

static  Set synchronizedSet(Set c)

static  SortedSet synchronizedSortedSet(SortedSet c)

static  Map synchronizedMap(Map c)

static  SortedMap synchronizedSortedMap(SortedMap c)       //构建集合视图，该集合的方法是同步的
</code></pre><p><strong>Callable与Future</strong></p>
<p>Callable与Runnable类似，但是有返回值，类型参数是返回值的类型</p>
<p>Future保存异步计算的结果，可以启动一个计算，将Future计算交给某个线程，Future对象的所有者在结果计算好之后就可以获得它</p>
<p>FutureTask包装器是一种非常便利的机制，可将Callable转换成Future和Runnable，它同时实现二者的接口，例如：</p>
<pre><code>Callable&lt;Integer&gt; myComputation = ...;
FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(myComputation);
Thread t = new Thread(task); //it&apos;s a Runnable
t.start();
...
Integer result = task.get(); //it&apos;s a Future
</code></pre><p><strong>java.util.concurrent.Callable</strong></p>
<pre><code>V call()               //运行一个将产生结果的任务
</code></pre><p><strong>java.util.concurrent.Future</strong></p>
<pre><code>V get()

V get(long time, TimeUnit unit)           //获取结果，如果没有结果可用，则阻塞直到真正得到结果超过指定的时间为止。如果不成功，第二个方法抛出TimeoutException异常

boolean cancel(boolean mayInterrupt)              //尝试取消这一任务的运行，如果任务已经开始，并且mayInterrupt参数值为true，它就会被中断，如果成功执行了取消操作，返回true

boolean isCancelled()              //如果任务在完成前被取消了，返回true

boolean isDone()                         //如果任务结束，无论是正常结束、中途取消或发生异常，都返回true。
</code></pre><p><strong>java.util.concurrent.FutureTask</strong></p>
<pre><code>FutureTask(Callable task)

FutureTask(Runnable task, V result)                     //构造一个既是Future又是Runnable的对象
</code></pre><p><strong>执行器</strong></p>
<p>执行者工厂方法</p>
<p>| newCachedThreadPool | 必要时创建新线程；空闲线程会被保留60秒 |<br>| newFixedThreadPool | 该池包含固定数量的线程：空闲线程一直被保留 |<br>| newSingleThreadExecutor | 只有一个线程的池，该线程顺序执行每一个提交的任务 |<br>| newScheduledThreadPool | 用于预定执行而构建的固定线程池，替代java.util.Timer |<br>| newSingleThreadScheduledExecutor | 用于预定执行而构建的单线程池 |</p>
<p>连接池使用：</p>
<p>1. 调用Executors类中静态的方法newCachedThreadPool或newFixedThreadPool</p>
<p>2. 调用submit提交Runnable或Callable对象</p>
<p>3. 如果想要取消一个任务，或如果提交Callable对象，那就要保存好返回的Future对象</p>
<p>4. 当不再提交任何任务时，调用shutdown</p>
<p><strong>java.util.concurrent.Executors</strong></p>
<pre><code>ExecutorService newCachedThreadPool()      //返回一个带缓存的线程池

ExecutorService newFixedThreadPool(int threads)             //返回一个指定线程数的线程池

ExecutorService newSingleThreadExecutor()               //返回一个执行器，它在一个单个的线程中依次执行各个任务
</code></pre><p><strong>java.util.concurrent.ExecutorService</strong></p>
<pre><code>Future submit(Callable task)

Future submit(Runnable task, T result)

Future submit(Runnable task)          //提交指定的任务去执行

void shutdown()            //关闭服务，会先完成已经提交的任务而不再接收新的任务
</code></pre><p><strong>java.util.concurrent.ThreadPoolExecutor</strong></p>
<pre><code>int getLargestPoolSize()            //返回线程池在该执行器生命周期中的最大尺寸
</code></pre><p>预定执行</p>
<p>ScheduledExecutorService接口具有为预定执行或重复执行任务而设计的方法</p>
<p>可以预定Runnable或Callable在初始的延迟之后只运行一次，也可以预定一个Runnable对象周期性地运行</p>
<p><strong>java.util.concurrent.Executors</strong></p>
<pre><code>ScheduledExecutorService newScheduledThreadPool(int threads)           //返回一个线程池，它使用给定的线程数来调度任务

ScheduledExecutorService newSingleThreadScheduledExecutor()              //返回一个执行器，它在一个单独线程中调度任务
</code></pre><p><strong>java.util.concurrent.ScheduledExecutorService</strong></p>
<pre><code>ScheduledFuture schedule(Callable task, long time, TimeUnit unit)

ScheduledFuture schedule(Runnable task, long time, TimeUnit unit)            //预定在指定的时间之后执行任务

ScheduledFuture scheduleAtFixedRate(Runnable task, long initialDelay, long period, TimeUnit unit)  //预定在初始的延迟结束后，周期性地运行给定的任务，周期长度是period

ScheduledFuture scheduleWithFixedDelay(Runnable task, long initialDelay, long delay, TimeUnit unit)    //预定在初始的延迟结束后周期性的给定的任务，在一次调用完成和下一次调用开始之间有长度为delay的延迟
</code></pre><p>控制任务组</p>
<p>invokeAny方法提交所有对象到一个Callable对象的集合中，并返回某个已经完成了的任务的结果</p>
<p>invokeAll方法提交所有对象到一个Callable对象的集合中，并返回一个Future对象的列表，代表所有任务的解决方案</p>
<p>可以用ExecutorCompletionService来对结果按可获得的顺序进行排列，如下：</p>
<pre><code>ExecutorCompletionService service = new ExecutorCompletionService(executor);
for (Callable&lt;T&gt; task : tasks) service.submit(task);
for (int i = 0; i &lt; tasks.size(); i++) processFurther(service.take().get());
</code></pre><p><strong>java.util.concurrent.ExecutorService</strong></p>
<pre><code>T invokeAny(Collection&gt; tasks)

T invokeAny(Collection&gt; tasks, long timeout, TimeUnit unit)          //执行给定的任务，返回其中一个任务的结果。第二个方法若发生超时，抛出一个Timeout Exception异常

List&gt; invokeAll(Collection&gt; tasks)

List&gt; invokeAll(Collection&gt; tasks, long timeout, TimeUnit unit)           //执行给定的任务，返回所有任务的结果。第二个方法若发生超时，抛出一个TimeoutException异常
</code></pre><p><strong>java.util.concurrent.ExecutorCompletionService</strong></p>
<pre><code>ExecutorCompletionService(Executor e)           //构建一个执行器完成服务来收集给定执行器的结果

Future submit(Callable task)

Future submit(Runnable task, T result)                 //提交一个任务给底层的执行器

Future take()                     //移除下一个已完成的结果，如果没有任何已完成的结果可用则阻塞

Future poll(long time,TimeUnit unit)            //移除下一个已完成的结果，如果没有任何已完成结果可用则返回null。第二个方法将等待给定的时间
</code></pre><p><strong>Fork-Join框架</strong></p>
<p>分解任务，并行运行，采用框架可用的一种方式完成递归计算，需要提供一个扩展RecursiveTask的类（返回T类型）或者提供一个扩展RecursiveAction（无返回）的类，这两个为ForkJoinTask的子类，覆盖compute方法来生成并调用子任务，然后合并其结果，如：</p>
<pre><code>class Counter extends RecursiveTask&lt;Integer&gt; {
    ...
    protected Integer compute() {
        if (to - from &lt; THRESHOLD) {
            solve problem directly
        }
        else {
            int mid = (from + to) / 2;
            Counter first = new Counter(values, from, mid, filter);
            Counter second = new Counter(values, mid, to, filter);
            invokeAll(first, second);
            return first.join() + second.join();
        }
    }
}
</code></pre><p>在这里，invokeAll方法接收到很多任务并阻塞，直到所有这些任务都已经完成，join方法将生成结果</p>
<p>fork-join框架后台的方法：工作密取（work stealing)</p>
<p>ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务</p>
<p>如：</p>
<pre><code>ForkJoinPool pool = new ForkJoinPool()
pool.invoke(counter);
System.out.println(counter.join());
</code></pre><p><strong>同步器</strong></p>
<p>公用集结点模式，预置功能</p>
<p>| CyclicBarrier | 允许线程集等待直至其中预定数目的线程到达一个公共障栅，然后可以选择执行一个处理障栅的动作 | 当大量的线程需要在它们的结果可用之前完成时 |<br>| CountDownLatch | 允许线程集等待直到计数器减为0 | 当一个或多个线程需要等待直到指定数目的事件发生 |<br>| Exchanger | 允许两个线程在要交换的对象准备好时交换对象 | 当两个线程工作在同一数据结构的两个实例上的时候，一个向实例添加数据而另一个从实例清除数据 |<br>| Semaphore | 允许线程集等待直到被允许继续运行为止 | 限制访问资源的线程总数，如果许可数是1，常常阻塞线程直到另一个线程给出许可为止 |<br>| SynchronousQueue | 允许一个线程把对象交给另一个线程 | 在没有显式同步的情况下，当两个线程准备好将一个对象从一个线程传递到另一个时 |</p>
<p>信号量，管理着许多的许可证，同步原语</p>
<p>倒计时门栓（CountDownLatch)</p>
<p>障栅，使用如下：</p>
<pre><code>CyclicBarrier barrier = new CyclicBarrier(nthreads);
public void run() {
    doWork();
    barrier.await();
}
//或者加入超时参数
barrier.await(100, TimeUnit.MILLISECONDS);
//加入障栅动作
Runnable barrierAction = ...;
CyclicBarrier barrier = new CyclicBarrier(nthreads, barrierAction);
</code></pre><p>交换器（Exchanger)，当两个线程在同一个数据缓冲区的两个实例上工作的时候，就可以使用交换器</p>
<p>同步队列，将生产者与消费者线程配对，当一个线程调用SynchronousQueue的put方法时，它会阻塞直到另一个线程调用take方法。它不是一个队列，没有包含任何元素，数据仅仅沿一个方向传递</p>
<p><strong>线程与Swing</strong></p>
<p>两个原则：</p>
<p>如果一个动作需要花费很长时间，在一个独立的工作器线程中做这件事不要在事件分配线程中做</p>
<p>除了事件分配线程，不要在任何线程中接触Swing组件</p>
<p>假定想在一个线程中周期性地更新标签来表明进度。不可以从自己的线程中调用label.setText，而应该使用EventQueue类的invokeLater方法(异步执行)和invokeAndWait方法使所调用的方法在事件分配线程中执行，如：</p>
<pre><code>EventQueue.invokeLater(new
    Runnable()
    {
        public void run()
        {
            label.setText(percentage + &quot;% complete&quot;);
        }
    });
</code></pre><p><strong>java.awt.EventQueue</strong></p>
<pre><code>static void invokeLater(Runnable runnable)       //在待处理的线程被处理之后，让runnable对象的run方法在事件分配线程中执行

static void invokeAndWait(Runnable runnable)            //在待处理的线程被处理之后，让runnable对象的run方法在事件分配线程中执行，该调用会阻塞，知道run方法终止

static boolean isDispatchThread()            //如果执行这一方法的线程是事件分配线程，返回true

Swing工作线程
</code></pre><p><strong>javax.swing.SwingWorker  //产生类型为T的结果以及类型为V的进度数据</strong></p>
<pre><code>abstract T doInBackground()     //覆盖这一方法来执行后台的任务并返回这一工作的结果

void process(List data)       //覆盖这一方法来处理事件分配线程中的中间进度数据

void publish(V... data)           //传递中间进度数据到事件分配线程中。从doInBackground调用这方法

void execute()         //为工作器线程的执行预定这个工作器

SwingWorker.StateValue getState()          //得到这个工作器线程的状态，值为PENDING、STARTED或DONE之一
</code></pre><p>单一线程规则</p>
<p>每一个Java应用程序都开始于主线程中的main方法，在Swing程序中，main方法的生命周期很短，它在事件分配线程中规划用户界面的构造然后退出。</p>
<p>一些线程安全的方法：</p>
<p>JTextComponent.setText</p>
<p>JTextArea.insert</p>
<p>JTextArea.append</p>
<p>JTextArea.replaceRange</p>
<p>JComponent.repaint</p>
<p>JComponent.revalidate</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/读书笔记-Java核心技术-高级特征/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KioLuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://b-ssl.duitang.com/uploads/item/201602/18/20160218194039_c2Kmt.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KioLuo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/13/读书笔记-Java核心技术-高级特征/" itemprop="url">
                  读书笔记--Java核心技术--高级特征
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T18:08:27+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>第一章–流与文件———————————————-</strong></p>
<p><strong>流</strong></p>
<p><strong>读写字节</strong></p>
<p><strong>java.io.InputStream 1.0</strong></p>
<ol>
<li><code>abstract  int read()  //从数据中读入一个字节，并返回该字节，在碰到流的结尾时返回-1</code></li>
<li><code>int read(byte[] b)  //读入一个字节数组，并返回实际读入的字节数，或者在碰到流的结尾时返回-1</code></li>
<li><code>int read(byte[] b,  int off,  int len)  //读入一个字节数组。这个read方法返回实际读入的字节数，或者在碰到流的结尾时返回-1</code></li>
<li><code>long skip(long n)  //在输入流中跳过n个字节，返回实际跳过的字节数（如果碰到流的结尾，则可能小于n）</code></li>
<li><code>int available()  //返回在不阻塞的情况下可用的字节数</code></li>
<li><code>void close()  //关闭这个输入流</code></li>
<li><code>void mark(int readLimit)  //在输入流的当前位置打一个标记，如果输入流中已经读入的字节多于readLimit个，则这个流允许忽略这个标记</code></li>
<li><code>void reset()  //返回到最后的标记，随后对read的调用将重新读入这些字节</code></li>
<li><code>boolean markSupported()  //如果这个流支持打标记，则返回true</code></li>
</ol>
<p><strong>java.io.OutputStream 1.0</strong></p>
<ol>
<li><code>abstract  void write(int n)  //写出一个字节的数据</code></li>
<li><code>void write(byte[] b)</code></li>
<li><code>void write(byte[] b,  int off,  int len)  //写出所有字节或者某个范围的字节到数组b中</code></li>
<li><code>void close()  //清空并关闭输出流</code></li>
<li><code>void flush()  //清空输出流，也就是将所有缓冲的数据发送到目的地</code></li>
</ol>
<p>流家族</p>
<p>InputStream和OutputStream为基础</p>
<p>DataInputStream和DataOutputStream可以以二进制格式读写所有的基本Java类型</p>
<p>ZipInputStream和ZipOutputStream可以以常见的ZIP压缩格式读写文件</p>
<p>4个附加接口：Closeable、Flushable、Readable和Appendable</p>
<p><strong>java.io.Closeable 5.0</strong></p>
<ol>
<li><code>void close()  //关闭这个Closeable，可能会抛出IOException</code></li>
</ol>
<p><strong>java.io.Flushable 5.0</strong></p>
<ol>
<li><code>void flush()  //清空这个Flushable</code></li>
</ol>
<p><strong>java.lang.Readable 5.0</strong></p>
<ol>
<li><code>int read(CharBuffer cb)  //尝试读入cb可以持有的数量的char值。返回读入的char值的数量</code></li>
</ol>
<p><strong>java.lang.Appendable 5.0</strong></p>
<ol>
<li><code>Appendable append(char c)</code></li>
<li><code>Appendable append(CharSequence cs)  //向这个Appendable中追加给定的码元或者给定的序列中的所有码元，返回this</code></li>
</ol>
<p><strong>java.lang.CharSequence 1.4</strong></p>
<ol>
<li><code>char charAt(int index)  //返回给定索引处的码元</code></li>
<li><code>int length()  //返回这个序列中的码元的数量</code></li>
<li><code>CharSequence subSequence(int startIndex,  int endIndex)  //返回由存储在startIndex到endIndex - 1处的所有码元构成的CharSequence</code></li>
<li><code>String toString()  //返回这个序列中所有码元构成的字符串</code></li>
</ol>
<p>组合流过滤器</p>
<ol>
<li><code>FileInputStream fin =  new  FileInputStream(&quot;employee.dat&quot;);</code></li>
<li><code>DataInputStream din =  new  DataInputStream(fin);</code></li>
<li><code>double s = din.readDouble();</code></li>
</ol>
<p>使用缓冲机制</p>
<ol>
<li><code>DataInputStream din =  new  DataInputStream(</code></li>
<li><code>new  BufferedInputStream(</code></li>
<li><code>new  FileInputStream(&quot;employee.dat&quot;)));</code></li>
</ol>
<p>从一个ZIP压缩文件中读入数字</p>
<ol>
<li><code>ZipInputStream zin =  new  ZipInputStream(new  FileInputStream(&quot;employee.zip&quot;));</code></li>
<li><code>DataInputStream din =  new  DataInputStream(zin);</code></li>
</ol>
<p><strong>java.io.FileInputStream 1.0</strong></p>
<ol>
<li><code>FileInputStream(String name)</code></li>
<li><code>FileInputStream(File file)  //使用由name字符串或file对象指定路径名的文件创建一个新的文件输入流</code></li>
</ol>
<p><strong>java.io.FileOutputStream 1.0</strong></p>
<ol>
<li><code>FileOutputStream(String name)</code></li>
<li><code>FileOutputStream(String name,  boolean append)</code></li>
<li><code>FileOutputStream(File file)</code></li>
<li><code>FileOutputStream(File file,  boolean append) //</code>使用由name字符串或file对象指定路径名的文件创建一个新的文件输出流</li>
</ol>
<p><strong>java.io.BufferedInputStream 1.0</strong></p>
<ol>
<li><code>BufferedInputStream(InputStream in)  //创建一个带缓冲区的流</code></li>
</ol>
<p><strong>java.io.BufferdOutputStream 1.0</strong></p>
<ol>
<li><code>BufferedOutputStream(OutputStream out)  //创建一个带缓冲区的流</code></li>
</ol>
<p><strong>java.io.PushbackInputStream 1.0</strong></p>
<ol>
<li><code>PushbackInputStream(InputStream in)</code></li>
<li><code>PushbackInputStream(InputStream in,  int size)  //构建一个可以预览一个字节或者具有指定尺寸的回推缓冲区的流</code></li>
<li>void unread(int b)  //回推一个字节，它可以在下次调用read时被再次获取，b:要再次读入的字节</li>
</ol>
<p><strong>文本输入与输出</strong></p>
<ol>
<li><code>InputStreamReader in =  new  InputStreamReader(new  FileInputStream(&quot;input.txt&quot;),  &quot;ISO8859_5&quot;);</code></li>
<li>等价于</li>
<li><code>FileReader in =  new  FileReader(&quot;input.txt&quot;):</code></li>
</ol>
<p>以文本格式打印字符串和数字</p>
<ol>
<li><code>PrintWriter out =  new  PrintWriter(&quot;employee.txt&quot;):</code></li>
<li><code>等同于</code></li>
<li><code>PrintWriter out =  new  PrintWriter(new  FileWriter(&quot;employee.txt&quot;));</code></li>
</ol>
<p>System.out是PrintStream类，在内部采用与PrintWriter相同的方式将Unicode字符转换成了默认的主机编码方式。与PrintWriter不同的是，它们允许我们用write(int)和write(byte[])方法输出原生字节</p>
<p><strong>java.io.PrintWriter 1.1</strong></p>
<ol>
<li><code>PrintWriter(Writer out)</code></li>
<li><code>PrintWriter(Writer out,  boolean autoFlush)  //创建一个新的PrintWriter</code></li>
<li><code>PrintWriter(OutputStream out)</code></li>
<li><code>PrintWriter(OutputStream out,  boolean autoflush)  //通过创建必需的中介OutputStreamWriter，从已有的OutputStream中创建一个新的PrintWriter</code></li>
<li><code>PrintWriter(String filename)</code></li>
<li><code>PrintWriter(File file)  //通过创建必需的中介FileWriter，创建一个想给定的文件写出的新的PrintWriter</code></li>
<li><code>void print(Object obj)  //通过打印从toString产生的字符串来打印一个对象</code></li>
<li><code>void print(String s)  //打印一个Unicode字符串</code></li>
<li><code>void println(String s)  //打印一个字符串，后面紧跟一个行终止符</code></li>
<li><code>void print(char[] s)  //打印给定的字符串中的所有Unicode字符</code></li>
<li><code>void print(char c)  //打印一个Unicode字符</code></li>
<li><code>void print(int i)</code></li>
<li><code>void print(long l)</code></li>
<li><code>void print(float f)</code></li>
<li><code>void print(double d)</code></li>
<li><code>void print(boolean b)  //以文本格式打印给定的值</code></li>
<li><code>void printf(String format,  Object... args)  //按照格式化字符串指定的方式打印给定的值</code></li>
<li><code>boolean checkError()  //如果产生格式化或输出错误，返回true</code></li>
</ol>
<p>使用Scanner读入文本输入</p>
<p>Java SE 5.0之前，处理文本的唯一方式就是BufferedReader类，它拥有一个readLine方法，可以读入一行文本</p>
<ol>
<li><code>BufferedReader in =  new  BufferedReader(new  FileReader(&quot;employee.txt&quot;));</code></li>
</ol>
<p>字符集</p>
<ol>
<li><code>//编码Unicode字符串</code></li>
<li><code>Charset cset =  Charset.forName(&quot;ISO-8859-1&quot;):</code></li>
<li><code>String str =  ...;</code></li>
<li><code>ByteBuffer buffer = cset.encode(str);</code></li>
<li><code>byte[] bytes = buffer.array();</code></li>
<li><code>//解码字节序列</code></li>
<li><code>byte[] bytes =  ...;</code></li>
<li><code>ByteBuffer bbuf =  ByteBuffer.wrap(bytes, offset, length);</code></li>
<li><code>CharBuffer cbuf = cset.decode(bbuf);</code></li>
<li><code>String str = cbuf.toString();</code></li>
</ol>
<p><strong>java.nio.charset.Charset 1.4</strong></p>
<ol>
<li><code>static  SortedMap availableCharsets()  //获取这个虚拟机可用的所有字符集。返回一个映射表，它的键是字符集的名字，值是字符集</code></li>
<li><code>static  Charset forName(String name)  //获取给定名字的字符集</code></li>
<li><code>Set aliases()  //返回这个字符集的别名集</code></li>
<li><code>ByteBuffer encode(String str)  //将给定的字符串编码为字节序列</code></li>
<li><code>CharBuffer decode(ByteBuffer buffer)  //解码给定的字节序列，无法识别的输入将被转换成Unicode的“替代字符”（’\uFFFD&#39;)</code></li>
</ol>
<p><strong>java.nio.ByteBuffer 1.4</strong></p>
<ol>
<li><code>byte[] array()  //返回这个缓冲区所管理的字节数组</code></li>
<li><code>static  ByteBuffer wrap(byte[] bytes)</code></li>
<li><code>static  ByteBuffer wrap(byte[] bytes,  int offset,  int length)  //返回管理给定的字节数组或给定字节数组的某个范围的字节缓冲区</code></li>
</ol>
<p><strong>java.nio.CharBuffer</strong></p>
<ol>
<li><code>char[] array()  //返回这个缓冲区所管理的码元数组</code></li>
<li><code>char charAt(int index)  //返回给定索引处的码元</code></li>
<li><code>String toString()  //返回由这个缓冲区所管理的码元构成的字符串</code></li>
</ol>
<p><strong>读写二进制数据</strong></p>
<p>DataInputStream类实现了DataInput接口</p>
<p><strong>java.io.DataInput 1.0</strong></p>
<ol>
<li><code>boolean readBoolean()</code></li>
<li><code>byte readByte()</code></li>
<li><code>char readChar()</code></li>
<li><code>double readDouble()</code></li>
<li><code>float readFloat()</code></li>
<li><code>int readInt()</code></li>
<li><code>long readLong()</code></li>
<li><code>short readShort()  //读入一个给定类型的值</code></li>
<li><code>void readFully(byte[] b)  //将字节读入到数组b中，其间阻塞直至所有字节都读入</code></li>
<li><code>void readFully(byte[] b,  int off,  int len)  //将字节读入到数组b中，其间阻塞直至所有字节都读入</code></li>
<li><code>String readUTF()  //读入由“修订过的UTF-8”格式的字符构成的字符串</code></li>
<li><code>int skipBytes(int n)  //跳过n个字节，其间阻塞直至所有字节都被跳过</code></li>
</ol>
<p><strong>java.io.DataOutput 1.0</strong></p>
<ol>
<li><code>void writeBoolean(boolean b)</code></li>
<li><code>void writeByte(int b)</code></li>
<li><code>void writeChar(int c)</code></li>
<li><code>void writeDouble(double d)</code></li>
<li><code>void writeFloat(float f)</code></li>
<li><code>void writeInt(int i)</code></li>
<li><code>void writeLong(long l)</code></li>
<li><code>void writeShort(int s)  //写出一个给定类型的值</code></li>
<li><code>void writeChars(String s)  //写出字符串中的所有字符</code></li>
<li><code>void writeUTF(String s)  //写出由“修订过的UTF-8”格式的字符构成的字符串</code></li>
</ol>
<p>随机访问文件</p>
<p>RandomAccessFile类可以在文件中的任何位置查找或写入数据，通过“r”或”rw”来指定。同时实现了DataInput和DataOutput接口</p>
<p><strong>java.io.RandomAccessFile 1.0</strong></p>
<ol>
<li><code>RandomAccessFile(String file,  String mode)</code></li>
<li><code>RandomAccessFile(File file,  String mode)  //file:要打开的文件，mode:&quot;r&quot;表示只读模式，&quot;rw&quot;表示读/写模式</code></li>
<li><code>long getFilePointer()  //返回文件指针的当前位置</code></li>
<li><code>void seek(long pos)  //将文件指针从文件的开始设置到pos个字节处</code></li>
<li><code>long length()  //返回文件按照字节来度量的长度</code></li>
</ol>
<p><strong>ZIP文档</strong></p>
<p>通读ZIP文件代码：</p>
<ol>
<li><code>ZipInputStream zin =  new  ZipInputStream(new  FileInputStream(zipname));</code></li>
<li><code>ZipEntry entry;</code></li>
<li><code>while  ((entry = zin.getNextEntry())  !=  null)</code></li>
<li><code>{</code></li>
<li><code>analyze entry;</code></li>
<li><code>read the contents of zin;</code></li>
<li><code>zin.closeEntry();</code></li>
<li><code>}</code></li>
<li><code>zin.close();</code></li>
</ol>
<p>写出ZIP文件代码：</p>
<ol>
<li><code>FileOutputStream fout =  new  FileOutputStream(&quot;test.zip&quot;);</code></li>
<li><code>ZipOutputStream zout =  new  ZipOutputStream(fout);</code></li>
<li><code>for all files</code></li>
<li><code>{</code></li>
<li><code>ZipEntry ze =  new  ZipEntry(filename);</code></li>
<li><code>zout.putNextEntry(ze);</code></li>
<li><code>send data to zout;</code></li>
<li><code>zout.closeEntry();</code></li>
<li><code>}</code></li>
<li><code>zout.close();</code></li>
</ol>
<p><strong>java.util.zip.ZipInputStream 1.1</strong></p>
<ol>
<li><code>ZipInputStream(InputStream in)  //创建一个ZipInputStream</code></li>
<li><code>ZipEntry getNextEntry()  //为下一项返回ZipEntry对象，否则没有更多的项时返回null</code></li>
<li><code>void closeEntry()  //关闭这个ZIP文件中当前打开的项</code></li>
</ol>
<p><strong>java.util.zip.ZipOutputStream 1.1</strong></p>
<ol>
<li><code>ZipOutputStream(OutputStream out)  //创建一个将压缩数据写出到指定的OutputStream的ZipOutputStream</code></li>
<li><code>void putNextEntry(ZipEntry ze)  //将给定的ZipEntry中的信息写出到流中，并定为用于写出数据的流，然后这些数据可以通过write()写出到这个流中</code></li>
<li><code>void closeEntry()  //关闭这个ZIP文件中当前打开的项</code></li>
<li><code>void setLevel(int level)  //设置后续的各个DEFAULTED项的默认压缩级别。</code></li>
<li><code>void setMethod(int method)  //设置用于这个ZipOutputStream的默认压缩方法，压缩方法：DEFLATED或STORED</code></li>
</ol>
<p><strong>java.util.zip.ZipEntry 1.1</strong></p>
<ol>
<li><code>ZipEntry(String name)  //这一项的名字</code></li>
<li><code>long getCrc()  //返回用于这个ZipEntry的CRC32校验和的值</code></li>
<li><code>String getName()  //返回这一项的名字</code></li>
<li><code>long getSize()  //返回这一项不被压缩的大小</code></li>
<li><code>boolean isDirectory()  //当这一项是目录时返回true</code></li>
<li><code>void setSize(long size)  //设置这一项的大小，当压缩方法是STORED时才必需</code></li>
<li><code>void setCrc(long crc)  //给这一项设置CRC32校验和，这个校验和是使用CRC32类计算的，STORED时必需</code></li>
</ol>
<p><strong>java.util.zip.ZipFile 1.1</strong></p>
<ol>
<li><code>ZipFile(String name)</code></li>
<li><code>ZipFile(File file)  //创建一个ZipFile，用于从给定的字符串或File对象中读入数据</code></li>
<li><code>Enumeration entries()  //返回一个Enumeration对象，它枚举了描述这个ZipFile中各个项的ZipEntry对象</code></li>
<li><code>ZipEntry getEntry(String name)  //返回给定名字所对应的项，或者在没有对应项的时候返回null</code></li>
<li><code>InputStream getInputStream(ZipEntry ze)  //返回用于给定项的InputStream</code></li>
<li><code>String getName()  //返回这个ZIP文件的路径</code></li>
</ol>
<p><strong>对象流与序列化</strong></p>
<p>对象序列化（object serialization)</p>
<p>ObjectInputStream和ObjectOutputStream类，readObject和writeObject方法</p>
<p>在对象流中存储或恢复的所有类都需要实现Serializable接口</p>
<p><strong>java.io.ObjectOutputStream 1.1</strong></p>
<ol>
<li><code>ObjectOutputStream(OutputStream out)  //创建一个ObjectOutputStream使得你可以将对象写出到指定的OutputStream</code></li>
<li><code>void writeObject(Object obj)  //写出指定的对象到ObjectOutputStream，这个方法将存储指定对象的类、类的签名以及这个类及其超类中所有非静态和非瞬时的域的值</code></li>
</ol>
<p><strong>java.io.ObjectInputStream 1.1</strong></p>
<ol>
<li><code>ObjectInputStream(InputStream in)  //创建一个ObjectInputStream用于从指定的InputSream中读回对象信息</code></li>
<li><code>Object readObject()  //从ObjectInputStream中读入一个对象</code></li>
</ol>
<p>对象流输出中包含所有对象的类型和数据域</p>
<p>每个对象都被赋予一个序列号</p>
<p>相同对象的重复出现将被存储为对这个对象的序列号的引用</p>
<p>修改默认的序列化机制</p>
<p>防止不应该被序列化的域被序列化，标记成transient</p>
<p>可序列化的类可以定义下列方法：</p>
<ol>
<li><code>private  void readObject(ObjectInputStream in)  throws  IOException,  ClassNotFoundException;</code></li>
<li><code>private  void writeObject(ObjectOutputStream out)  throws  IOException;</code></li>
</ol>
<p>之后，数据域就不再自动序列化，而是调用这些方法</p>
<p>类还可以定义它自己的机制，必须实现Externalizable接口，定义两个方法：</p>
<ol>
<li><code>public  void readExternal(ObjectInputStream in)  throws  IOException,  ClassNotFoundException;</code></li>
<li><code>public  void writeExternal(ObjectOutputStream out)  throws  IOException;</code></li>
</ol>
<p>序列化单例和类型安全的枚举</p>
<p>请记住向遗留代码中所有类型安全的枚举以及向所有支持单例设计模式的类中添加readResolve方法</p>
<p><strong>版本管理</strong></p>
<p>运行JDK中的单机程序serialver</p>
<p>serialver Employee</p>
<p>这个类的所有版本都需要定义</p>
<p>public static final long serialVersionUID = -184528436328947893L;</p>
<p><strong>文件管理</strong></p>
<p>File类</p>
<p>可以用FileNameFilter对象作为list方法的参数来减小列表长度，一个实现FileNameFilter接口的类需要定义accept方法</p>
<p>使用File类中存储在名为separator的静态实例域中的有关当前目录分隔符的信息可以得到系统恰当的分隔符</p>
<p><strong>java.io.File 1.0</strong></p>
<ol>
<li><code>boolean canRead()</code></li>
<li><code>boolean canWrite()</code></li>
<li><code>boolean canExecute()  //表明文件是否可读、可写或可执行</code></li>
<li><code>boolean setReadable(boolean state,  boolean ownerOnly)</code></li>
<li><code>boolean setWritable(boolean state,  boolean ownerOnly)</code></li>
<li><code>boolean setExecutable(boolean state,  boolean ownerOnly)  //设置这个文件的可读、可写或可执行状态。如果ownerOnly为true，状态设置只对文件拥有者有效，否则，对所有人有效。这些方法在设置状态成功后返回true</code></li>
<li><code>static  boolean createTempFile(String prefix,  String suffix)</code></li>
<li><code>static  boolean createTempFile(String prefix,  String suffix,  File directory)  //在系统的默认临时目录或给定目录中创建一个临时文件，并使用给定的前缀或后缀来生成文件名</code></li>
<li><code>boolean  delete()  //尝试删除这个文件</code></li>
<li><code>void deleteOnExit()  //请求在虚拟机关闭时将文件删除</code></li>
<li><code>boolean exists()  //如果目录存在则返回true</code></li>
<li><code>String getAbsolutePath()  //返回包含绝对路径名的字符串，应该用getCanonicalPath代替它</code></li>
<li><code>File getCanonicalFile()  //返回包含这个文件的规范路径名的File对象</code></li>
<li><code>String getCanonicalPath()  //返回包含这个文件的规范路径名的字符串</code></li>
<li><code>String getName()  //返回包含这个File对象的文件名的字符串（不包含路径）</code></li>
<li><code>String getParent()  //返回这个File对象的父亲名字的字符串</code></li>
<li><code>File getParentFile()  //返回这个File目录的父目录的File对象</code></li>
<li><code>String getPath()  //返回包含这个文件的路径名的字符串</code></li>
<li><code>boolean isDirectory()  //如果这个File对象表示一个文件而不是一个目录或一个设备，则返回true</code></li>
<li><code>boolean isFile()  //如果这个File对象表示一个文件而不是一个目录或一个设备，则返回true</code></li>
<li><code>boolean isHidden()  //如果这个File对象表示的是一个隐藏文件或目录，则返回true</code></li>
<li><code>long lastModified()  //返回这个文件最后被修改的时间（毫秒数）</code></li>
<li><code>String[] list()</code></li>
<li><code>String[] list(FilenameFilter filter)  //返回由这个File对象包含的满足过滤器条件的文件名和目录名构成的字符串数组</code></li>
<li><code>File[] listFiles()</code></li>
<li><code>File[] listFiles(FilenameFilter filter)  //返回由这个File对象包含的文件和目录所对应的File对象构成的数组</code></li>
<li><code>static  File[] listRoots()  //返回由所有可获得的文件根对应的File对象构成的数组</code></li>
<li><code>boolean createNewFile()  //自动创建一个由File对象给定名字的新文件</code></li>
<li><code>boolean mkdir()  //创建一个由这个File对象给定名字的子目录</code></li>
<li><code>boolean mkdirs()  //与mkdir不同，这个方法在必要时将创建父目录</code></li>
<li><code>boolean renameTo(File newName)  //如果文件名被修改，则返回true</code></li>
<li><code>boolean setLastModified(long time)  //设置这个文件的最后修改时间</code></li>
<li><code>boolean setReadOnly()  //将这个文件设置成只读</code></li>
<li><code>URL toURL()  //将这个File对象转换成一个文件的URL</code></li>
<li><code>long getTotalSpace()</code></li>
<li><code>long getFreeSpace()</code></li>
<li><code>long getUsableSpace()  //获得由File对象所描述的分区的总大小、未分配字节的数量和可用字节的数量</code></li>
</ol>
<p><strong>java.io.FilenameFilter 1.0</strong></p>
<ol>
<li><code>boolean accept(File dir,  String name)  //应该定义为在文件能够匹配过滤器标准时返回true</code></li>
</ol>
<p><strong>新IO</strong></p>
<p>内存映射文件</p>
<p><strong>java.io.FileInputStream 1.0</strong></p>
<ol>
<li><code>FileChannel getChannel()  //返回用于访问这个流的通道</code></li>
</ol>
<p><strong>java.io.FileOutputStream 1.0</strong></p>
<ol>
<li><code>FileChannel getChannel()  //返回用于访问这个流的通道</code></li>
</ol>
<p><strong>java.io.RandomAccessFile 1.0</strong></p>
<ol>
<li><code>FileChannel getChannel()  //返回用于访问这个流的通道</code></li>
</ol>
<p><strong>java.nio.channels.FileChannel 1.4</strong></p>
<ol>
<li><code>MappedByteBuffer map(FileChannel.MapMode mode,  long position,  long size)  //将文件的一个区域映射到内存中</code></li>
</ol>
<p><strong>java.nio.Buffer 1.4</strong></p>
<ol>
<li><code>boolean hasRemaining()  //如果当前的缓冲区位置没有达到这个缓冲区的界限位置则返回true</code></li>
<li><code>int limit()  //返回这个缓冲区的界限位置</code></li>
</ol>
<p><strong>java.nio.ByteBuffer 1.4</strong></p>
<ol>
<li><code>byte get()  //从当前位置获得一个字节，并将当前位置推到下一个字节</code></li>
<li><code>byte get(int index)  //从指定索引处获得一个字节</code></li>
<li><code>ByteBuffer put(byte b)  //向当前位置推入一个字节，并将当前位置推到下一个字节，返回对这个缓冲区的引用</code></li>
<li><code>ByteBuffer put(int index,  byte b)  //向指定索引处推入一个字节，返回对这个缓冲区的引用</code></li>
<li><code>ByteBuffer get(byte[] destination)</code></li>
<li><code>ByteBuffer get(byte[] destination,  int offset,  int length)  //用缓冲区的字节来填充字节数组，或者字节数组的某个区域，并将当前位置向前推读入的字节数个位置，如果缓冲区不够，不会读入任何字节，并抛出BufferUnderflowException</code></li>
<li><code>ByteBuffer put(byte[] source)</code></li>
<li><code>ByteBuffer put(byte[] source,  int offset,  int length)  //将字节数组中的所有字节或者给定区域的字节都推入缓冲区，并将当前位置向前推写出的字节数个位置</code></li>
<li><code>Xxx getXxx()</code></li>
<li><code>Xxx getXxx(int index)</code></li>
<li><code>ByteBuffer putXxx(xxx value)</code></li>
<li><code>ByteBuffer putXxx(int index, xxx value)  //获得或放置一个二进制数</code></li>
<li><code>ByteBuffer order(ByteOrder order)</code></li>
<li><code>ByteOrder order()  //设置或获得字节顺序，order的值是ByteOrder类的常量BIG_ENDIAN或LITTLE_ENDIAN中的一个</code></li>
</ol>
<p>缓冲区数据结构</p>
<p><strong>java.nio.Buffer 1.4</strong></p>
<ol>
<li><code>Buffer clear()  //通过将位置复位到0，并将界限复位到容量，使这个缓冲区为写出做好准备。返回this</code></li>
<li><code>Buffer flip()  //通过将界限设置为位置，并将位置复位到0，使这个缓冲区为读入做好准备，返回this</code></li>
<li><code>Buffer rewind()  //通过将读写位置复位到0，并保持极限不变，使这个缓冲区为重新读入相同的值做好准备，返回this</code></li>
<li><code>Buffer mark()  //将这个缓冲区的标记设置到读写位置，返回this</code></li>
<li><code>Buffer reset()  //将这个缓冲区的位置设置到标记，从而允许被标记的部分可以再次被读入或写出，返回this</code></li>
<li><code>int remaining()  //返回剩余可读入或可写出的值的数量，即界限与位置之间的差异</code></li>
<li><code>int position()  //返回这个缓冲区的位置</code></li>
<li><code>int capacity()  //返回这个缓冲区的容量</code></li>
</ol>
<p><strong>java.nio.CharBuffer 1.4</strong></p>
<ol>
<li><code>char get()</code></li>
<li><code>CharBuffer get(char[] destination)</code></li>
<li><code>CharBuffer get(char[] destination,  int offset,  int length)  //从这个缓冲区的位置处开始，获得一个char值，或者某个范围的char值，然后将位置向前推过所读入的字符，最后两个方法返回this</code></li>
<li><code>CharBuffer put(char c)</code></li>
<li><code>CharBuffer put(char[] source)</code></li>
<li><code>CharBuffer put(char[] source,  int offset,  int length)</code></li>
<li><code>CharBuffer put(String source)</code></li>
<li><code>CharBuffer put(CharBuffer source)  //从这个缓冲区的位置处开始，推入一个char值，或者某个范围的char值，然后将位置向前推过所写出的字符</code></li>
<li><code>CharBuffer read(CharBuffer destination)  //从这个缓冲区中获得char值，然后将它们推入目标缓冲区，直至达到目标缓冲区的界限</code></li>
</ol>
<p>文件加锁机制</p>
<p>文件加锁机制是依赖于操作系统的</p>
<p>文件锁是由整个Java虚拟机持有的。如果有两个程序是由同一个虚拟机启动的，那么它们不可能每一个都获得一个在同一个文件上的锁，当调用lock和tryLock方法时，如果虚拟机已经在同一个文件上持有了另一个重叠的锁，那么这两个方法将抛出OverlappingFileLockException</p>
<p><strong>java.nio.channels.FileChannel 1.4</strong></p>
<ol>
<li><code>FileLock lock()  //在整个文件上获得一个独占的锁，这个方法将阻塞直至获得锁</code></li>
<li><code>FileLock tryLock()  //在整个文件上获得一个独占的锁，或者在无法获得锁的情况下返回null</code></li>
<li><code>FileLock lock(long position,  long size,  boolean shared)</code></li>
<li><code>FileLock tryLock(long position,  long size,  boolean shared)  //在文件的一个区域上获得锁</code></li>
</ol>
<p><strong>java.nio.channels.FileLock 1.4</strong></p>
<ol>
<li><code>void release()  //释放这个锁</code></li>
</ol>
<p><strong>正则表达式</strong></p>
<p>语法</p>
<ol>
<li><code>String patternString =  &quot;]*)\\s*&gt;&quot;</code></li>
</ol>
<p>用法</p>
<ol>
<li><code>Pattern pattern =  Pattern.compile(patternString);</code></li>
<li><code>Matcher matcher = pattern.matcher(input);</code></li>
<li><code>if  (matcher.matches())  ...</code></li>
</ol>
<p><strong>java.util.regex.Pattern 1.4</strong></p>
<ol>
<li><code>static  Pattern compile(String expression)</code></li>
<li><code>static  Pattern compile(String expression,  int flags)  //把正则表达式字符串编译到一个用于快速处理匹配的模式对象中</code></li>
<li><code>Matcher matcher(CharSequence input)  //返回一个matcher对象，可以用它在输入定位模式的匹配</code></li>
<li><code>String[] split(CharSequence input)</code></li>
<li><code>String[] split(CharSequence input,  int limit)  //将输入分割成标号，其中模式指定了分隔符的形式</code></li>
</ol>
<p><strong>java.util.regex.Matcher 1.4</strong></p>
<ol>
<li><code>boolean matches()  //如果输入匹配模式，则返回true</code></li>
<li><code>boolean lookingAt()  //如果输入的开头匹配模式，则返回true</code></li>
<li><code>boolean find()</code></li>
<li><code>boolean find(int start)  //尝试查找下一个匹配，找到返回true</code></li>
<li><code>int start()</code></li>
<li><code>int end()  //返回当前匹配的开始索引和结尾之后的索引</code></li>
<li><code>String group()  //返回当前的匹配</code></li>
<li><code>int groupCount()  //返回输入模式中的群组数量</code></li>
<li><code>int start(int groupIndex)</code></li>
<li><code>int end(int groupIndex)  //返回当前匹配中给定群组的开始和结尾之后的位置</code></li>
<li><code>String group(int groupIndex)  //返回匹配给定群组的字符串</code></li>
<li><code>String replaceAll(String replacement)</code></li>
<li><code>String replaceFirst(String replacement)  //返回从匹配器输入获得的通过将所有匹配或第一个匹配用替换字符串替换之后的字符串</code></li>
<li><code>Matcher reset()</code></li>
<li><code>Matcher reset(CharSequence input)  //复位匹配器的状态。第二个方法将使匹配器作用于另一个不同的输入，两个方法都返回this</code></li>
</ol>
<p><strong>第二章–XML———————————————-</strong></p>
<p><strong>XML文档</strong></p>
<p>文档头</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</code></pre><p>文档类型定义（DTD，Document Type Definition）</p>
<pre><code>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN&quot; &quot;http:java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;
</code></pre><p>通常属性只应该在修改值的解释时使用，而不是在指定值时使用</p>
<p>字符引用：&amp;#233 （十进制）; &amp;#xD9（十六进制）</p>
<p>实体引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&amp;lt; 小于</div><div class="line">&amp;gt; 大于</div><div class="line">&amp;amp; &amp;</div><div class="line">&amp;quot; 引号</div><div class="line">&amp;apos; 省略号</div></pre></td></tr></table></figure></p>
<p>CDATA部分: 用&lt;![CDATA[和]]&gt;来限定其界限，可用来包含含有&lt;、&gt;、&amp;之类字符的字符串<br>处理指令：用&lt;?和?&gt;限定界限<br>注释：用&lt;!-和–&gt;限定界限</p>
<p><strong>解析XML文档</strong></p>
<p>DOM（Document Object Model，文档对象模型）解析器：树型解析器</p>
<p>用于XML的简单API（Simple API for XML, SAX)解析器：流机制解析器</p>
<p>读入一个XML文档</p>
<ol>
<li><code>DocumentBuilderFactory factory =  DocumentBuilderFactory.newInstance();</code></li>
<li><code>DocumentBuilder builder = factory.newDocumentBuilder();</code></li>
<li><code>File f =  ...</code></li>
<li><code>Document doc = builder.parse(f);</code></li>
</ol>
<p><strong>javax.xml.parsers.DocumentBuilderFactory 1.4</strong></p>
<ol>
<li><code>static  DocumentBuilderFactory newInstance()  //返回DocumentBuilderFactory类的一个实例</code></li>
<li><code>DocumentBuilder newDocumentBuilder()  //返回DocumentBuilder类的一个实例</code></li>
</ol>
<p><strong>javax.xml.parsers.DocumentBuilder 1.4</strong></p>
<ol>
<li><code>Document parse(File f)</code></li>
<li><code>Document parse(String url)</code></li>
<li><code>Document parse(InputStream in)  //解析来自给定文件、URL或输入流的XML文档，返回解析后的文档</code></li>
</ol>
<p><strong>org.w3c.dom.Document 1.4</strong></p>
<ol>
<li><code>Element getDocumentElement()  //返回文档的根元素</code></li>
</ol>
<p><strong>org.w3c.dom.Element 1.4</strong></p>
<ol>
<li><code>String getTagName()  //返回元素的名字</code></li>
<li><code>String getAttribute(String name)  //返回给定名字的属性值，没有该属性时返回空字符串</code></li>
</ol>
<p><strong>org.w3c.dom.Node 1.4</strong></p>
<ol>
<li><code>NodeList getChildNodes()  //返回包含所有子元素节点的节点列表</code></li>
<li><code>Node getFirstChild()</code></li>
<li><code>Node getLastChild()  //获取该节点的第一个或最后一个子节点，在该节点没有子节点时返回null</code></li>
<li><code>Node getNextSibling()</code></li>
<li><code>Node getPreviousSibling()  //获取该节点的下一个或上一个兄弟节点，在该节点没有兄弟节点时返回null</code></li>
<li><code>Node getParentNode()  //获取该节点的父结点，在该节点是文档节点时返回null</code></li>
<li><code>NamedNodeMap getAttributes()  //返回含有描述该节点所有属性的Attr节点的映射表</code></li>
<li><code>String getNodeName()  //返回该节点的名字，当该结点是Attr节点时，该名字就是属性名</code></li>
<li><code>String getNodeValue()  //返回该节点的值，当该节点是Attr节点时，该值就是属性值</code></li>
</ol>
<p><strong>org.w3c.dom.CharacterData 1.4</strong></p>
<ol>
<li><code>String getData()  //返回存储在节点中的文本</code></li>
</ol>
<p><strong>org.w3c.dom.NodeList 1.4</strong></p>
<ol>
<li><code>int getLength()  //返回列表中的节点数</code></li>
<li><code>Node item(int index)  //返回给定索引号的节点</code></li>
</ol>
<p><strong>org.w3c.dom.NamedNodeMap 1.4</strong></p>
<ol>
<li><code>int getLength()  //返回该节点映射表中的节点数</code></li>
<li><code>Node item(int index)  //返回给定索引号的节点</code></li>
</ol>
<p><strong>验证XML文档</strong></p>
<p>DTD</p>
<pre><code>&lt;!ELEMENT font (name,size)&gt;
</code></pre><p>XML Schema （xsd文件）</p>
<pre><code>&lt;xsd:element name=&quot;font&quot;&gt;
    &lt;xsd:sequence&gt;
        &lt;xsd:element name=&quot;name&quot; type=&quot;xsd:string&quot; /&gt;
        &lt;xsd:element name=&quot;size&quot; type=&quot;xsd:int&quot; /&gt;
    &lt;/xsd:sequence&gt;
&lt;/xsd:element&gt;
</code></pre><p>文档类型定义：<br>将DTD纳入XML文档中</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE configuration [
    &lt;!ELEMENT configuration ...&gt;
    more rules
    ...
]&gt;
&lt;configuration&gt;
...
&lt;/configuration&gt;
</code></pre><p>将DTD存储在外面</p>
<pre><code>&lt;!DOCTYPE configuration SYSTEM &quot;config.dtd&quot;&gt;
</code></pre><p>或者</p>
<pre><code>&lt;!DOCTYPE configuration SYSTEM &quot;http://myserver.com/config.dtd&quot;&gt;
</code></pre><p>如果使用DTD的相对URL（比如”config.dtd”），需要给解析器一个文件或URL对象，而不是InputStream，如果必须从一个输入流来解析，请提供一个实体渲染器<br>来源于SGML的用于识别“众所周知的”DTD的机制，如</p>
<pre><code>&lt;!DOCTYPE web-app
  PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN&quot; &quot;http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot; &gt;
</code></pre><p>如果使用的是DOM解析器，想要支持公共标识符，需要调用DocumentBuilder类的setEntityResolver方法来安装EntityResolver接口的某个实现类的一个对象，该接口只有一个方法：resolveEntity</p>
<p>ELEMENT规则</p>
<p>E*    0或多个E<br>E+    1或多个E<br>E？    0或1个E<br>E1|E2|…|En    E1, E2, …, En中的一个<br>E1, E2, …, En    E1随后是E2，…，En</p>
<p>#PCDATA    文本<br>(#PCDATA|E1|E2|…|En)*    0或多个任意顺序的文本和E1，E2，…，En（混合式内容）<br>ANY    允许任意子元素<br>EMPTY    不允许有子元素</p>
<p>元素的规范可以包含嵌套的和复杂的正则表达式，如</p>
<pre><code>&lt;!ELEMENT chapter (intro, (heading, (para | image | table | note)+)+)
</code></pre><p>描述合法元素属性的语法规则：</p>
<pre><code>&lt;!ATTLIST element attribute type default&gt;
</code></pre><p>两个属性规范范例：</p>
<pre><code>&lt;!ATTLIST font style (plain|bold|italic|bold-italic) &quot;plain&quot;&gt;
&lt;!ATTLIST size unit CDATA #IMPLIED&gt;
</code></pre><p>使用DTD验证输入</p>
<ol>
<li><code>factory.setValidating(true);</code></li>
<li><code>factory.setIgnoringElementContentWhitespace(true);</code></li>
</ol>
<p>在验证时，应该安装一个错误处理器，即一个实现了ErrorHandler接口的对象</p>
<p><strong>javax.xml.parsers.DocumentBuilder 1.4</strong></p>
<ol>
<li><code>void setEntityResolver(EntityResolver resolver)  //设置解析器，来定位要分析的XML文档中引用的实体</code></li>
<li><code>void setErrorHandler(ErrorHandler handler)  //设置报告解析过程中出现的错误和警告的处理器</code></li>
</ol>
<p><strong>org.xml.sax.EntityResolver 1.4</strong></p>
<ol>
<li><code>public  InputSource resolveEntity(String publicID,  String systemID)  //返回包含被指定ID引用数据的一个输入源，或者，当解析器不知道如何解析某个特定名字时，返回null。如果没有提供公共ID，那么参数publicID可以为null</code></li>
</ol>
<p><strong>org.xml.sax.InputSource 1.4</strong></p>
<ol>
<li><code>InputSource(InputStream in)</code></li>
<li><code>InputSource(Reader in)</code></li>
<li><code>InputSource(String systemID)  //根据流、读入器、或系统ID（通常是相对或绝对URL）构建输入源</code></li>
</ol>
<p><strong>org.xml.sax.ErrorHandler 1.4</strong></p>
<ol>
<li><code>void fatalError(SAXParseException exception)</code></li>
<li><code>void error(SAXParseException exception)</code></li>
<li><code>void warning(SAXParseException exception)  //覆盖这些方法以提供处理器，对致命错误、非致命错误和警告进行处理</code></li>
</ol>
<p><strong>org.xml.sax.SAXParseException 1.4</strong></p>
<ol>
<li><code>int getLineNumber()</code></li>
<li><code>int getColumnNumber()  //返回引起异常的已处理的输入信息末尾的行号和列号</code></li>
</ol>
<p><strong>javax.xml.parsers.DocumentBuilderFactory 1.4</strong></p>
<ol>
<li><code>boolean isValidating()</code></li>
<li><code>void setValidating(boolean value)  //获取和设置工厂的validating属性，当设为true时，工厂生成的解析器会验证它们的输入信息</code></li>
<li><code>boolean isIgnoringElementContentWhiteSpace(boolean value)  //获取和设置工厂的ignoringElementContentWhiteSpace属性，当设为true时，工厂生成的解析器会忽略没有混合内容（即元素与#PCDATA混合）的元素节点之间的空白</code></li>
</ol>
<p><strong>XML Schema</strong></p>
<p>如果要在文档中引用Schema文件，需要在根元素中加上属性</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;configuration xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:noNamespaceSchemaLocation=&quot;config.xsd&quot;&gt;
...
&lt;/configuration&gt;
</code></pre><p>解析带有Schema的XML文件和解析带有DTD的文件相似，但有3点差别：<br>//必须打开对命名空间的支持</p>
<pre><code>factory.setNamespaceAware(true);
</code></pre><p>//必须执行如下步骤</p>
<pre><code>final String JAXP_SCHEMA_LANGUAGE = &quot;http://java.sun.com/xml/jaxp/properties/schemaLanguage&quot;;
final String W3C_XML_SCHEMA = &quot;http://www.w3.org/2001/XMLSchema&quot;;
factory.setAttribute(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);
</code></pre><p><strong>使用XPath来定位信息</strong></p>
<p>XPath表达式/configuration/database/username</p>
<p>使用@操作符可以得到属性值，如</p>
<p>/gridbag/row[1]/cell[1]/@anchor</p>
<p><strong>javax.xml.xpath.XPathFactory 5.0</strong></p>
<ol>
<li><code>static  XPathFactory newInstance()  //返回XPathFactory实例来创建XPath对象</code></li>
<li><code>XPath newXpath()  //构建XPath对象来计算XPath表达式</code></li>
</ol>
<p><strong>javax.xml.xpath.XPath 5.0</strong></p>
<ol>
<li><code>String evaluate(String expression,  Object startingPoint)  /从给定的起点计算表达式，起点可以是一个节点或节点列表，如果结果是一个节点或节点集，则返回的字符串包含所有文本节点子元素的数据</code></li>
<li><code>Object evaluate(String expression,  Object startingPoint,  QName resultType)  //从给定的起点计算表达式，起点可以是一个节点或节点列表。ResultType是XPathConstants类的常量STRING, NODE, NODESET, NUMBER或BOOLEAN之一</code></li>
</ol>
<p><strong>使用命名空间（URI）</strong></p>
<p>HTTP URL格式最常用</p>
<p>xmlns:alias=”namespaceURI” 用于定义命名空间和别名</p>
<p>打开命名空间处理特性</p>
<ol>
<li><code>factory.setNamespaceAware(true);</code></li>
</ol>
<p>由getNodeName和getTagName等方法返回带有别名前缀的限定名</p>
<p><strong>org.w3c.dom.Node 1.4</strong></p>
<ol>
<li><code>String getLocalName()  //返回本地名（不带别名前缀），或者在解析器不支持命名空间时返回null</code></li>
<li><code>String getNamespaceURI()  //返回命名空间URI，或者在解析器不支持命名空间时返回null</code></li>
</ol>
<p><strong>javax.xml.parsers.DocumentBuilderFactory 1.4</strong></p>
<ol>
<li><code>boolean isNamespaceAware()</code></li>
<li><code>void setNamespaceAware(boolean value)  //获取或设置工厂的namespaceAware属性</code></li>
</ol>
<p><strong>流机制解析器</strong></p>
<p>使用SAX解析器（事件回调）</p>
<p>在使用SAX解析器时，需要一个处理器来定义不同的解析器事件的事件动作，ContentHandler接口定义了若干个回调方法，如startElement, endElement, characters, startDocument和endDocument</p>
<ol>
<li><code>SAXParserFactory factory =  SAXParserFactory.newInstance();</code></li>
<li><code>SAXParser parser = factory.newSAXParser();</code></li>
<li><code>parser.parse(source, handler);</code></li>
</ol>
<p>处理器属于DefaultHandler的一个子类，DefaultHandler类为4个接口定义了空的方法：ContentHandler, DTDHandler, EntityResolver, ErrorHandler</p>
<p><strong>javax.xml.parsers.SAXParserFactory 1.4</strong></p>
<ol>
<li><code>static  SAXParserFactory newInstance()  //返回SAXParserFactory类的一个实例</code></li>
<li><code>SAXParser newSAXParser()  //返回SAXParser类的一个实例</code></li>
<li><code>boolean isNamespaceAware()</code></li>
<li><code>void setNamespaceAware(boolean value)  //获取和设置工厂的namespaceAware属性</code></li>
<li><code>boolean isValidating()</code></li>
<li><code>void setValidating(boolean value)  //获取和设置工厂的validating属性</code></li>
</ol>
<p><strong>javax.xml.parsers.SAXParser 1.4</strong></p>
<ol>
<li><code>void parse(File f,  DefaultHandler handler)</code></li>
<li><code>void parse(String url,  DefaultHandler handler)</code></li>
<li><code>void parse(InputStream in,  DefaultHandler handler)  //解析来自给定文件、URL或输入流的XML文档，并把解析事件报告给指定的处理器</code></li>
</ol>
<p><strong>org.xml.sax.ContentHandler 1.4</strong></p>
<ol>
<li><code>void startDocument()</code></li>
<li><code>void endDocument()</code></li>
<li><code>void startElement(String uri,  String lname,  String qname,  Attributes attr)</code></li>
<li><code>void endElement(String uri,  String lname,  String qname)  //在元素的起始或结束时被调用</code></li>
<li><code>void characters(char[] data,  int start,  int length)  //解析器报告字符数据时被调用</code></li>
</ol>
<p><strong>org.xml.sax.Attributes 1.4</strong></p>
<ol>
<li><code>int getLength()  //返回存储在该属性集合中属性数量</code></li>
<li><code>String getLocalName(int index)  //返回给定索引的属性的本地名（无别名前缀），或当不支持命名空间特性时返回空字符串</code></li>
<li><code>String getURI(int index)  //返回给定索引的属性的命名空间URI</code></li>
<li><code>String getQName(int index)  //返回给定索引的属性的限定名</code></li>
<li><code>String getValue(int index)</code></li>
<li><code>String getValue(String qname)</code></li>
<li><code>String getValue(String uri,  String lname)  //根据给定索引、限定名或命名空间URI+本地名，返回属性值，该值不存在时返回null</code></li>
</ol>
<p>使用StAX解析器（提供解析事件的迭代器）</p>
<ol>
<li><code>InputStream in = url.openStream();</code></li>
<li><code>XMLInputFactory factory =  XMLInputFactory.newInstance();</code></li>
<li><code>XMLStreamReader parser = factory.createXMLStreamReader(in);</code></li>
<li><code>while  (parser.hasNext())  {</code></li>
<li><code>int event = parser.next();</code></li>
<li><code>Call parser methods to obtain event details</code></li>
<li><code>}</code></li>
</ol>
<p><strong>javax.xml.stream.XMLInputFactory 6</strong></p>
<ol>
<li><code>static  XMLInputFactory newInstance()  //返回XMLInputFactory类的一个实例</code></li>
<li><code>void setProperty(String name,  Object value)  //设置这个工厂的属性，或者在要设置的属性不支持设置成给定值时，抛出IllegalArgumentException</code></li>
<li><code>XMLStreamReader createXMLStreamReader(InputStream in)</code></li>
<li><code>XMLStreamReader createXMLStreamReader(InputStream in,  String characterEncoding)</code></li>
<li><code>XMLStreamReader createXMLStreamReader(Reader in)</code></li>
<li><code>XMLStreamReader createXMLStreamReader(Source in)  //创建一个从给定的流、阅读器或JAXP源读入的解析器</code></li>
</ol>
<p><strong>javax.xml.stream.XMLStreamReader 6</strong></p>
<ol>
<li><code>boolean hasNext()  //如果有另一个解析事件则返回true</code></li>
<li><code>int next()  //将解析器的状态设置为下一个解析事件，并返回下列常量之一：START_ELEMENT、CHARACTERS、START_DOCUMENT、END_DOCUMENT、CDATA、COMMENT、SPACE（可忽略的空白字符）、PROCESSING_INSTRUCTION、ENTITY_REFERENCE、DTD</code></li>
<li><code>boolean isStartElement()</code></li>
<li><code>boolean isEndElement()</code></li>
<li><code>boolean isCharacters()</code></li>
<li><code>boolean isWhiteSpace()  //如果当前事件是一个开始元素、结束元素、字符数据或空白字符，返回true</code></li>
<li><code>QName getName()</code></li>
<li><code>String getLocalName()  //获取在START_ELEMENT或END_ELEMENT事件中的元素的名字</code></li>
<li><code>String getText()  //返回一个CHARACTERS、COMMENT或CDATA事件，或一个ENTITY_REFERENCE的替换值，或者一个DTD的内部子集所对应的字符</code></li>
<li><code>int getAttributeCount()</code></li>
<li><code>QName getAttributeName(int index)</code></li>
<li><code>String getAttributeLocalName(int index)</code></li>
<li><code>String getAttributeValue(int index)</code></li>
<li><code>String getAttributeValue(String namespaceURI,  String name)  //只要当前事件是START_ELEMENT，则获取给定属性的值，如果namespaceURI为null，则不检查名字空间</code></li>
</ol>
<p><strong>生成XML文档</strong></p>
<p>用文档的内容构建一棵DOM树</p>
<ol>
<li><code>Document doc = builder.newDocument();</code></li>
<li><code>Element rootElement = doc.createElement(rootName);</code></li>
<li><code>Element childElement = doc.createElement(childName);</code></li>
<li><code>Text textNode = doc.createTextNode(textContents);</code></li>
<li><code>doc.appendChild(rootElement);</code></li>
<li><code>rootElement.appendChild(childElement);</code></li>
<li><code>childElement.appendChild(textNode);</code></li>
<li><code>rootElement.setAttribute(name, value);</code></li>
</ol>
<p>但是DOM API目前还不支持DOM树写到输出流，需要使用可扩展的格式页转换（XSLT) API</p>
<ol>
<li><code>//construct the &quot;do nothing&quot; transformation</code></li>
<li><code>Transformer t =  TransformerFactory.newInstance().newTransformer();</code></li>
<li><code>//set output properties to get a DOCTYPE node</code></li>
<li><code>t.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemIdentifier);</code></li>
<li><code>t.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, publicIdentifier);</code></li>
<li><code>//set indentation</code></li>
<li><code>t.setOutputProperty(OutputKeys.INDENT,  &quot;yes&quot;);</code></li>
<li><code>t.setOutputProperty(OutputKeys.METHOD,  &quot;xml&quot;);</code></li>
<li><code>//apply the &quot;do nothing&quot; transformation and send the output to a file</code></li>
<li><code>t.transform(new  DOMSource(doc),  new  StreamResult(new  FileOutputStream(file)));</code></li>
</ol>
<p><strong>javax.xml.parsers.DocumentBuilder 1.4</strong></p>
<ol>
<li><code>Document newDocument()  //返回一个空文档</code></li>
</ol>
<p><strong>org.w3c.dom.Document 1.4</strong></p>
<ol>
<li><code>Element createElement(String name)  //返回具有给定名字的元素</code></li>
<li><code>Text createTextNode(String data)  //返回具有给定数据的文本节点</code></li>
</ol>
<p><strong>org.w3c.dom.Node 1.4</strong></p>
<ol>
<li><code>Node appendChild(Node child)  //将一个节点附加到该节点的子节点列表，返回该节点</code></li>
</ol>
<p><strong>org.w3c.dom.Element 1.4</strong></p>
<ol>
<li><code>void setAttribute(String name,  String value)  //将有给定名字的属性设置为指定的值</code></li>
<li><code>void setAttributeNS(String uri,  String qname,  String value)  //将带有给定命名空间URI和限定名的属性设置为指定的值</code></li>
</ol>
<p><strong>javax.xml.transform.TransformerFactory 1.4</strong></p>
<ol>
<li><code>static  TransformerFactory newInstance()  //返回TransformerFactory类的一个实例</code></li>
<li><code>transformer newTransformer()  //返回Transformer类的一个实例，带有标识符或“无操作”的转换</code></li>
</ol>
<p><strong>javax.xml.transform.Transformer 1.4</strong></p>
<ol>
<li><code>void setOutputProperty(String name,  String value)  //设置输出属性</code></li>
<li><code>void transform(Source from,  Result to)  //转换一个XML文档</code></li>
</ol>
<p><strong>javax.xml.transform.dom.DOMSource 1.4</strong></p>
<ol>
<li><code>DOMSource(Node n)  //根据指定的节点构建一个源。通常，n是文档节点</code></li>
</ol>
<p><strong>javax.xml.transform.stream.StreamResult 1.4</strong></p>
<ol>
<li><code>StreamResult(File f)</code></li>
<li><code>StreamResult(OutputStream out)</code></li>
<li><code>StreamResult(Writer out)</code></li>
<li><code>StreamResult(String systemID)根据文件、流、写入程序或系统ID（通常是相对或绝对URL）来构建数据流结果</code></li>
</ol>
<p>使用StAX写XML文档</p>
<ol>
<li><code>XMLOutputFactory factory =  XMLOutputFactory.newInstance();</code></li>
<li><code>XMLStreamWriter writer = factory.createXMLStreamWriter(out);</code></li>
<li><code>writer.writeStartDocument();</code></li>
<li><code>writer.writeStartElement(name);</code></li>
<li><code>writer.writeAttribute(name, value);</code></li>
<li><code>writer.writeCharacters(text);</code></li>
<li><code>writer.writeEndElement();</code></li>
<li><code>writer.writeEmptyElement(name);</code></li>
<li><code>writer.writeEndDocument();</code></li>
</ol>
<p><strong>javax.xml.stream.XMLOutputFactory 6.</strong></p>
<ol>
<li><code>static  XMLOutputFactory newInstance()  //返回这个XMLOutputFactory类的一个实例</code></li>
<li><code>XMLStreamWriter createXMLStreamWriter(OutputStream in)</code></li>
<li><code>XMLStreamWriter createXMLStreamWriter(OutputStream in,  String characterEncoding)</code></li>
<li><code>XMLStreamWriter createXMLStreamWriter(Writer in)</code></li>
<li><code>XMLStreamWriter createXMLStreamWriter(Result in)  //创建写入给定流、写出器和JAXP结果的写出器</code></li>
</ol>
<p><strong>javax.xml.stream.XMLStreamWriter 6</strong></p>
<ol>
<li><code>void writeStartDocument()</code></li>
<li><code>void writeStartDocument(String xmlVersion)</code></li>
<li><code>void writeStartDocument(String encoding,  String xmlVersion)  //在文档的顶部写入XML处理指令</code></li>
<li><code>void setDefaultNamespace(String namespaceURI)</code></li>
<li><code>void setPrefix(String prefix,  String namespaceURI)</code></li>
<li><code>设置默认的命名空间，或具有前缀的命名空间，作用域仅为当前元素</code></li>
<li><code>void writeStartElement(String localName)</code></li>
<li><code>void writeStartElement(String namespaceURI,  String localName)  //写出一个开始标签，其中namespaceURI将用相关联的前缀来代替</code></li>
<li><code>void writeEndElement()  //关闭当前元素</code></li>
<li><code>void writeEndDocument()  //关闭所有打开的元素</code></li>
<li><code>void writeEmptyElement(String localName)</code></li>
<li><code>void writeEmptyElement(String namespaceURI,  String localName)  //写出一个自闭合的标签</code></li>
<li><code>void writeAttribute(String localName,  String value)</code></li>
<li><code>void writeAttribute(String namespaceURI,  String localName,  String value)  //写出一个用于当前元素的属性</code></li>
<li><code>void writeCharacters(String text)  //写出字符数据</code></li>
<li><code>void writeCData(String text)  //写出CDATA块</code></li>
<li><code>void writeDTD(String dtd)  //写出dtd字符串，该字串需要包含一个DOCTYPE声明</code></li>
<li><code>void writeComment(String comment)  //写出一个注释</code></li>
<li><code>void close()  //关闭这个写出器</code></li>
</ol>
<p><strong>XSL转换（XSLT）</strong></p>
<p>典型模板：</p>
<pre><code>&lt;xsl:template match=&quot;/staff/employee&quot;&gt;
  &lt;tr&gt;&lt;xsl:apply-templates/&gt;&lt;/tr&gt;
&lt;/xsl:template&gt;
</code></pre><p>处理属性值：</p>
<pre><code>&lt;xsl:template match=&quot;/staff/employee/hiredate&quot;&gt;
  &lt;td&gt;&lt;xsl:value-of select=&quot;@year&quot;/&gt;-&lt;xsl:value-of select=&quot;@month&quot;/&gt;-&lt;xsl:value-of select=&quot;@day&quot;/&gt;&lt;/td&gt;
&lt;/xsl:template&gt;
</code></pre><p>实现XML转换</p>
<ol>
<li><code>File styleSheet =  new  File(filename);</code></li>
<li><code>StreamSource styleSource =  new  StreamSource(styleSheet);</code></li>
<li><code>Transformer t =  TransformerFactory.newInstance().newTransformer(styleSource);</code></li>
<li><code>t.transform(source, result);</code></li>
</ol>
<p>Source接口有3个实现类：DOMSource, SAXSource, StreamSource</p>
<p>Result接口有3个实现类：DOMResult，SAXResult，StreamResult</p>
<p><strong>javax.xml.transform.TransformerFactory 1.4</strong></p>
<ol>
<li><code>transformer newTransformer(Source stylesheet)  //返回一个transformer类的实例，用来从指定的源中读取样式表</code></li>
</ol>
<p><strong>javax.xml.transform.stream.StreamSource 1.4</strong></p>
<ol>
<li><code>StreamSource(File f)</code></li>
<li><code>StreamSource(InputStream in)</code></li>
<li><code>StreamSource(Reader in)</code></li>
<li><code>StreamSource(String stystemID)  //根据一个文件、流、阅读器或系统ID（通常是相对或绝对URL）来构建一个数据流源</code></li>
</ol>
<p><strong>javax.xml.transform.sax.SAXSource 1.4</strong></p>
<ol>
<li><code>SAXSource(XMLReader reader,  InputSource source)  //构建一个SAX数据源，以便从给定输入源获取数据，并使用给定的阅读器来解析输入数据</code></li>
</ol>
<p><strong>org.xml.sax.XMLReader 1.4</strong></p>
<ol>
<li><code>void setContentHandler(ContentHandler handler)  //设置在输入被解析时会被告知解析事件的处理器</code></li>
<li><code>void parse(InputSource source)  //根据给定输入源解析输入数据，并将解析事件发送到内容处理器</code></li>
</ol>
<p><strong>javax.xml.transform.dom.DOMResult 1.4</strong></p>
<ol>
<li><code>DOMResult(Node n)  //根据给定结点构建一个数据源，通常n是一个新文档节点</code></li>
</ol>
<p><strong>org.xml.sax.helpers.AttributesImpl 1.4</strong></p>
<ol>
<li><code>void addAtrribute(String uri,  String lname,  String qname,  String type,  String value)  //将一个属性添加到该属性集合</code></li>
<li><code>void clear()  //删除属性集合中的所有属性</code></li>
</ol>
<p><strong>第三章–网络———————————————-</strong></p>
<p><strong>套接字Socket</strong></p>
<p>套接字超时设置</p>
<p><strong>java.net.Socket 1.0</strong></p>
<ol>
<li><code>Socket(String host,  int port)  //构建一个套接字，用来连接给定的主机和端口</code></li>
<li><code>InputStream getInputStream()</code></li>
<li><code>OutputStream getOutputStream()  //获取可以从套接字中读取数据的流，以及可以向套接字写出数据的流</code></li>
<li><code>Socket()  //创建一个还未被连接的套接字</code></li>
<li><code>void connect(SocketAddress address)  //将该套接字连接到给定的地址</code></li>
<li><code>void connect(SocketAddress address,  int timeoutInMilliSeconds)  //将套接字连接到给定的地址，如果在给定的时间内没有响应，则返回</code></li>
<li><code>void setSoTimeout(int timeoutInMilliseconds)  //设置该套接字上读请求的阻塞时间，如果超出时间，则抛出一个InterruptedIOException异常</code></li>
<li><code>boolean isConnected()  //如果该套接字已被连接，则返回true</code></li>
<li><code>boolean isClosed()  //如果该套接字已被关闭，返回true</code></li>
</ol>
<p>因特网地址</p>
<ol>
<li><code>InetAddress address =  InetAddress.getByName(&quot;time-A.timefreq.bldrdoc.gov&quot;);</code></li>
<li><code>byte[] addressBytes = address.getAddress();</code></li>
</ol>
<p><strong>java.net.InetAddress 1.0</strong></p>
<ol>
<li><code>static  InetAddress getByName(String host)</code></li>
<li><code>static  InetAddress[] getAllByName(String host)  //为给定的主机名，创建一个InetAddress对象，或者一个包含了该主机名所对应的所有因特网地址的数组</code></li>
<li><code>static  InetAddress getLocalHost()  //为本地主机创建一个InetAddress对象</code></li>
<li><code>byte[] getAddress()  //返回一个包含数字型地址的字节数组</code></li>
<li><code>String getHostAddress()  //返回一个由十进制数组成的字符串，各数字间用圆点符号隔开</code></li>
<li><code>String getHostName()  //返回主机名</code></li>
</ol>
<p><strong>实现服务器</strong></p>
<ol>
<li><code>ServerSocket s =  new  ServerSocket(8189);</code></li>
<li><code>Socket incoming = s.accept();</code></li>
<li><code>InputStream inStream = incoming.getInputStream();</code></li>
<li><code>OutputStream outStream = incoming.getOutputStream();</code></li>
<li><code>Scanner in =  new  Scanner(inStream);</code></li>
<li><code>PrintWriter out =  new  PrintWriter(outStream,  true  /* autoFlush */);</code></li>
<li><code>out.println(&quot;Hello!Enter BYE to exit.“);</code></li>
<li><code>String line = in.nextLine();</code></li>
<li><code>out.println(&quot;Echo:&quot;  + line);</code></li>
<li><code>if  (line.trim().equals(&quot;BYE&quot;)) done =  true;</code></li>
<li><code>incoming.close();</code></li>
</ol>
<p><strong>java.net.ServerSocket 1.0</strong></p>
<ol>
<li><code>ServerSocket(int port)  //创建一个监控端口的服务器套接字</code></li>
<li><code>Socket accept()  //等待连接，阻塞当前线程直到建立连接为止</code></li>
<li><code>void close()  //关闭服务器套接字</code></li>
</ol>
<p>为多个客户端服务</p>
<ol>
<li><code>while  (true)  {</code></li>
<li><code>Socket incoming = s.accept();</code></li>
<li><code>Runnable r =  new  ThreadedEchoHandler(incoming);</code></li>
<li><code>Thread t =  new  Thread(r);</code></li>
<li><code>t.start();</code></li>
<li><code>}</code></li>
</ol>
<p>半关闭</p>
<p><strong>java.net.Socket 1.0</strong></p>
<ol>
<li><code>void shutdownOutput()  //将输出流设为“流结束”</code></li>
<li><code>void shutdownInput()  //将输入流设为“流结束”</code></li>
<li><code>boolean isOutputShutdown()  //如果输出已被关闭返回true</code></li>
<li><code>boolean isInputShutdown()  //如果输入已被关闭，返回true</code></li>
</ol>
<p><strong>可中断套接字</strong></p>
<p>java.nio包的特性：SocketChannel类，通道（channel)没有相关联的流，需要调用Buffer对象来实现ReadableByteChannel和WritableByteChannel接口声明的read和write方法</p>
<ol>
<li><code>SocketChannel channel =  SocketChannel.open(new  InetSocketAddress(host, port));</code></li>
<li><code>Scanner in =  new  Scanner(channel);</code></li>
<li><code>OutputStream outStream =  Channels.newOutputStream(channel);</code></li>
</ol>
<p>如果线程发生中断，不会阻塞，而是会抛出异常</p>
<p><strong>java.net.InetSocketAddress 1.4</strong></p>
<ol>
<li><code>InetSocketAddress(String hostname,  int port)  //通过主机和端口参数创建一个地址对象，并在创建过程中解析主机名，如果主机名不能被解析，那么该地址对象的unresolved属性被设为true</code></li>
<li><code>boolean isUnresolved()  //如果不能解析该地址对象，返回true</code></li>
</ol>
<p><strong>java.nio.channels.SocketChannel 1.4</strong></p>
<ol>
<li><code>static  SocketChannel open(SocketAddress address)  //打开一个套接字通道，并将其连接到远程地址</code></li>
</ol>
<p><strong>java.nio.channels.Channels 1.4</strong></p>
<ol>
<li><code>static  InputStream newInputStream(ReadableByteChannel channel)  //创建一个输入流，用以从指定的通道读取数据</code></li>
<li><code>static  OutputStream newOutputStream(WritableByteChannel channel)  //创建一个输出流，用以向指定的通道写入数据</code></li>
</ol>
<p><strong>发送E-mail</strong></p>
<ol>
<li><code>Socket s =  new  Socket(&quot;mail.yourserver.com&quot;,  25);</code></li>
<li><code>PrintWriter out =  new  PrintWriter(s.getOutputStream));</code></li>
</ol>
<p>信息规范：</p>
<pre><code>HELO sending host
MAIL FROM: &lt;sender e-mail address&gt;
RCPT TO: &lt;recipient e-mail address&gt;
DATA
mail message
(any number of lines)
.
QUIT
</code></pre><p>SMTP规范规定，每一行都要以\r再紧跟一个\n来结尾</p>
<p><strong>建议URL连接</strong></p>
<p>URL和URI</p>
<ol>
<li><code>URL url =  new URL(urlString);</code></li>
<li><code>InputStream inStream = url.openStream();</code></li>
<li><code>Scanner in =  new  Scanner(inStream);</code></li>
</ol>
<p>URI句法：</p>
<p>[scheme:]schemeSpecificPart[#fragment]</p>
<p>一个分层URI的schemeSpecificPart具有以下结构：</p>
<p>[//authority][path][?query]</p>
<p>对基于服务器的URI，authority部分采用以下形式：</p>
<p>[user-info@]host[:port]</p>
<ol>
<li><code>relative = base.relativize(combined);</code></li>
<li><code>combined = base.resolve(relative);</code></li>
</ol>
<p>使用URLConnection获取信息</p>
<p>1. 调用URL类中的openConnection方法获得URLConnection对象</p>
<ol>
<li><code>URLConnection connection = url.openConnection()</code></li>
</ol>
<p>2. 使用以下方法来设置任意的请求属性</p>
<ol>
<li><code>setDoInput</code></li>
<li><code>setDoOutput</code></li>
<li><code>setIfModifiedSince</code></li>
<li><code>setUseCaches</code></li>
<li><code>setAllowUserInteraction</code></li>
<li><code>setRequestProperty</code></li>
<li><code>setConnectTimeout</code></li>
<li><code>setReadTimeout</code></li>
</ol>
<p>3. 调用connect方法连接远程资源</p>
<ol>
<li><code>connection.connect();</code></li>
</ol>
<p>4. 建立连接后，可以查询头信息</p>
<ol>
<li><code>getContentType</code></li>
<li><code>getContentLength</code></li>
<li><code>getContentEncoding</code></li>
<li><code>getDate</code></li>
<li><code>getExpiration</code></li>
<li><code>getLastModified</code></li>
</ol>
<p>5. 访问资源数据</p>
<ol>
<li><code>getInputStream</code></li>
</ol>
<p>setRequestProperty方法，设置“名-值”对</p>
<ol>
<li><code>String input = username +  &quot;:&quot;  + password;</code></li>
<li><code>String encoding = base64Encode(input);</code></li>
<li><code>connection.setRequestProperty(&quot;Authorization&quot;,  &quot;Basic &quot;  + encoding);</code></li>
</ol>
<p><strong>java.net.URL 1.0</strong></p>
<ol>
<li><code>InputStream openStream()  //打开一个用于读取资源数据的输入流</code></li>
<li><code>URLConnection openConnection()  //返回一个URLConnection对象，该对象负责管理与资源之间的连接</code></li>
</ol>
<p><strong>java.net.URLConnection 1.0</strong></p>
<ol>
<li><code>void setDoInput()  //如果doInput为true，那么用户可以接收来自该URLConnection的输入</code></li>
<li><code>void setDoOutput(boolean doOutput)</code></li>
<li><code>boolean getDoOutput(boolean doOutput)  //如果doOutput为true，那么用户可以将输出发送到该URLConnection</code></li>
<li><code>void setIfModifiedSince(long time)</code></li>
<li><code>long getIfModifiedSince()  //属性ifModifiedSince用于配置URLConnection对象，使它只获取那些自从某个给定时间以来被修改过的数据</code></li>
<li><code>void setUseCaches(boolean useCaches)</code></li>
<li><code>boolean getUseCaches()  //如果useCaches为true，那么数据可以从本地缓存中得到，URLConnection本身并不维护这个缓存，缓存必须由浏览器之类的外部程序提供</code></li>
<li><code>void setAllowUserInteraction(boolean allowUserInteraction)</code></li>
<li><code>boolean getAllowUserInteraction()  //如果为true，那么可以查询用户的口令</code></li>
<li><code>void setConnectTimeout(int timeout)</code></li>
<li><code>int getConnectionTimeout()  //设置或得到连接超时时限</code></li>
<li><code>void setRequestProperty(String key,  String value)  //设置请求头的一个字段</code></li>
<li><code>Map&lt;String,  List&lt;String&gt;&gt; getRequestProperties()  //返回请求头属性的一个映射表，相同的键对应的所有值被放置在同一个映射表中</code></li>
<li><code>void connect()  //连接远程资源并获取响应头信息</code></li>
<li><code>Map&lt;String,  List&lt;String&gt;&gt;  Map getHeaderFields()  //返回响应的一个映射表，相同的键对应的所有值被放置在同一个映射表中</code></li>
<li><code>String getHeaderFieldKey(int n)  //得到响应头第n个字段的键，如果n等于0或大于响应头字段的总数返回null值</code></li>
<li><code>String getHeaderField(int n)  //得到响应头第n个字段的值</code></li>
<li><code>int getContentLength()  //如果知道内容长度，则返回该长度值，否则返回-1</code></li>
<li><code>String getContentType()  //获取内容的类型，比如text/plain或image/gif</code></li>
<li><code>String getContentEncoding()  //获取内容的编码，比如gzip</code></li>
<li><code>long getDate()</code></li>
<li><code>long getExpiration()</code></li>
<li><code>long getLastModified()  //获取创建日期、过期日以及最后一次被修改的日期</code></li>
<li><code>InputStream getInputStream()</code></li>
<li><code>OutputStream getOutputStream()  //返回从资源读取信息或向资源写入信息的流</code></li>
<li><code>Object getContent()  //选择适当的内容处理器，以便读取资源数据并将它转换成对象。该方法不能用于读取诸如text/plain或image/gif之类的标准内容类型，除非安装了自己的内容处理器</code></li>
</ol>
<p><strong>提交表单数据</strong></p>
<p>GET和POST命令，向Web服务器发送信息</p>
<p>URL编码模式编码，参数规则：</p>
<p>保留字符A-Z、a-z、0-9以及 . - * _</p>
<p>用+字符替换所有的空格</p>
<p>将其他所有字符编码为UTF-8，并将每个字节都编码为%后面紧跟一个两位的十六进制数字</p>
<p>使用POST命令的方法：</p>
<ol>
<li><code>URL url =  new URL(&quot;http://host/script&quot;);</code></li>
<li><code>URLConnection connection = url.openConnection();</code></li>
<li><code>connection.setDoOutput(true);</code></li>
<li><code>PrintWriter out =  new  PrintWriter(connection.getOutputStream());</code></li>
<li><code>out.print(name1 +  &quot;=&quot;  +  URLEncoder.encode(value1,  &quot;UTF-8&quot;)  +  &quot;&amp;&quot;);</code></li>
<li><code>out.print(name2 +  &quot;=&quot;  +  URLEncoder.encode(value2,  &quot;UTF-8&quot;));</code></li>
<li><code>out.close();</code></li>
</ol>
<p><strong>java.net.HttpURLConnection 1.0</strong></p>
<ol>
<li><code>InputStream getErrorStream()  //返回一个流，通过这个流可以读取Web服务器的错误信息</code></li>
</ol>
<p><strong>java.net.URLEncoder 1.0</strong></p>
<ol>
<li><code>static  String encode(String s,  String encoding)  //采用指定的字符编码模式对字符串s进行编码，并返回它的URL编码形式</code></li>
</ol>
<p><strong>java.net.URLDecoder 1.2</strong></p>
<ol>
<li><code>static  String decode(String s,  String encoding)  //采用指定编码模式对已编码字符串s进行解码，并返回结果</code></li>
</ol>
<p><strong>第三章–数据库编程———————————————-</strong></p>
<p><strong>JDBC的典型用法</strong></p>
<p>客户端（可视化表示） —HTTP、RMI—&gt; 中间层（业务逻辑） —JDBC-数据库协议-&gt;数据库服务器 </p>
<p>JDBC URL一般语法：</p>
<p>jdbc:subprotocol:other stuff</p>
<p>注册驱动器类</p>
<p>Class.forName(“org.postgresql.Driver”);</p>
<p>或者</p>
<p>java -Djdbc.drivers=org.postgresql.Driver <em>ProgramName</em></p>
<p>或者</p>
<p>System.setProperty(“jdbc.drivers”, “org.postgresql.Driver”);</p>
<p>连接到数据库</p>
<ol>
<li><code>String url =  &quot;jdbc:postgresql:COREJAVA&quot;;</code></li>
<li><code>String username =  &quot;dbuser&quot;;</code></li>
<li><code>String password =  &quot;scret&quot;;</code></li>
<li><code>Connection conn =  DriverManager.getConnection(url, username, password);</code></li>
</ol>
<p><strong>java.sql.DriverManager 1.1</strong></p>
<ol>
<li><code>static  Connection getConnection(String url,  String user,  String password)  //建立一个到指定数据库的连接，并返回一个Connection对象</code></li>
</ol>
<p><strong>执行SQL语句</strong></p>
<p><strong>java.sql.Connection 1.1</strong></p>
<ol>
<li><code>Statement createStatement()  //创建一个Statement对象，用以执行不带参数的SQL查询和更新</code></li>
<li><code>void close()  //用于立即关闭当前的连接以及释放由它所创建的JDBC资源</code></li>
</ol>
<p><strong>java.sql.Statement 1.1</strong></p>
<ol>
<li><code>ResultSet executeQuery(String sqlQuery)  //执行给定字符串中的SQL语句，并返回一个用于查看查询结果的ResultSet对象</code></li>
<li><code>int executeUpdate(String sqlStatement)  //执行字符串中指定的INSERT、UPDATE或DELETE等SQL语句，也可以执行CREATE TABLE等语句，返回受影响的记录总数</code></li>
<li><code>boolean execute(String sqlStatement)  //执行字符串中指定的SQL语句，可能会产生多个结果集和更新数。如果第一个执行结果是结果集，则返回true，反之返回false。调用getResultSet或getUpdateCount方法可以得到第一个执行结果</code></li>
<li><code>ResultSet getResultSet()  //返回前一条查询语句的结果集，如果前一条语句未产生结果集则返回null值，对于每一条执行过的语句，该方法只能被调用一次</code></li>
<li><code>void close()  //关闭Statement对象以及它所对应的结果集</code></li>
<li><code>boolean isClosed()  //如果语句被关闭返回true</code></li>
</ol>
<p><strong>java.sql.ResultSet 1.1</strong></p>
<ol>
<li><code>boolean next()  //将结果集中的当前行向前移动一行。如果已经到达最后一行的后面，返回false，注意初始情况必须调用该方法才能转到第一行</code></li>
<li><code>Xxx getXxx(int columnNumber)</code></li>
<li><code>Xxx getXxx(String columnName)  //用给定的列序号或列标签返回该列的值，并将之转换成指定类型</code></li>
<li><code>int findColumn(String columnName)  //根据给定的列名，返回该列的序号</code></li>
<li><code>void close()  //立即关闭当前的结果集</code></li>
<li><code>boolean isClosed()  //如果语句被关闭，则返回true</code></li>
</ol>
<p>管理连接、语句和结果集</p>
<p>分析SQL异常</p>
<p>每个SQLException都有一个由多个SQLException对象构成的链，这些对象可以通过getNextException方法获取</p>
<p><strong>java.sql.SQLException 1.1</strong></p>
<ol>
<li><code>SQLException getNextException()  //返回链接到该SQL异常的下一个SQL异常，或者在到达链尾时返回null</code></li>
<li><code>Iterator&lt;Throwable&gt; iterator()  //获取迭代器，可以迭代链接的SQL异常和它们的成因</code></li>
<li><code>String getSQLState()  //获取“SQL状态”，即标准化的错误代码</code></li>
<li><code>int getErrorCode()  //获取提供商相关的错误代码</code></li>
</ol>
<p><strong>java.sql.Warning 1.1</strong></p>
<ol>
<li><code>SQLWarning getNextWarning()  //返回链接到该警告的下一个警告，或者在到达链尾时返回null</code></li>
</ol>
<p><strong>java.sql.Connection 1.1</strong></p>
<p><strong>java.sql.Statement 1.1</strong></p>
<p><strong>java.sql.ResultSet 1.1</strong></p>
<ol>
<li><code>QLWarning getWarnings()</code></li>
<li><code>SQLWarning getWarnings()  //返回未处理警告中的第一个，或者在没有未处理警告时返回null</code></li>
</ol>
<p><strong>java.sql.DataTruncation 1.1</strong></p>
<ol>
<li><code>boolean getParameter()  //如果在参数上进行了数据截断，则返回true，如果在列上进行了数据截断返回false</code></li>
<li><code>int getIndex()  //返回被截断的参数和列的索引</code></li>
<li><code>int getDataSize()  //返回应该被传输的字节数量，或者在该值未知的情况下返回-1</code></li>
<li><code>int getTransferSize()  //返回实际被传输的字节数量，或者在该值未知的情况下返回-1</code></li>
</ol>
<p>元数据</p>
<ol>
<li><code>ResultSet result = stat.getResultSet();</code></li>
<li><code>ResultSetMetaData metaData = result.getMetaData();</code></li>
<li><code>int columnCount = metaData.getColumnCount();</code></li>
<li><code>metaData.getColumnLabel(i);</code></li>
</ol>
<p>预备语句</p>
<p>占位符?</p>
<ol>
<li><code>PreparedStatement  PublisherQueryStat  = conn.prepareStatement(publisherQuery);</code></li>
<li><code>publisherQueryStat.setString(1, publisher);</code></li>
<li><code>ResultSet rs = publisherQueryStat.executeQuery();</code></li>
</ol>
<p><strong>java.sql.Connection 1.1</strong></p>
<ol>
<li><code>PreparedStatement prepareStatement(String sql)  //返回一个含预编译语句的PreparedStatement对象</code></li>
</ol>
<p><strong>java.sql.PreparedStatement 1.1</strong></p>
<ol>
<li><code>void setXxx(int n,  Xxx x)  //设置第n个参数值为x</code></li>
<li><code>void clearParameters()  //清除预备语句中的所有当前参数</code></li>
<li><code>ResultSet executeQuery()  //执行预备SQL查询，并返回一个ResultSet对象</code></li>
<li><code>int executeUpdate()  //执行预备SQL语句INSERT UPDATE或DELETE，返回受影响的记录数，如果执行CREATE TABLE,返回0</code></li>
</ol>
<p>读写LOB</p>
<p>二进制大对象称为BLOB，字符型大对象称为CLOB</p>
<p>获取一张图像：</p>
<ol>
<li><p>PreparedStatement stat = conn.preapareStatement(“SELECT Cover FROM BookCovers WHERE ISBN=?”);</p>
</li>
<li><p><code>stat.set(1, isbn);</code></p>
</li>
<li><code>ResultSet result = stat.executeQuery();</code></li>
<li><code>if  (result.next())  {</code></li>
<li><code>Blob coverBlob = result.getBlob(1);</code></li>
<li><code>Image coverImage =  ImageIO.read(coverBlob.getInputstream());</code></li>
<li><code>}</code></li>
</ol>
<p>存储一张图像：</p>
<ol>
<li><code>Blob coverBlob = connection.createBlob();</code></li>
<li><code>int offset =  0;</code></li>
<li><code>OutputStream out = coverBlob.setBinaryStream(offset);</code></li>
<li><code>ImageIO.write(coverImage,  &quot;PNG&quot;, out);</code></li>
<li><code>PreparedStatement stat = conn.prepareStatement(&quot;INSET INTO Cover VALUES (?, ?)&quot;);</code></li>
<li><code>stat.set(1, isbn);</code></li>
<li><code>stat.set(2, coverBlob);</code></li>
<li><code>stat.executeUpdate();</code></li>
</ol>
<p><strong>java.sql.ResultSet 1.1</strong></p>
<ol>
<li><code>Blob getBlob(int columnIndex)</code></li>
<li><code>Blob getBlob(String columnLabel)</code></li>
<li><code>Clob getClob(int columnIndex)</code></li>
<li><code>Clob getClob(String columnLabel)  //获取给定列的BLOB或CLOB</code></li>
</ol>
<p><strong>java.sql.Blob 1.2</strong></p>
<ol>
<li><code>long length()  //获取该BLOB的长度</code></li>
<li><code>byte[] getBytes(long startPosition,  long length)  //获取该BLOB中给定范围的数据</code></li>
<li><code>InputStream getBinaryStream()</code></li>
<li><code>InputStream getBinaryStream(long startPosition,  long length)  //返回一个输入流，用于读取该BLOB中全部或给定范围的数据</code></li>
<li><code>OutputStream setBinaryStream(long startPosition)  //返回一个输出流，用于从给定位置开始写入该BLOB</code></li>
</ol>
<p><strong>java.sql.Clob 1.4</strong></p>
<ol>
<li><code>long length()  //获取该CLOB中的字符总数</code></li>
<li><code>String getSubString(long startPosition,  long length)  //获取该CLOB中给定范围的字符</code></li>
<li><code>Reader getCharacterStream()</code></li>
<li><code>Reader getCharacterStream(long startPosition,  long length)  //返回一个读入器（而不是流），用于读取CLOB中全部或给定范围的数据</code></li>
<li><code>Writer setCharacterStream(long startPosition)  //返回一个写出器（而不是流），用于从给定位置开始写入该CLOB</code></li>
</ol>
<p><strong>java.sql.Connection 1.1</strong></p>
<ol>
<li><code>Blob createBlob()</code></li>
<li><code>Clob createClob()  //创建一个空的BLOB或CLOB</code></li>
</ol>
<p>SQL转义</p>
<p>转义主要用于下列特性：</p>
<p>日期和时间字面常量</p>
<p>调用标量函数</p>
<p>调用存储过程</p>
<p>外连接</p>
<p>在LIKE子句中的转义字符</p>
<p>多结果集</p>
<p>遍历execute所有结果：</p>
<ol>
<li><code>boolean done =  false;</code></li>
<li><code>boolean isResult = stmt.execute(command);</code></li>
<li><code>while  (!done)  {</code></li>
<li><code>if  (isResult)  {</code></li>
<li><code>ResultSet result = stmt.getResultSet();</code></li>
<li><code>do something with result</code></li>
<li><code>}  else  {</code></li>
<li><code>int updateCount = stmt.getUpdateCount();</code></li>
<li><code>if  (updateCount &gt;=  0)</code></li>
<li><code>do something with updateCount</code></li>
<li><code>else</code></li>
<li><code>done =  true;</code></li>
<li><code>}</code></li>
<li><code>isResult = stmt.getMoreResults();</code></li>
<li><code>}</code></li>
</ol>
<p><strong>java.sql.Statement 1.1</strong></p>
<ol>
<li><code>boolean getMoreResults()  //获取该语句的下一个结果集，如果存在返回true</code></li>
</ol>
<p>获取自动生成键</p>
<ol>
<li><code>stmt.executeUpdate(insertStatement,  Statement.RETURN_GENERATED_KEYS);</code></li>
<li><code>ResultSet rs = stmt.getGeneratedKeys();</code></li>
<li><code>if  (rs.next())  {</code></li>
<li><code>int key = rs.getInt(1);</code></li>
<li><code>...</code></li>
<li><code>}</code></li>
</ol>
<p><strong>java.sql.Statement 1.1</strong></p>
<ol>
<li><code>boolean execute(String statement,  int autogenerated)</code></li>
<li><code>int executeUpdate(String statement,  int autogenerated)  //如果autogenerated被设置为Statement.RETURN_GENERATED_KEYS，并且该语句是一条INSERT语句，那么第一列中就是自动生成的键</code></li>
</ol>
<p><strong>可滚动和可更新的结果集</strong></p>
<ol>
<li><code>Statement stat = conn.createStatement(type, concurrency);</code></li>
<li><code>PreparedStatement stat = conn.prepareStatement(command, type, concurrency);</code></li>
</ol>
<p>ResultSet类的type值</p>
<p>| TYPE_FORWARD_ONLY | 结果集不能滚动 |<br>| TYPE_SCROLL_INSENSITIVE | 结果集可以滚动，但对数据库变化不敏感 |<br>| TYPE_SCROLL_SENSITIVE | 结果集可以滚动，且对数据库变化敏感 |</p>
<p>ResultSet类的Concurrency值</p>
<p>| CONCUR_READ_ONLY | 结果集不能用于更新数据库 |<br>| CONCUR_UPDATE | 结果集可以用于更新数据库 |</p>
<p>需要用getType和getConcurrency方法先检查结果集的功能再使用，否则可能抛出SQLException异常</p>
<p>在结果集上的滚动</p>
<ol>
<li><code>if  (rs.previous())  ...</code></li>
</ol>
<p>将游标向后或向前移动多行</p>
<ol>
<li><code>rs.relative(n);</code></li>
</ol>
<p>将游标设置到指定的行号上</p>
<ol>
<li><code>rs.absolute(n);</code></li>
<li><code>int currentRow = rs.getRow();</code></li>
</ol>
<p>获得可更新的结果集</p>
<ol>
<li><code>Statement stat = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,  ResultSet.CONCUR_UPDATABLE);</code></li>
</ol>
<p>迭代遍历所有结果并更新相关内容</p>
<ol>
<li><code>String query =  &quot;SELECT * FROM Books&quot;;</code></li>
<li><code>ResultSet rs = stat.executeQuery(query);</code></li>
<li><code>while  (rs.next())  {</code></li>
<li><code>if  (...)  {</code></li>
<li><code>double increase =  ...</code></li>
<li><code>double price = rs.getDouble(&quot;Price&quot;);</code></li>
<li><code>rs.updateDouble(&quot;Price&quot;, price + increase);</code></li>
<li><code>rs.updateRow();</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>添加新行</p>
<ol>
<li><code>rs.moveToInsertRow();</code></li>
<li><code>rs.updateString(&quot;Title&quot;, title);</code></li>
<li><code>rs.updateString(&quot;ISBN&quot;, isbn);</code></li>
<li><code>rs.updateString(&quot;Publisher_Id&quot;, pubid);</code></li>
<li><code>rs.updateDouble(&quot;Price&quot;, price);</code></li>
<li><code>rs.insertRow();</code></li>
<li><code>rs.moveToCurrentRow();</code></li>
</ol>
<p>删除行</p>
<ol>
<li><code>rs.deleteRow();</code></li>
</ol>
<p><strong>java.sql.Connection 1.1</strong></p>
<ol>
<li><code>Statement createStatement(int type,  int concurrency)</code></li>
<li><code>PreparedStatement prepareStatement(String command,  int type,  int concurrency)  //创建一个语句或预备语句，且该语句可以产生指定类型和并发模式的结果集</code></li>
</ol>
<p><strong>java.sql.ResultSet 1.1</strong></p>
<ol>
<li><code>int getType()  //返回结果集的类型</code></li>
<li><code>int getConcurrency()  //返回结果集的并发设置</code></li>
<li><code>boolean previous()  //把光标移动到前一行</code></li>
<li><code>int getRow()  //得到当前行的序号</code></li>
<li><code>boolean absolute(int r)  //移动光标到第r行</code></li>
<li><code>boolean relative(int d)  //将光标移动d行，如果d为负数，则光标向后移动，如果光标位于某一行上，返回true</code></li>
<li><code>boolean first()</code></li>
<li><code>boolean last()  //移动光标到第一行或最后一行</code></li>
<li><code>void beforeFirst()</code></li>
<li><code>void afterLast()  //移动光标到第一行之前或最后一行之后的位置</code></li>
<li><code>boolean isFirst()</code></li>
<li><code>boolean isLast()  //测试光标是否在第一行或最后一行</code></li>
<li><code>boolean isBeforeFirst()</code></li>
<li><code>boolean isAfterLast()  //测试光标是否在第一行之前或最后一行之后的位置</code></li>
<li><code>void moveToInsertRow()  //移动光标到插入行</code></li>
<li><code>void moveToCurrentRow()  //将光标从插入行移回到调用moveToInsertRow之前所在那一行</code></li>
<li><code>void insertRow()  //将插入行上的内容插入到数据库和结果集中</code></li>
<li><code>void deleteRow()  //从数据库和结果集中删除当前行</code></li>
<li><code>void updateXxx(int column,  Xxx data)</code></li>
<li><code>void updateXxx(String columnName,  Xxx data)  //更新结果中当前行上的某个字段值</code></li>
<li><code>void updateRow()  //将当前行的更新信息发送到数据库</code></li>
<li><code>void cancelRowUpdates()  //撤销对当前行的更新</code></li>
</ol>
<p><strong>java.sql.DatabaseMetaData 1.1</strong></p>
<ol>
<li><code>boolean supportsResultSetType(int type)  //如果数据库支持给定类型的结果集，则返回true</code></li>
<li><code>boolean supportsResultSetConcurrency(int type,  int concurrency)  //如果数据库支持给定类型和并发模式的结果集，则返回true</code></li>
</ol>
<p><strong>行集</strong></p>
<p>CachedRowSet</p>
<p>WebRowSet</p>
<p>FilteredRowSet</p>
<p>JoinRowSet</p>
<p>JdbcRowSet</p>
<p>被缓存的行集</p>
<p>使用一个结果集来填充CachedRowSet对象</p>
<ol>
<li><code>ResultSet result =  ...;</code></li>
<li><code>CachedRowSet crs =  new com.sun.rowset.CachedRowSetImpl();</code></li>
<li><code>crs.populate(result);</code></li>
<li><code>conn.close();</code></li>
</ol>
<p>或者可以让CachedRowSet对象自动创建一个数据库连接并将查询结果填充到行集，最后断开连接</p>
<ol>
<li><code>crs.setURL(&quot;jdbc:derby://localhost:1527/COREJAVA&quot;);</code></li>
<li><code>crs.setUsername(&quot;dbuser&quot;);</code></li>
<li><code>crs.setPassword(&quot;secret&quot;);</code></li>
<li><code>crs.setCommand(&quot;SELECT * FROM Books WHERE PUBLISHER = ?&quot;);</code></li>
<li><code>crs.setString(1, publisherName);</code></li>
<li><code>crs.execute();</code></li>
</ol>
<p>指定每一页尺寸</p>
<ol>
<li><code>CachedRowSet crs =  ...;</code></li>
<li><code>crs.setCommand(command);</code></li>
<li><code>crs.setPageSize(20);</code></li>
<li><code>...</code></li>
<li><code>crs.execute();</code></li>
<li><code>crs.nextPage();</code></li>
</ol>
<p>将修改写回到数据库中</p>
<ol>
<li><code>crs.acceptChanges(conn);</code></li>
<li><code>或</code></li>
<li><code>crs.acceptChanges();  //这个方法只有设置连接数据库所需信息才有效</code></li>
</ol>
<p><strong>javax.sql.RowSet 1.4</strong></p>
<ol>
<li><code>String getURL()</code></li>
<li><code>void setURL(String url)  //获取或设置数据库的URL</code></li>
<li><code>String getUsername()</code></li>
<li><code>void setUsername(String username)  //获取或设置连接数据库所需的用户名</code></li>
<li><code>String getPassword()</code></li>
<li><code>void setPassword(String password)  //获取或设置连接数据库所需的密码</code></li>
<li><code>String getCommand()</code></li>
<li><code>void setCommand(String command)  //获取或设置向行集中填充数据时需要执行的命令</code></li>
<li><code>void execute()  //通过执行使用setCommand方法设置的命令集来填充行集。为了使驱动管理器可以获得连接，必须事先设定URL、用户名和密码</code></li>
</ol>
<p><strong>javax.sql.rowset.CachedRowSet 5.0</strong></p>
<ol>
<li><code>void execute(Connection conn)  //通过执行使用setCommand方法设置的命令集来填充行集，该方法使用给定的连接，并负责关闭它</code></li>
<li><code>void populate(ResultSet result)  //将指定的结果集中的数据填充到被缓存的行集中</code></li>
<li><code>String getTableName()</code></li>
<li><code>void setTableName(String tableName)  //获取或设置数据库表名称，填充被缓存的行集时所需的数据来自于该表</code></li>
<li><code>int getPageSize()</code></li>
<li><code>void setPageSize(int size)  //获取和设置页的尺寸</code></li>
<li><code>boolean nextPage()</code></li>
<li><code>boolean previousPage()  //加载下一页或上一页，如果要加载的页存在，返回true</code></li>
<li><code>void acceptChanges()</code></li>
<li><code>void acceptChanges(Connection conn)  //重新连接数据库，并写回行集中修改过的数据，如果因为数据库中的数据已经被修改而导致无法写回行集中的数据，该方法可能会抛出SyncProviderException异常</code></li>
</ol>
<p><strong>元数据</strong></p>
<p>描述数据库或其组成部分的数据称为元数据</p>
<p>获取数据库所有表名（第三列是表名）</p>
<ol>
<li><code>DatabaseMetaData meta = conn.getMetaData();</code></li>
<li><code>ResultSet mrs = meta.getTables(null,  null,  null,  new  String[]  {&quot;TABLE&quot;});</code></li>
<li><code>while  (mrs.next())</code></li>
<li><code>tableNames.addItem(mrs.getString(3));</code></li>
</ol>
<p>通过ResultSetMetaData提供结果集的相关信息，如每一列的名称、类型和字段宽度：</p>
<ol>
<li><code>ResultSet mrs = stat.executeQuery(&quot;SELECT * FROM &quot;  + tableName);</code></li>
<li><code>ResultSetMetaData meta = mrs.getMetaData();</code></li>
<li><code>for  (int i =  1; i &lt;= meta.getColumnCount(); i++)  {</code></li>
<li><code>String columnName = meta.getColumnLabel(i);</code></li>
<li><code>int columnWidth = meta.getColumnDisplaySize(i);</code></li>
<li><code>...</code></li>
<li><code>}</code></li>
</ol>
<p><strong>java.sql.Connection 1.1</strong></p>
<ol>
<li><code>DatabaseMetaData getMetaData()  //返回一个DatabaseMetaData对象，该对象封装了有关数据库连接的元数据</code></li>
</ol>
<p><strong>java.sql.DatabaseMetaData 1.1</strong></p>
<ol>
<li><code>ResultSet getTables(String catalog,  String schemaPattern,  String tableNamePattern,  String types[])  //返回某个目录中的所有表的描述，该目录必须符合给定的模式（schema）、表名字模式以及类型标准</code></li>
<li><code>int getJDBCMajorVersion()</code></li>
<li><code>int getJDBCMinorVersion()  //返回建立数据库连接的JDBC驱动程序的主版本号和次版本号</code></li>
<li><code>int getMaxConnections()  //返回可同时连接到数据库的最大连接数</code></li>
<li><code>int getMaxStatements()  //返回单个数据库连接允许同时打开的最大语句数</code></li>
</ol>
<p><strong>java.sql.ResultSet 1.1</strong></p>
<ol>
<li><code>ResultSetMetaData getMetaData()  //返回与当前ResultSet对象中的列相关的元数据</code></li>
</ol>
<p><strong>java.sql.ResultSetMetaData 1.1</strong></p>
<ol>
<li><code>int getColumnCount()  //返回当前ResultSet对象中的列数</code></li>
<li><code>int getColumnDisplaySize(int column)  //返回给定列序号的列的最大宽度</code></li>
<li><code>String getColumnLabel(int column)  //返回该列所建议的名称</code></li>
<li><code>String getColumnName(int column)  //返回指定的列序号所对应的列名</code></li>
</ol>
<p><strong>事务</strong></p>
<p>回滚（rollback）</p>
<p>默认为自动提交模式（autocommit mode）</p>
<ol>
<li><code>conn.setAutoCommit(false);</code></li>
<li><code>Statement stat = conn.createStatement();</code></li>
<li><code>stat.executeUpdate(command1);</code></li>
<li><code>stat.executeUpdate(command2);</code></li>
<li><code>...</code></li>
<li><code>conn.commit();</code></li>
<li><code>如果出现错误，请调用：</code></li>
<li><code>conn.rollback();</code></li>
</ol>
<p>保存点</p>
<ol>
<li><code>Statement stat = conn.createStatement();  //start transaction; rollback() goes here</code></li>
<li><code>stat.executeUpdate(command1);</code></li>
<li><code>Savepoint svpt = conn.setSavepoint();  //set savepoint; rollback(svpt) goes here</code></li>
<li><code>stat.executeUpdate(command2);</code></li>
<li><code>if  (...) conn.rollback(svpt);  //undo effect of command2</code></li>
<li><code>...</code></li>
<li><code>conn.commit();</code></li>
<li><code>conn.releaseSavepoint(svpt);</code></li>
</ol>
<p>批量更新</p>
<p>使用DatabaseMetaData类中的supportsBatchUpdates方法可以获知数据库是否支持这种特性</p>
<p>可以是INSERT、UPDATE、DELETE等操作，也可以是CREATE TABLE和DROP TABLE，但不可以是SELECT命令，会抛异常</p>
<ol>
<li><code>Statement stat = conn.createStatement();</code></li>
<li><code>String command =  &quot;CREATE TABLE ...&quot;;</code></li>
<li><code>stat.addBatch(command);</code></li>
<li><code>while  (...)  {</code></li>
<li><code>command =  &quot;INSERT INTO ... VALUES (&quot;  +  ...  +  &quot;)&quot;;</code></li>
<li><code>stat.addBatch(command);</code></li>
<li><code>}</code></li>
<li><code>int[] counts = stat.executeBatch();</code></li>
</ol>
<p><strong>java.sql.Connection 1.1</strong></p>
<ol>
<li><code>boolean getAutoCommit()</code></li>
<li><code>void setAutoCommit(boolean b)  //获取该连接中的自动提交模式，或将其设置为b</code></li>
<li><code>void commit()  //提交自上次提交以来所有执行过的语句</code></li>
<li><code>void rollback()  //撤销自上次提交以来所有执行过的语句所产生的影响</code></li>
<li><code>Savepoint setSavepoint()</code></li>
<li><code>Savepoint setSavepoint(String name)  //设置一个匿名或具名的保存点</code></li>
<li><code>void rollback(Savepoint svpt)  //回滚到给定保存点</code></li>
<li><code>void releaseSavepoint(Savepoint svpt)  //释放给定的保存点</code></li>
</ol>
<p><strong>java.sql.Savepoint 1.4</strong></p>
<ol>
<li><code>int getSavepointId()  //获取该匿名保存点的ID号，如果有名字则抛出SQLException异常</code></li>
<li><code>String getSavepointName()  //获取该保存点的名称，如果为匿名保存点则抛出SQLException异常</code></li>
</ol>
<p><strong>java.sql.Statement 1.1</strong></p>
<ol>
<li><code>void addBatch(String command)  //添加命令到当前批量命令中</code></li>
<li><code>int[] executeBatch()  //执行当前批量更新中的所有命令，返回一个记录数的数组</code></li>
</ol>
<p><strong>java.sql.DatabaseMetaData 1.1</strong></p>
<ol>
<li><code>boolean supportsBatchUpdates()  //如果驱动程序支持批量更新，返回true</code></li>
</ol>
<p><strong>Web与企业应用中的连接管理</strong></p>
<p>通过目录接口（JNDI）查找</p>
<ol>
<li><code>Context jndiContext =  new  InitialContext();</code></li>
<li><code>DataSource source =  (DataSource) jndiContext.lookup(&quot;java:comp/env/jdbc/corejava&quot;);</code></li>
<li><code>Connection conn = source.getConnection();</code></li>
</ol>
<p><strong>LDAP介绍</strong></p>
<p>轻量级目录访问协议（Lightweight Directory Access Protocol, LDAP）</p>
<p>通用的LDAP属性</p>
<p>| 属性ID     | 意义     |<br>| dc     | 域构件     |<br>| cn     | 通用名     |<br>| sn     | 姓     |<br>| dn     | 专有名称     |<br>| o     | 组织 |<br>| ou     | 组织单元     |<br>| uid     | 唯一标识符 |</p>
<p>访问LDAP目录信息</p>
<ol>
<li><code>Hashtable env =  new  Hashtable();</code></li>
<li><code>env.put(Context.SECURITY_PRINCIPAL, username);</code></li>
<li><code>env.put(Context.SECURITY_CREDENTIALS, password);</code></li>
<li><code>DirContext initial =  new  InitialDirContext(env);</code></li>
<li><code>DirContext context =  (DirContext) initial.lookup(&quot;ldap://localhost:389&quot;);</code></li>
</ol>
<p><strong>javax.naming.directory.InitialDirContext 1.3</strong></p>
<ol>
<li><code>InitialDirContext(Hashtable env)  //使用给定的环境设置创建一个目录上下文，散列表包含了Context.SECURITY_PRINCIPAL、Context.SECURITY_CREDENTIALS以及其他键的相关信息</code></li>
</ol>
<p><strong>javax.naming.Context 1.3</strong></p>
<ol>
<li><code>Object lookup(String name)  //使用给定的名称查找对象，返回通常为一棵子树或一个叶对象</code></li>
<li><code>Context createSubcontext(String name)  //使用给定的名字创建一个子上下文</code></li>
<li><code>void destroySubcontext(String name)  //根据给定的名称删除其对应的子上下文</code></li>
<li><code>void close()  //关闭该上下文</code></li>
</ol>
<p><strong>javax.naming.directory.DirContext 1.3</strong></p>
<ol>
<li><code>Attributes getAttributes(String name)  //根据给定的名称，得到其对应条目的属性</code></li>
<li><code>void modifyAttributes(String name,  int flag,  Attributes modes)  //根据给定的名称，修改其对应条目的属性，flag为以下常量之一：DirContext.ADD_ATTRIBUTE、DirContext.REMOVE_ATTRIBUTE或DirContext.REPLACE_ATTRIBUTE</code></li>
</ol>
<p><strong>javax.naming.directory.Attributes 1.3</strong></p>
<ol>
<li><code>Attribute get(String id)  //根据给定的ID，得到其对应的属性</code></li>
<li><code>NamingEnumeration  extends  Attribute&gt; getAll()  //返回一个枚举对象，用于迭代遍历该属性的所有值</code></li>
<li><code>Attribute put(Attribute attr)</code></li>
<li><code>Attribute put(String id,  Object value)  //将一个属性添加到属性集合中</code></li>
</ol>
<p><strong>javax.naming.directory.BasicAttributes 1.3</strong></p>
<ol>
<li><code>BasicAttributes(String id,  Object value)  //使用给定的ID和值，构造一个属性集合，该集合只包含了单个属性</code></li>
</ol>
<p><strong>javax.naming.directory.Attribute 1.3</strong></p>
<ol>
<li><code>String getId()  //获取该属性的ID</code></li>
<li><code>Object get()  //如果值已排好序，则获取该属性的第一个值，未排序则返回其中任意一个值</code></li>
<li><code>NamingEnumeration getAll()  //返回一个枚举对象，用于迭代遍历该属性的所有值</code></li>
</ol>
<p><strong>javax.naming.NamingEnumeration 1.3</strong></p>
<ol>
<li><code>boolean hasMore()  //如果该对象还包含其他元素，返回true</code><br><code>T next()  //返回下一个元素</code></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://b-ssl.duitang.com/uploads/item/201602/18/20160218194039_c2Kmt.jpeg"
               alt="KioLuo" />
          <p class="site-author-name" itemprop="name">KioLuo</p>
           
              <p class="site-description motion-element" itemprop="description">gogogo~</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KioLuo</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
